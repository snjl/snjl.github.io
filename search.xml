<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot：测试，打包，部署]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9A%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%89%93%E5%8C%85%EF%BC%8C%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[开发阶段单元测试 在pom包中添加spring-boot-starter-test包引用 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 开发测试类 以最简单的helloworld为例，在测试类的类头部需要添加：@RunWith(SpringRunner.class)和@SpringBootTest注解，在测试方法的顶端添加@Test即可，最后在方法上点击右键run就可以运行。 12345678910@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Test public void hello() &#123; System.out.println("hello world"); &#125;&#125; 实际使用中，可以按照项目的正常使用去注入dao层代码或者是service层代码进行测试验证，spring-boot-starter-test提供很多基础用法，更难得的是增加了对Controller层测试的支持。123456//简单验证结果集是否正确Assert.assertEquals(3, userMapper.getAll().size());//验证结果集，提示Assert.assertTrue("错误，正确的返回值为200", status == 200); Assert.assertFalse("错误，正确的返回值为200", status != 200); 引入了MockMvc支持了对Controller层的测试，简单示例如下：12345678910111213141516171819202122232425262728public class HelloControlerTests &#123; private MockMvc mvc; //初始化执行 @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; //验证controller是否正常响应并打印返回结果 @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125; //验证controller是否正常响应并判断返回结果是否正确 @Test public void testHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 单元测试是验证你代码第一道屏障，要养成每写一部分代码就进行单元测试的习惯，不要等到全部集成后再进行测试，集成后因为更关注整体运行效果，很容易遗漏掉代码底层的bug。 打包一般分为两种；一种是打包成jar包直接执行，另一种是打包成war包放到tomcat服务器下。 jar包如果你使用的是maven来管理项目，执行以下命令既可以12345cd 项目跟目录（和pom.xml同级）mvn clean package## 或者执行下面的命令## 排除测试代码后进行打包mvn clean package -Dmaven.test.skip=true 打包完成后jar包会生成到target目录下，命名一般是 项目名+版本号.jar 弃用jar包命令：1java -jar target/spring-boot-scheduler-1.0.0.jar 这种方式，只要控制台关闭，服务就不能访问了。下面我们使用在后台运行的方式来启动:1nohup java -jar target/spring-boot-scheduler-1.0.0.jar &amp; 也可以在启动的时候选择读取不同的配置文件1java -jar app.jar --spring.profiles.active=dev 也可以在启动的时候设置jvm参数1java -Xms10m -Xmx80m -jar app.jar &amp; 打成war包打成war包一般可以分两种方式来实现，第一种可以通过eclipse这种开发工具来导出war包，另外一种是使用命令来完成，这里主要介绍后一种 maven项目，修改pom包 将1&lt;packaging&gt;jar&lt;/packaging&gt; 改为1&lt;packaging&gt;war&lt;/packaging&gt; 打包时排除tomcat.123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在这里将scope属性设置为provided，这样在最终形成的WAR中不会包含这个JAR包，因为Tomcat或Jetty等服务器在运行时将会提供相关的API类。 注册启动类 创建ServletInitializer.java，继承SpringBootServletInitializer ，覆盖configure()，把启动类Application注册进去。外部web应用服务器构建Web Application Context的时候，会把启动类添加进去。123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125;&#125; 最后执行1mvn clean package -Dmaven.test.skip=true 会在target目录下生成：项目名+版本号.war文件，拷贝到tomcat服务器中启动即可。 生产运维查看JVM参数可以根据java自带的jinfo命令：1jinfo -flags pid 来查看jar 启动后使用的是什么gc、新生代、老年代分批的内存都是多少，示例如下：1-XX:CICompilerCount=3 -XX:InitialHeapSize=234881024 -XX:MaxHeapSize=3743416320 -XX:MaxNewSize=1247805440 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=78118912 -XX:OldSize=156762112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC -XX:CICompilerCount ：最大的并行编译数 -XX:InitialHeapSize 和 -XX:MaxHeapSize ：指定JVM的初始和最大堆内存大小 -XX:MaxNewSize ： JVM堆区域新生代内存的最大可分配大小 … -XX:+UseParallelGC ：垃圾回收使用Parallel收集器 重启直接kill掉进程再次启动jar包12345ps -ef|grep java ##拿到对于Java程序的pidkill -9 pid## 再次重启Java -jar xxxx.jar 脚本执行如果使用的是maven,需要包含以下的配置1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt;&lt;/plugin&gt; 启动方式： 可以直接./yourapp.jar 来启动 注册为服务 也可以做一个软链接指向你的jar包并加入到init.d中，然后用命令来启动。 init.d 例子:12ln -s /var/yourapp/yourapp.jar /etc/init.d/yourappchmod +x /etc/init.d/yourapp 这样就可以使用stop或者是restart命令去管理你的应用。1/etc/init.d/yourapp start|stop|restart 或者1service yourapp start|stop|restart]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>部署</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：mybatis多数据源]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Amybatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mulidatasource.git 配置文件数据库配置：123456789101112mybatis.config-locations=classpath:mybatis/mybatis-config.xmlspring.datasource.test1.driverClassName = com.mysql.jdbc.Driverspring.datasource.test1.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.test1.username = rootspring.datasource.test1.password = 123456spring.datasource.test2.driverClassName = com.mysql.jdbc.Driverspring.datasource.test2.url = jdbc:mysql://localhost:3306/spring2?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.test2.username = rootspring.datasource.test2.password = 123456 一个test1库和一个test2库，其中test1位主库，在使用的过程中必须指定主库，不然会报错。 数据源配置123456789101112131415161718192021222324252627282930313233@Configuration@MapperScan(basePackages = "com.neo.mapper.test1", sqlSessionTemplateRef = "test1SqlSessionTemplate")public class DataSource1Config &#123; @Bean(name = "test1DataSource") @ConfigurationProperties(prefix = "spring.datasource.test1") @Primary public DataSource testDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = "test1SqlSessionFactory") @Primary public SqlSessionFactory testSqlSessionFactory(@Qualifier("test1DataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mybatis/mapper/test1/*.xml")); return bean.getObject(); &#125; @Bean(name = "test1TransactionManager") @Primary public DataSourceTransactionManager testTransactionManager(@Qualifier("test1DataSource") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = "test1SqlSessionTemplate") @Primary public SqlSessionTemplate testSqlSessionTemplate(@Qualifier("test1SqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 最关键的地方就是这块了，一层一层注入,首先创建DataSource，然后创建SqlSessionFactory再创建事务，最后包装到SqlSessionTemplate中。其中需要指定分库的mapper文件地址，以及分库dao层代码1@MapperScan(basePackages = "com.neo.mapper.test1", sqlSessionTemplateRef = "test1SqlSessionTemplate") 这块的注解就是指明了扫描dao层，并且给dao层注入指定的SqlSessionTemplate。所有@Bean都需要按照命名指定正确。 dao层和xml层dao层和xml需要按照库来分在不同的目录，比如：test1库dao层在com.neo.mapper.test1包下，test2库在com.neo.mapper.test112345678910111213public interface User1Mapper &#123; List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id);&#125; xml层：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.neo.mapper.test1.User1Mapper" &gt; &lt;resultMap id="BaseResultMap" type="com.neo.entity.UserEntity" &gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="userName" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="passWord" property="passWord" jdbcType="VARCHAR" /&gt; &lt;result column="user_sex" property="userSex" javaType="com.neo.enums.UserSexEnum"/&gt; &lt;result column="nick_name" property="nickName" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, passWord, user_sex, nick_name &lt;/sql&gt; &lt;select id="getAll" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users &lt;/select&gt; &lt;select id="getOne" parameterType="java.lang.Long" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insert" parameterType="com.neo.entity.UserEntity" &gt; INSERT INTO users (userName,passWord,user_sex) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;) &lt;/insert&gt; &lt;update id="update" parameterType="com.neo.entity.UserEntity" &gt; UPDATE users SET &lt;if test="userName != null"&gt;userName = #&#123;userName&#125;,&lt;/if&gt; &lt;if test="passWord != null"&gt;passWord = #&#123;passWord&#125;,&lt;/if&gt; nick_name = #&#123;nickName&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="delete" parameterType="java.lang.Long" &gt; DELETE FROM users WHERE id =#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; controller测试可以使用SpringBootTest,也可以放到Controller中，这里只贴Controller层的使用12345678910111213141516171819202122232425262728293031323334353637@RestControllerpublic class UserController &#123; @Autowired private User1Mapper user1Mapper; @Autowired private User2Mapper user2Mapper; @RequestMapping("/getUsers") public List&lt;UserEntity&gt; getUsers() &#123; List&lt;UserEntity&gt; users=user1Mapper.getAll(); return users; &#125; @RequestMapping("/getUser") public UserEntity getUser(Long id) &#123; UserEntity user=user2Mapper.getOne(id); return user; &#125; @RequestMapping("/add") public void save(UserEntity user) &#123; user2Mapper.insert(user); &#125; @RequestMapping(value="update") public void update(UserEntity user) &#123; user2Mapper.update(user); &#125; @RequestMapping(value="/delete/&#123;id&#125;") public void delete(@PathVariable("id") Long id) &#123; user1Mapper.delete(id); &#125; &#125; 测试 分别用的是数据源1，数据源2。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：随机端口]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[为Spring Cloud的应用实用随机端口非常简单，主要有两种方法： 设置server.port=0，当应用启动的时候会自动的分配一个随机端口，但是该方式在注册到Eureka的时候会一个问题：所有实例都使用了同样的实例名（如：Lenovo-test:hello-service:0），这导致只出现了一个实例。所以，我们还需要修改实例ID的定义，让每个实例的ID不同，比如使用随机数来配置实例ID：12server.port=0eureka.instance.instance-id=$&#123;spring.application.name&#125;:$&#123;random.int&#125; 除了上面的方法，实际上我们还可以直接使用random函数来配置server.port。这样就可以指定端口的取值范围，比如：1server.port=$&#123;random.int[10000,19999]&#125; 由于默认的实例ID会由server.port拼接，而此时server.port设置的随机值会重新取一次随机数，所以使用这种方法的时候不需要重新定义实例ID的规则就能产生不同的实例ID了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：thymeleaf设置不校验html标签]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Athymeleaf%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%A0%A1%E9%AA%8Chtml%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[默认配置下，thymeleaf对.html的内容要求很严格，比如，如果少封闭符号/，就会报错而转到错误页。也比如你在使用Vue.js这样的库，然后有这样的html代码，也会被thymeleaf认为不符合要求而抛出错误。 通过设置thymeleaf模板可以解决这个问题，下面是具体的配置:12spring.thymeleaf.cache=falsespring.thymeleaf.mode=LEGACYHTML5 LEGACYHTML5需要搭配一个额外的库NekoHTML才可用 项目中使用的构建工具是Maven添加如下的依赖即可完成: 12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：task定时任务（二）]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Atask%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.springtask2.git pom包配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 启动类启用定时在启动类上面加上@EnableScheduling即可开启定时12345678@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建定时任务实现类定时任务1：1234567891011@Componentpublic class SchedulerTask &#123; private int count=0; @Scheduled(cron="*/6 * * * * ?") private void process()&#123; System.out.println("this is scheduler task runing "+(count++)); &#125;&#125; 定时任务2：1234567891011@Componentpublic class Scheduler2Task &#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + dateFormat.format(new Date())); &#125;&#125; 结果如下：12345678this is scheduler task runing 0现在时间：09:44:17this is scheduler task runing 1现在时间：09:44:23this is scheduler task runing 2现在时间：09:44:29this is scheduler task runing 3现在时间：09:44:35 参数说明@Scheduled 参数可以接受两种定时的设置，一种是我们常用的cron=”/6 * ?”,一种是 fixedRate = 6000，两种都表示每隔六秒打印一下内容。 fixeRate说明 @Scheduled(fixedRate = 6000) ：上一次开始执行时间点之后6秒再执行 @Scheduled(fixedDelay = 6000) ：上一次执行完毕时间点之后6秒再执行 @Scheduled(initialDelay=1000, fixedRate=6000) ：第一次延迟1秒后执行，之后按fixedRate的规则每6秒执行一次]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：解决分页插件ClassNotFoundException]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6ClassNotFoundException%2F</url>
    <content type="text"><![CDATA[报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration&apos;: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration] from ClassLoader [sun.misc.Launcher$AppClassLoader@2f4d3709]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:558) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:503) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:760) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at com.lee.www.DemoApplication.main(DemoApplication.java:14) [classes/:na]at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_161]at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_161]at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_161]at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_161]at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) [idea_rt.jar:na]Caused by: java.lang.IllegalStateException: Failed to introspect Class [com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration] from ClassLoader [sun.misc.Launcher$AppClassLoader@2f4d3709]at org.springframework.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:758) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.util.ReflectionUtils.doWithLocalFields(ReflectionUtils.java:690) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.buildResourceMetadata(CommonAnnotationBeanPostProcessor.java:355) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.findResourceMetadata(CommonAnnotationBeanPostProcessor.java:339) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(CommonAnnotationBeanPostProcessor.java:298) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(AbstractAutowireCapableBeanFactory.java:1022) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]... 20 common frames omittedCaused by: java.lang.NoClassDefFoundError: Lorg/springframework/boot/bind/RelaxedPropertyResolver;at java.lang.Class.getDeclaredFields0(Native Method) ~[na:1.8.0_161]at java.lang.Class.privateGetDeclaredFields(Class.java:2583) ~[na:1.8.0_161]at java.lang.Class.getDeclaredFields(Class.java:1916) ~[na:1.8.0_161]at org.springframework.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:753) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]... 26 common frames omittedCaused by: java.lang.ClassNotFoundException: org.springframework.boot.bind.RelaxedPropertyResolverat java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_161]at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_161]at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) ~[na:1.8.0_161]at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_161]... 30 common frames omitted 重点是ClassNotFoundException: org.springframework.boot.bind.RelaxedPropertyResolver。 原版本为：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt; 升级为1.2.3即可：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：日期错误Zero date value prohibited 异常的解决方法]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E6%97%A5%E6%9C%9F%E9%94%99%E8%AF%AFZero-date-value-prohibited-%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实际的错误还应该有：java.sql.SQLException: Value ‘0000-00-00’ can not be represented as java.sql.Date 更改jdbc连接为：1jdbc:mysql://yourserver:3306/yourdatabase?zeroDateTimeBehavior=convertToNull 即设置zeroDateTimeBehavior=convertToNull 设置zeroDateTimeBehavior 属性，当遇到DATETIME值完全由0组成时，最终的有效值可以设置为，异常(exception)，一个近似值(round)，或将这个值转换为null(convertToNull)。 使用convertToNull，返回null来替代0000-00-00这样的日期。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：项目修改访问端口和访问路径]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3%E5%92%8C%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[创建SpringBoot项目，启动后，默认的访问路径即主机IP+默认端口号8080。 修改端口号使用properties文件方式：在src/main/resoutces目录下创建：application.properties，添加如下配置即可修改端口号：1server.port=8088 使用yml文件方式：在src/main/resoutces目录下创建：application.yml，添加如下配置即可修改端口号：12server: port:8088 修改项目访问路径使用properties文件方式：在application.properties，添加如下配置即可修改项目访问路径：1server.servlet.context-path=/test 使用yml文件方式：在src/main/resoutces目录下创建：application.yml，添加如下配置即可修改端口号：1234server: port:8088 servlet: context-path:/test]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：报错Invalid CORS request， CORS 跨域请求设置]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E6%8A%A5%E9%94%99Invalid-CORS-request%EF%BC%8C-CORS-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot提供的跨域配置有两种，一种是全局的，一种是具体到方法的。如果同时配置了那么具体方法的优先。 全局跨域配置提供一个自定义的WebMvcConfigurer bean，该bean的addCorsMappings方法中定义自己的跨域配置。可以看到我的跨域配置是允许来自http://localhost:6677访问/user/users/*的方法。等程序运行后我们可以发现如果我们的前端使用http://127.0.0.1:6677 或者我们的前端运行在http://localhost:8080都无法通过rest访问对应的API（备注，示例程序提供了/user/users和/user/users/{userId}方法）1234567891011121314151617181920212223242526package com.yq;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@SpringBootApplicationpublic class CorsDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CorsDemoApplication.class, args); &#125; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**").allowedOrigins("http://localhost:6677"); &#125; &#125;; &#125;&#125; 此处，设置addMapping是设置访问路径（pathPattern—），设置了可以被跨域访问的路径和可以被哪些主机跨域访问，而不是设置包的路径。即包名为app.api.controller，但是controller里面的地址设置为/user/paper/，/user/user/，则这里应该写为/user/**。 具体方法的跨域配置@CrossOrigin我们可以使用@CrossOrigin在具体的API上配置跨域设置。@CrossOrigin(origins = “http://localhost:9000”)表明该方法允许来自http://localhost:9000访问，也就是前端可以是localhost:9000。1234567@ApiOperation(value = "查询所有用户") @CrossOrigin(origins = "http://localhost:9000") @GetMapping(value = "/users", produces = "application/json;charset=UTF-8") public Iterable&lt;User&gt; findAllUsers() &#123; Collection&lt;User&gt; users = userMap.values(); return users; &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web项目中的dao，service层的接口的必要性]]></title>
    <url>%2F2018%2F12%2F01%2Fjava-web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84dao%EF%BC%8Cservice%E5%B1%82%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[参考：https://www.jianshu.com/p/64abdd29bdf6 https://www.zhihu.com/question/36021012 DAO接口为每个DAO声明接口的好处在于： 可以在尚未实现具体DAO的时候编写上层代码,如Service里对DAO的调用可以为DAO进行多实现,例如有JDBCDAO实现,MyBatisDAO实现,而不需要更改上层代码,只需要简单的在Spring的IoC配置里修改一下注入的DAO实现 Service接口 可以在尚未实现具体Service情况下编写上层改代码,如Controller对Service的调用Spring无论是AOP还是事务管理的实现都是基于动态代理的,而动态代理的实现依赖于接口,所以必须有接口的定义才能使用这些功能可以对Service进行多实现总的来说,接口的优势就在于规范方法参数,返回值,另外可以实现多态,结合Spring来说接口对于使用Spring的各种功能也是不可或缺的 另外,使用接口对于测试代码也是有好处的,对于mock一个方法来说,我们不需要关注方法的具体实现,因为本来mock就会将方法内部实现置空,我们的关注点集中于方法参数以及返回值,所以使用接口对于快速实现流程上的测试是有好处的. 使用接口是为了调用与实现解耦，带来的好处是可以各干各的了，带来的坏处是从一个概念变成了两个概念，增加了系统的复杂度。衡量一下在具体场景中是弊大于利还是利大于弊，就可以做选择了。当然，在大部分场景下，还要考虑一个因素，就是你会不会写接口。没有良好接口设计能力的人，写出来的接口抽象不合理，等于没写，什么好处都得不到，只有坏处，这种情况下干脆别写。那怎么衡量你会不会写接口呢，我的经验是，至少见过一次写了接口后得到明确好处的例子。 什么情况下需要各干各的？ 最简单的场景，写接口的是你，写实现的是你小弟。当然大多数类似情况没必要真的建一个interface然后再让人家去implements，把函数的第一行写好，注释写好，代码提交上，里面的内容让小弟去填就行了。 另一种情况，调用代码先于实现代码编写。比如你开发的是struts这种东西，那你指定得搞个Action接口。 再一种情况，多种业务的模式类似。此时这个接口类实际上相当于某一层的抽象。定义出一个层后，有多种实现，然后通过向调用端注入不同的实现类，实现不同的逻辑。如果这种注入不能在编译期完成的话，也就需要用接口抽象一下。 上面这几种情况写得有点绕，没办法，太难表述了并且好多事我自己也没想明白…… 说到题目中的场景。 先说dao，这玩意儿是做数据库读写的。对应一下上面那几种情况：你作为项目架构师想写两行代码就让苦逼小弟加班干活然则自己去泡妹子的话，可能需要写个interface里面几个抽象的insert、delete之类的函数；项目在快速原型阶段如果客户满意就掏钱买oracle如果客户不满意就得免费MySQL的话，你可能需要定义个dao接口然后先用内存数据库写点能让原型跑起来的实现，等一切有定论了再说；每个类都有一个dao，每个dao都有crud基本方法的话你可能需要定义一个通用Dao接口然后搞点代码技巧不用一个个的去写体力代码从此登上人生巅峰。所以dao接口还是有用的。 再说service，这玩意儿更得具体问题具体分析。不去抠理论的话，什么是service，我的理解就是一段段实现了某个逻辑的代码的组合。所以service是个比dao更抽象的概念，严格来讲dao就是一种service。只不过在java web开发中，dao是个人人都得写的东西，所以都拿出来单说了。因此，后面说的service跟dao没有本质分别。 还是上面说的那几种情况： 先从工序上说，你在写上一层的时候，会用到下一层提供的逻辑，具体表现形式就是各种各样的service类和里面的方法。上一层开搞的时候，一定会知道的一个事是下一层会干什么事，比如“将传入编号对应的人员信息设置为离职”，但下一层的代码不一定已经一行一行写出来了。所以这会儿需要有个接口，让写上层代码的人先能把代码写下去。有各种理由可以支持这种工序的合理性，比如一般来说，上一层的一行代码会对应下一层的好多行代码，那先让写上层代码的人写一遍，解决高端层面的bug，会提高很多效率。 再从抽象角度说，不同业务模块之间的共用，不一定是共用某段代码，也可能是共用某段逻辑框架，这时候就需要抽象一个接口层出来，再通过不同的注入逻辑实现。比如模块1是登记学生信息，模块2是新闻发布，看上去风马牛不相及。但分析下来如果两个模块都有共同点，顺序都是1、验证是否有权限 2、验证输入参数是否合法 3、将输入参数转化为业务数据 4、数据库存取 5、写log，那就可以写一个service接口，里面有上述5个函数，再分别写两个service实现。具体执行的时候，通过各种注入方法，直接new也好，用spring注入也好，实现不同的效果。 当然上面说的这种情况很少有人这么干，因为已经普遍到这个程度，再精化精化就是struts了，java web的各种mvc框架都提供机制给你干这个事。但是每个项目或产品，都应该可以用类似的思路抽象出一些东西，如果抽象合理，会很大程度的提高项目架构的合理性。 这些要是能搞定，那什么写个接口然后实现个mock用于测试这种事，信手拈来。 JavaWeb 开发中，服务器端通常分为表示层、业务层、持久层，这就是所谓的三层架构。三层架构的每一层都有自己的开发模式，即架构模式。 其中，表示层一般是采用 MVC 架构模式，业务层有事务脚本模式、领域模型模式等，持久层有数据映射器模式（Hibernate即是典型的）、入口模式（iBatis、JDBC）。企业应用中最关键的显然是业务层。而对于初学者来说，事务脚本模式是最为简单，最容易掌握的。如果开发团队面向对象设计能力一般，而且业务逻辑相对简单，业务层一般都会采用事务脚本模式。为嘛？简单呀，是个人都能很快学会！（当然，如果业务逻辑复杂，用事务脚本模式就很不明智了。嗯，简单点讲，就是违背了单一职责设计原则，Service类成为万能的上帝，承担了太多职责。。。）那么什么是事务脚本模式呢？所谓事务，就是表示层的一个请求；所谓脚本就是一个方法或者一个函数；所谓事务脚本就是将一次请求封装为一个方法或者一个函数。 在事务脚本模式中，有三类对象。其中，Service类封装业务流程（或者说是界面上的业务流程），DAO类封装对持久层的访问，DTO类封装业务实体对象。各个对象之间的关系如上图所示，这就是所谓业务逻辑的组织方式。 为什么要用Service接口和DAO接口？我们还得回到最基本的面向对象设计原则上去。面向对象设计原则中有三条与此相关：开闭原则、依赖倒转原则、理氏替换原则。还记得依赖倒转原则吧？高层不依赖于低层，二者都依赖于抽象，也就是面向接口编程。为什么要用Service接口？是让表示层不依赖于业务层的具体实现。为什么要用DAO接口？是让业务层不依赖于持久层的具体实现。有了这两个接口，Spring IOC容器才能发挥作用。举个例子，用DAO接口，那么持久层用Hibernate，还是用iBatis，还是 JDBC，随时可以替换，不用修改业务层Service类的代码。使用接口的意义就在此。]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>理论</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：使用Swagger2构建强大的RESTful API文档]]></title>
    <url>%2F2018%2F12%2F01%2Fspringboot%EF%BC%9A%E4%BD%BF%E7%94%A8Swagger2%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84RESTful-API%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.swagger2.git 由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。 这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示： 添加Swagger2依赖在pom.xml中加入Swagger2的依赖：12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger2：12345678910111213141516171819202122232425262728293031323334353637package com.didispace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.didispace.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("更多Spring Boot相关文章请关注：https://snjl.github.io/") .termsOfServiceUrl("https://snjl.github.io/") .contact("snjl") .version("1.0") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.didispace.web;import com.didispace.domain.User;import java.util.*;import io.swagger.annotations.*;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125; 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。 API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！ 此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。 相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：数据存储篇-SQL关系型数据库之MyBatis的使用]]></title>
    <url>%2F2018%2F12%2F01%2Fspringboot%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87-SQL%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMyBatis%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mybatis.git 添加依赖这里需要添加mybatis-spring-boot-starter依赖跟mysql依赖：1234567891011 &lt;!--最新版本，匹配spring Boot1.5 or higher--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖。 MyBatis-Spring-Boot-Starter依赖将会提供如下： 自动检测现有的DataSource 将创建并注册SqlSessionFactory的实例，该实例使用SqlSessionFactoryBean将该DataSource作为输入进行传递 将创建并注册从SqlSessionFactory中获取的SqlSessionTemplate的实例。 自动扫描您的mappers，将它们链接到SqlSessionTemplate并将其注册到Spring上下文，以便将它们注入到您的bean中。 就是说，使用了该Starter之后，只需要定义一个DataSource即可（application.properties中可配置），它会自动创建使用该DataSource的SqlSessionFactoryBean以及SqlSessionTemplate。会自动扫描你的Mappers，连接到SqlSessionTemplate，并注册到Spring上下文中。 数据源配置在src/main/resources/application.properties中配置数据源信息：1234spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = rootspring.datasource.driver-class-name = com.mysql.jdbc.Driver 自定义数据源Spring Boot默认使用tomcat-jdbc数据源，如果你想使用其他的数据源，比如这里使用了阿里巴巴的数据池管理,除了在application.properties配置数据源之外，你应该额外添加以下依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt;&lt;/dependency&gt; 修改Application.java：1234567891011121314151617181920212223242526@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Autowired private Environment env; //destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty("spring.datasource.url")); dataSource.setUsername(env.getProperty("spring.datasource.username"));//用户名 dataSource.setPassword(env.getProperty("spring.datasource.password"));//密码 dataSource.setDriverClassName(env.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2);//初始化时建立物理连接的个数 dataSource.setMaxActive(20);//最大连接池数量 dataSource.setMinIdle(0);//最小连接池数量 dataSource.setMaxWait(60000);//获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery("SELECT 1");//用来检测连接是否有效的sql dataSource.setTestOnBorrow(false);//申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true);//建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false);//是否缓存preparedStatement，也就是PSCache return dataSource; &#125;&#125; Spring Boot会智能地选择我们自己配置的这个DataSource实例。 注解方式跟XML配置方式共同的模块编码不管是注解方式还是XML配置的方式，以下代码模块都是一样的：pojo类：1234567public class LearnResouce &#123; private Long id; private String author; private String title; private String url; // SET和GET方法&#125; Controller:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.dudu.controller;import com.alibaba.fastjson.JSONObject;import com.dudu.domain.LearnResouce;import com.dudu.service.LearnService;import com.dudu.tools.ServletUtil;import com.dudu.tools.StringUtil;import com.github.pagehelper.PageInfo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** 教程页面 * Created by tengj on 2017/3/13. */@Controller@RequestMapping("/learn")public class LearnController &#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn()&#123; return "learn-resource"; &#125; @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST,produces="application/json;charset=UTF-8") @ResponseBody public void queryLearnList(HttpServletRequest request ,HttpServletResponse response)&#123; String page = request.getParameter("page"); // 取得当前页数,注意这是jqgrid自身的参数 String rows = request.getParameter("rows"); // 取得每页显示行数，,注意这是jqgrid自身的参数 String author = request.getParameter("author"); String title = request.getParameter("title"); Map&lt;String,Object&gt; params = new HashMap&lt;String,Object&gt;(); params.put("page", page); params.put("rows", rows); params.put("author", author); params.put("title", title); List&lt;LearnResouce&gt; learnList=learnService.queryLearnResouceList(params); PageInfo&lt;LearnResouce&gt; pageInfo =new PageInfo&lt;LearnResouce&gt;(learnList); JSONObject jo=new JSONObject(); jo.put("rows", learnList); jo.put("total", pageInfo.getPages());//总页数 jo.put("records",pageInfo.getTotal());//查询出的总记录数 ServletUtil.createSuccessResponse(200, jo, response); &#125; /** * 新添教程 * @param request * @param response */ @RequestMapping(value = "/add",method = RequestMethod.POST) public void addLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; LearnResouce learnResouce = new LearnResouce(); learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.add(learnResouce); if(index&gt;0)&#123; result.put("message","教程信息添加成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息添加失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 修改教程 * @param request * @param response */ @RequestMapping(value = "/update",method = RequestMethod.POST) public void updateLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String id = request.getParameter("id"); LearnResouce learnResouce=learnService.queryLearnResouceById(Long.valueOf(id)); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.update(learnResouce); System.out.println("修改结果="+index); if(index&gt;0)&#123; result.put("message","教程信息修改成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息修改失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 删除教程 * @param request * @param response */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public void deleteUser(HttpServletRequest request ,HttpServletResponse response)&#123; String ids = request.getParameter("ids"); System.out.println("ids==="+ids); JSONObject result = new JSONObject(); //删除操作 int index = learnService.deleteByIds(ids.split(",")); if(index&gt;0)&#123; result.put("message","教程信息删除成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息删除失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125;&#125; Service:12345678package com.dudu.service;public interface LearnService &#123; int add(LearnResouce learnResouce); int update(LearnResouce learnResouce); int deleteByIds(String[] ids); LearnResouce queryLearnResouceById(Long learnResouce); List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params);&#125; 实现类：123456789101112131415161718192021222324252627282930313233343536 package com.dudu.service.impl;/** * Created by tengj on 2017/4/7. */ @Service public class LearnServiceImpl implements LearnService &#123; @Autowired LearnMapper learnMapper; @Override public int add(LearnResouce learnResouce) &#123; return this.learnMapper.add(learnResouce); &#125; @Override public int update(LearnResouce learnResouce) &#123; return this.learnMapper.update(learnResouce); &#125; @Override public int deleteByIds(String[] ids) &#123; return this.learnMapper.deleteByIds(ids); &#125; @Override public LearnResouce queryLearnResouceById(Long id) &#123; return this.learnMapper.queryLearnResouceById(id); &#125; @Override public List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; PageHelper.startPage(Integer.parseInt(params.get("page").toString()), Integer.parseInt(params.get("rows").toString())); return this.learnMapper.queryLearnResouceList(params); &#125; &#125; Mybatis集成方案一：注解方式Mybatis注解的方式简单，只要定义一个dao接口，然后sql语句通过注解写在接口方法上。最后给这个接口添加@Mapper注解或者在启动类上添加@MapperScan(“com.dudu.dao”)注解都行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.dudu.dao;import com.dudu.domain.LearnResouce;import com.dudu.tools.StringUtil;import org.apache.ibatis.annotations.*;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/22. * Component注解不添加也没事，只是不加service那边引入LearnMapper会有错误提示，但不影响 */@Component@Mapperpublic interface LearnMapper &#123; @Insert("insert into learn_resource(author, title,url) values(#&#123;author&#125;,#&#123;title&#125;,#&#123;url&#125;)") int add(LearnResouce learnResouce); @Update("update learn_resource set author=#&#123;author&#125;,title=#&#123;title&#125;,url=#&#123;url&#125; where id = #&#123;id&#125;") int update(LearnResouce learnResouce); @DeleteProvider(type = LearnSqlBuilder.class, method = "deleteByids") int deleteByIds(@Param("ids") String[] ids); @Select("select * from learn_resource where id = #&#123;id&#125;") @Results(id = "learnMap", value = &#123; @Result(column = "id", property = "id", javaType = Long.class), @Result(property = "author", column = "author", javaType = String.class), @Result(property = "title", column = "title", javaType = String.class) &#125;) LearnResouce queryLearnResouceById(@Param("id") Long id); @SelectProvider(type = LearnSqlBuilder.class, method = "queryLearnResouceByParams") List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params); class LearnSqlBuilder &#123; public String queryLearnResouceByParams(final Map&lt;String, Object&gt; params) &#123; StringBuffer sql =new StringBuffer(); sql.append("select * from learn_resource where 1=1"); if(!StringUtil.isNull((String)params.get("author")))&#123; sql.append(" and author like '%").append((String)params.get("author")).append("%'"); &#125; if(!StringUtil.isNull((String)params.get("title")))&#123; sql.append(" and title like '%").append((String)params.get("title")).append("%'"); &#125; System.out.println("查询sql=="+sql.toString()); return sql.toString(); &#125; //删除的方法 public String deleteByids(@Param("ids") final String[] ids)&#123; StringBuffer sql =new StringBuffer(); sql.append("DELETE FROM learn_resource WHERE id in("); for (int i=0;i&lt;ids.length;i++)&#123; if(i==ids.length-1)&#123; sql.append(ids[i]); &#125;else&#123; sql.append(ids[i]).append(","); &#125; &#125; sql.append(")"); return sql.toString(); &#125; &#125;&#125; 需要注意的是，简单的语句只需要使用@Insert、@Update、@Delete、@Select这4个注解即可，但是有些复杂点需要动态SQL语句，就比如上面方法中根据查询条件是否有值来动态添加sql的，就需要使用@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider等注解。 这些可选的 SQL 注解允许你指定一个类名和一个方法在执行时来返回运行 允许创建动态 的 SQL。 基于执行的映射语句, MyBatis 会实例化这个类,然后执行由 provider 指定的方法. 该方法可以有选择地接受参数对象.(In MyBatis 3.4 or later, it’s allow multiple parameters) 属性: type,method。type 属性是类。method 属性是方法名。 注意: 这节之后是对 类的 讨论,它可以帮助你以干净,容于阅读 的方式来构建动态 SQL。 方案二：XML配置方式xml配置方式保持映射文件的老传统，优化主要体现在不需要实现dao的是实现层，系统会自动根据方法名在映射文件中找对应的sql，具体操作如下： 编写Dao层的代码新建LearnMapper接口，无需具体实现类。123456789package com.dudu.dao;@Mapperpublic interface LearnMapper &#123; int add(LearnResouce learnResouce); int update(LearnResouce learnResouce); int deleteByIds(String[] ids); LearnResouce queryLearnResouceById(Long id); public List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params);&#125; 修改application.properties 配置文件：1234#指定bean所在包mybatis.type-aliases-package=com.dudu.domain#指定映射文件mybatis.mapperLocations=classpath:mapper/*.xml 添加LearnMapper的映射文件: 在src/main/resources目录下新建一个mapper目录，在mapper目录下新建LearnMapper.xml文件。 通过mapper标签中的namespace属性指定对应的dao映射，这里指向LearnMapper。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dudu.dao.LearnMapper"&gt; &lt;resultMap id="baseResultMap" type="com.dudu.domain.LearnResouce"&gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="author" property="author" jdbcType="VARCHAR"/&gt; &lt;result column="title" property="title" jdbcType="VARCHAR"/&gt; &lt;result column="url" property="url" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; &lt;sql id="baseColumnList" &gt; id, author, title,url &lt;/sql&gt; &lt;select id="queryLearnResouceList" resultMap="baseResultMap" parameterType="java.util.HashMap"&gt; select &lt;include refid="baseColumnList" /&gt; from learn_resource &lt;where&gt; 1 = 1 &lt;if test="author!= null and author !=''"&gt; AND author like CONCAT(CONCAT('%',#&#123;author,jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;if test="title != null and title !=''"&gt; AND title like CONCAT(CONCAT('%',#&#123;title,jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="queryLearnResouceById" resultMap="baseResultMap" parameterType="java.lang.Long"&gt; SELECT &lt;include refid="baseColumnList" /&gt; FROM learn_resource WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="add" parameterType="com.dudu.domain.LearnResouce" &gt; INSERT INTO learn_resource (author, title,url) VALUES (#&#123;author&#125;, #&#123;title&#125;, #&#123;url&#125;) &lt;/insert&gt; &lt;update id="update" parameterType="com.dudu.domain.LearnResouce" &gt; UPDATE learn_resource SET author = #&#123;author&#125;,title = #&#123;title&#125;,url = #&#123;url&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteByIds" parameterType="java.lang.String" &gt; DELETE FROM learn_resource WHERE id in &lt;foreach item="idItem" collection="array" open="(" separator="," close=")"&gt; #&#123;idItem&#125; &lt;/foreach&gt; &lt;/delete&gt;&lt;/mapper&gt; 分页插件上面我有使用到物理分页插件pagehelper，用法还算简单，pom.xml中添加依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 然后你只需在查询list之前使用PageHelper.startPage(int pageNum, int pageSize)方法即可。pageNum是第几页，pageSize是每页多少条：12345@Overridepublic List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; PageHelper.startPage(Integer.parseInt(params.get(&quot;page&quot;).toString()), Integer.parseInt(params.get(&quot;rows&quot;).toString())); return this.learnMapper.queryLearnResouceList(params);&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：默认日志logback配置解析]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97logback%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.log.git Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。 默认日志LogbackSLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。 Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。 日志输出内容元素具体如下： 时间日期：精确到毫秒 日志级别：ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符：— 标识实际日志的开始 线程名：方括号括起来（可能会截断控制台输出） Logger名：通常使用源代码的类名 日志内容 添加日志依赖假如maven依赖中添加了spring-boot-starter-logging：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。 但是呢，实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。Thymeleaf依赖包含了spring-boot-starter，所以理论上，如果选择引入Thymeleaf，就不需要引入spring-boot-starter-logging：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 默认配置属性支持Spring Boot为我们提供了很多默认的日志配置，所以，只要将spring-boot-starter-logging作为依赖加入到当前应用的classpath，则“开箱即用”。下面介绍几种在application.properties就可以配置的日志相关属性。 控制台输出日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可： 在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug 在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。 文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log 注：二者不能同时使用，如若同时使用，则只有logging.file生效 默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO。 级别控制所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中）格式为：’logging.level.* = LEVEL’ logging.level：日志级别控制前缀，*为包名或Logger名 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF举例： logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出 logging.level.root=WARN：root日志以WARN级别输出 自定义日志配置由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。 根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载： Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml Log4j2：log4j2-spring.xml, log4j2.xml JDK (Java Util Logging)：logging.properties Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。 上面是默认的命名规则，并且放在src/main/resources下面即可。 如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：1logging.config=classpath:logging-config.xml 虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日志配置，这个功能会很有用。 下面是一个普通的logback-spring.xml例子： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="E:\\test\\logback.log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.dudu.controller"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.dudu.controller.LearnController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 参考：http://tengj.top/2017/04/05/springboot7/]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：静态资源和拦截器处理]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/jdbcTemplete.dudu.static.git 前面章节我们也有简单介绍过SpringBoot中对静态资源的默认支持，今天详细的来介绍下默认的支持，以及自定义扩展如何实现。 默认资源映射Spring Boot 默认为我们提供了静态资源处理，使用 WebMvcAutoConfiguration 中的配置各种属性。建议大家使用Spring Boot的默认配置方式，提供的静态资源映射如下: classpath:/META-INF/resources classpath:/resources classpath:/static classpath:/public 上面这几个都是静态资源的映射路径，优先级顺序为：META-INF/resources &gt; resources &gt; static &gt; public。 可以自己在上面4个路径下都放一张同名的图片，访问一下即可验证。还有，你可以随机在上面一个路径下面放上index.html，当我们访问应用根目录http://lcoalhost:8080 时，会直接映射到index.html页面。 对应的配置文件配置如下：1234# 默认值为 /**spring.mvc.static-path-pattern=# 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开 可以通过修改spring.mvc.static-path-pattern来修改默认的映射，例如我改成/dudu/**,那运行的时候访问http://lcoalhost:8080/dudu/index.html 才对应到index.html页面。 接管Spring Boot的Web配置如果Spring Boot提供的Sping MVC不符合要求，则可以通过一个配置类（注解有@Configuration的类）加上@EnableWebMvc注解来实现完全自己控制的MVC配置。 当然，通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter,无需使用@EnableWebMvc注解。 这里我们提到这个WebMvcConfigurerAdapter这个类，重写这个类中的方法可以让我们增加额外的配置，这里我们就介绍几个常用的。 自定义资源映射addResourceHandlers比如，我们想自定义静态资源映射目录的话，只需重写addResourceHandlers方法即可。123456789101112@Configurationpublic class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter &#123; /** * 配置静态访问资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/my/**").addResourceLocations("classpath:/my/"); super.addResourceHandlers(registry); &#125;&#125; 通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。我们访问自定义my文件夹中的elephant.jpg 图片的地址为：http://localhost:8080/my/elephant.jpg 如果你想指定外部的目录也很简单，直接addResourceLocations指定即可，代码如下：12345@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/my/**").addResourceLocations("file:E:/my/"); super.addResourceHandlers(registry);&#125; addResourceLocations指的是文件放置的目录，addResoureHandler指的是对外暴露的访问路径。 页面跳转addViewControllers以前写SpringMVC的时候，如果需要访问一个页面，必须要写Controller类，然后再写一个方法跳转到页面，感觉好麻烦，其实重写WebMvcConfigurerAdapter中的addViewControllers方法即可达到效果了：12345678910/** * 以前要访问一个页面需要先创建个Controller控制类，再写方法跳转到页面 * 在这里配置后就不需要那么麻烦了，直接访问http://localhost:8080/toLogin就跳转到login.htm页面了 * @param registry */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/toLogin").setViewName("login"); super.addViewControllers(registry); &#125; 值的指出的是，在这里重写addViewControllers方法，并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这也就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是我们推荐添加自己的MVC配置的方式。 拦截器addInterceptors拦截器在我们项目中经常使用的，这里就来介绍下最简单的判断是否登录的使用。要实现拦截器功能需要完成以下2个步骤： 创建我们自己的拦截器类并实现 HandlerInterceptor 接口 其实重写WebMvcConfigurerAdapter中的addInterceptors方法把自定义的拦截器类添加进来即可首先，自定义拦截器代码：1234567891011121314151617181920212223package com.dudu.interceptor;public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; boolean flag =true; User user=(User)request.getSession().getAttribute("user"); if(null==user)&#123; response.sendRedirect("toLogin"); flag = false; &#125;else&#123; flag = true; &#125; return flag; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 这里我们简单实现了根据session中是否有User对象来判断是否登录，为空就跳转到登录页，不为空就通过。 接着，重写WebMvcConfigurerAdapter中的addInterceptors方法如下：1234567891011/*** 拦截器* @param registry*/@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").excludePathPatterns("/toLogin","/login"); super.addInterceptors(registry);&#125; addPathPatterns(“/**”)对所有请求都拦截，但是排除了/toLogin和/login请求的拦截。 页面登录关键代码12345678910111213141516171819//简单登录操作$("#doLogin").click(function (e) &#123; $.ajax(&#123; type : "POST", url : "/login", data : &#123; "userName" : $("#userName").val(), "password" : $("#password").val() &#125;, dataType : "json", success : function(data) &#123; if (data.result == "1") &#123; window.location.href ="/learn"; &#125; else &#123; alert("账号密码不能为空！"); &#125; &#125; &#125;);&#125;); controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.dudu.controller;import com.dudu.domain.LearnResouce;import com.dudu.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.List;/** * Created by tengj on 2017/3/13. */@Controllerpublic class LearnController &#123; @RequestMapping(value = "/login",method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; login(HttpServletRequest request, HttpServletResponse response)&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); String userName=request.getParameter("userName"); String password=request.getParameter("password"); if(!userName.equals("") &amp;&amp; password!="")&#123; User user =new User(userName,password); request.getSession().setAttribute("user",user); map.put("result","1"); &#125;else&#123; map.put("result","0"); &#125; return map; &#125; @RequestMapping("/learn") public ModelAndView index()&#123; List&lt;LearnResouce&gt; learnList =new ArrayList&lt;LearnResouce&gt;(); LearnResouce bean =new LearnResouce("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResouce("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResouce("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResouce("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResouce("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResouce("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResouce("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResouce("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResouce("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResouce("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView("/template"); modelAndView.addObject("learnList", learnList); return modelAndView; &#125;&#125; 这样访问的时候，如果未登录就会跳转到login.html页面，而访问http://localhost:8080/toLogin 和http://localhost:8080/login 不会被拦截。 更多配置可以查看WebMvcConfigurerAdapter的类的API。因其是WebMvcConfigurer接口的实现，所以WebMvcConfigurer的API方法也可以用来配置MVC。 但是只是实现这个接口的话，要实现所有的方法，比较麻烦。 所以还是推荐使用继承WebMvcConfigurerAdapter类来处理。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：spring task定时任务]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9Aspring-task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.springtask.git 创建一个项目，在DemoApplication上加上注解@EnableScheduling：123456789101112131415161718package com.example.demo;import com.example.demo.task.Task;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class DemoApplication &#123; @Autowired private Task task; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 在demo包里创建Task.java：12345678910111213141516171819202122package com.example.demo.task;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class Task &#123; private int count=0; @Scheduled(cron="*/6 * * * * ?") private void process()&#123; System.out.println("[" + Thread.currentThread().getName() + "]" + "this is scheduler task runing "+(count++)); &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125;&#125; 使用@Scheduled注解，就会定时执行。 log日志：12345678910111213141516171819202122[scheduling-1]this is scheduler task runing 0[scheduling-1]this is scheduler task runing 1[scheduling-1]this is scheduler task runing 2[scheduling-1]this is scheduler task runing 3[scheduling-1]this is scheduler task runing 4[scheduling-1]this is scheduler task runing 5[scheduling-1]this is scheduler task runing 6[scheduling-1]this is scheduler task runing 7[scheduling-1]this is scheduler task runing 8[scheduling-1]this is scheduler task runing 9[scheduling-1]this is scheduler task runing 10[scheduling-1]this is scheduler task runing 11[scheduling-1]this is scheduler task runing 12[scheduling-1]this is scheduler task runing 13[scheduling-1]this is scheduler task runing 14[scheduling-1]this is scheduler task runing 15[scheduling-1]this is scheduler task runing 16[scheduling-1]this is scheduler task runing 17[scheduling-1]this is scheduler task runing 18[scheduling-1]this is scheduler task runing 19[scheduling-1]this is scheduler task runing 20[scheduling-1]this is scheduler task runing 21 不需要加入其它配置文件和注解。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>定时</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring task定时任务（一）]]></title>
    <url>%2F2018%2F11%2F30%2Fspring-task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/spring.springtask.git SprngTask没有专门的包，其核心类位于spring-context包中。所以引入spring的核心包此功能即可使用。 在实际的项目中，我们经常将job作为action层，在job中注入service去操作底层的dao，或者定时的向其他系统拉取数据,再或者向其他系统推送数据。 xml配置文件applicationContext.xml： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd"&gt; &lt;context:component-scan base-package="org.task.app"/&gt; &lt;!-- 定时器开关--&gt; &lt;task:annotation-driven /&gt;&lt;/beans&gt; SpringTimer.java1234567891011121314151617package org.task.app;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;/** * @author 34924 */@Componentpublic class SpringTimer &#123; @Scheduled(cron="0/5 * * * * ? ") //每5秒执行一次 public void myTest()&#123; System.out.println("进入测试 " + new Date()); &#125;&#125; 测试类TaskTest.java：1234567891011121314151617181920212223242526package org.task.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.task.app.SpringTimer;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = "classpath:applicationContext.xml")public class TaskTest &#123; @Autowired SpringTimer springTimerTest; @Test public void springTask() &#123; try&#123; Thread.sleep(1000000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; log:123456进入测试 Fri Nov 30 21:39:20 CST 2018进入测试 Fri Nov 30 21:39:25 CST 2018进入测试 Fri Nov 30 21:39:30 CST 2018进入测试 Fri Nov 30 21:39:35 CST 2018进入测试 Fri Nov 30 21:39:40 CST 2018进入测试 Fri Nov 30 21:39:45 CST 2018]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium一些记录]]></title>
    <url>%2F2018%2F11%2F29%2Fselenium%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95-1%2F</url>
    <content type="text"><![CDATA[selenium中文文档：https://selenium-python-zh.readthedocs.io/en/latest/index.html 使用selenium，安装好对应版本的chromedriver和chrome，然后将driver放入项目，用 driver = webdriver.Chrome()启动。 selenium刷新：123driver.refresh()# 或调用jsdriver.execute_script("location.reload()") 请求头配置参考：https://blog.csdn.net/u013440574/article/details/81911954 仅添加普通请求头：123456opt = webdriver.ChromeOptions() opt.set_headless() opt.add_argument( 'user-agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400') driver = webdriver.Chrome(options=opt) 这里使用opt作为chromedriver的参数，添加user-agent信息，然后调用webdriver.Chrome，并传入opt。 注：这里使用的是无窗口界面的chrome selenium爬虫，所以可以设置，如果使用有界面的，则不必设置，因为带界面必定带请求头和各种信息。 Selenium不再推荐使用PhantomJS，会报如下警告 UserWarning: Selenium support for PhantomJS has been deprecated, please use headless versions of Chrome or Firefox instead warnings.warn(‘Selenium support for PhantomJS has been deprecated, please use headless ‘ 于是从PhantomJS转移到Chrome，使用headless versions of Chrome时，首先要安装Chrome，然后下载chromedriver，再把chromedriver的地址配置到系统环境变量path中，方便调用。如果不把chromedriver的地址配置到系统环境变量的话，也可以在使用时指定chromedriver的地址。 注意Chrome和chromedriver有版本对应的要求，系统中安装了某一版本的chrome要使用对应版本的chromedriver，其实下载最新版本的Chrome和chromedriver就行了，一般都是对应的。 Chrome下载地址：https://chrome.en.softonic.com/ chromedriver下载地址：http://npm.taobao.org/mirrors/chromedriver/ 报错：[0917/002914.533:ERROR:gpu_process_transport_factory.cc(1007)] Lost UI shared context. 原因是在windows系统中Chrome无头模式下，其中的SwiftShader软件会触发断言失败，但实际上不影响程序执行，可以忽略该错误。 可以设置chromedriver的日志级别，只有大于设置级别的日志还会输出，该配置参数为：log-level：123456opt.add_argument('log-level=3')# INFO = 0, # WARNING = 1, # LOG_ERROR = 2, # LOG_FATAL = 3# default is 0]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用JdbcTemplate（二）]]></title>
    <url>%2F2018%2F11%2F29%2Fspringboot%E4%BD%BF%E7%94%A8JdbcTemplate%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考博客 http://tengj.top/2017/04/13/springboot8/项目地址：https://github.com/snjl/jdbcTemplete.dudu.example 添加依赖123456789在pom.xml里添加spring-boot-starter-jdbc依赖跟mysql依赖：&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 数据源配置在src/main/resources/application.properties中配置数据源信息：1234spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = rootspring.datasource.driver-class-name = com.mysql.jdbc.Driver 自定义数据源添加mysql依赖（spring-boot-starter-jdbc 默认使用tomcat-jdbc数据源，如果要使用其他数据源，需要添加额外的依赖，这里使用了阿里巴巴的数据池管理）：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt;&lt;/dependency&gt; 修改Application.java：12345678910111213141516171819202122232425262728293031323334353637383940package com.dudu;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.core.env.Environment;import javax.sql.DataSource;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Autowired private Environment env; //destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty("spring.datasource.url")); dataSource.setUsername(env.getProperty("spring.datasource.username"));//用户名 dataSource.setPassword(env.getProperty("spring.datasource.password"));//密码 dataSource.setDriverClassName(env.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2);//初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 dataSource.setMaxActive(20);//最大连接池数量 dataSource.setMinIdle(0);//最小连接池数量 dataSource.setMaxWait(60000);//获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 dataSource.setValidationQuery("SELECT 1");//用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 dataSource.setTestOnBorrow(false);//申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 dataSource.setTestWhileIdle(true);//建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 dataSource.setPoolPreparedStatements(false);//是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 return dataSource; &#125;&#125; Spring Boot会智能地选择我们自己配置的这个DataSource实例。 脚本初始化12345678910111213141516171819202122232425CREATE DATABASE /*!32312 IF NOT EXISTS*/`spring` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `spring`;DROP TABLE IF EXISTS `learn_resource`;CREATE TABLE `learn_resource` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID', `author` varchar(20) DEFAULT NULL COMMENT '作者', `title` varchar(100) DEFAULT NULL COMMENT '描述', `url` varchar(100) DEFAULT NULL COMMENT '地址链接', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1029 DEFAULT CHARSET=utf8;insert into `learn_resource`(`id`,`author`,`title`,`url`) values (999,'官方SpriongBoot例子','官方SpriongBoot例子','https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1000,'龙果学院','Spring Boot 教程系列学习','http://www.roncoo.com/article/detail/124661');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1001,'嘟嘟MD独立博客','Spring Boot干货系列','http://tengj.top/');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1002,'后端编程嘟','Spring Boot视频教程','http://www.toutiao.com/m1559096720023553/');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1003,'程序猿DD','Spring Boot系列','http://www.roncoo.com/article/detail/125488');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1004,'纯洁的微笑','Sping Boot系列文章','http://www.ityouknow.com/spring-boot');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1005,'CSDN——小当博客专栏','Sping Boot学习','http://blog.csdn.net/column/details/spring-boot.html');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1006,'梁桂钊的博客','Spring Boot 揭秘与实战','http://blog.csdn.net/column/details/spring-boot.html');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1007,'林祥纤博客系列','从零开始学Spring Boot','http://412887952-qq-com.iteye.com/category/356333');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1028,'杜琪','关于Spring Boot的博客集合','http://www.jianshu.com/p/7e2e5e7b32ab'); 使用JdbcTemplateSpring的JdbcTemplate是自动配置的，可以直接使用@Autowired来注入到自己的bean中来使用。这里做了一套增伤改查。pojo类：1234567public class LearnResouce &#123; private Long id; private String author; private String title; private String url; // SET和GET方法&#125; dao层的接口实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.dudu.dao.impl;import com.dudu.dao.LearnDao;import com.dudu.domain.LearnResouce;import com.dudu.tools.Page;import com.dudu.tools.StringUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/8. */@Repositorypublic class LearnDaoImpl implements LearnDao&#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(LearnResouce learnResouce) &#123; return jdbcTemplate.update("insert into learn_resource(author, title,url) values(?, ?, ?)",learnResouce.getAuthor(),learnResouce.getTitle(),learnResouce.getUrl()); &#125; @Override public int update(LearnResouce learnResouce) &#123; return jdbcTemplate.update("update learn_resource set author=?,title=?,url=? where id = ?",new Object[]&#123;learnResouce.getAuthor(),learnResouce.getTitle(),learnResouce.getUrl(),learnResouce.getId()&#125;); &#125; @Override public int deleteByIds(String ids)&#123; return jdbcTemplate.update("delete from learn_resource where id in("+ids+")"); &#125; @Override public LearnResouce queryLearnResouceById(Long id) &#123; List&lt;LearnResouce&gt; list = jdbcTemplate.query("select * from learn_resource where id = ?", new Object[]&#123;id&#125;, new BeanPropertyRowMapper(LearnResouce.class)); if(null != list &amp;&amp; list.size()&gt;0)&#123; LearnResouce learnResouce = list.get(0); return learnResouce; &#125;else&#123; return null; &#125; &#125; @Override public Page queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; StringBuffer sql =new StringBuffer(); sql.append("select * from learn_resource where 1=1"); if(!StringUtil.isNull((String)params.get("author")))&#123; sql.append(" and author like '%").append((String)params.get("author")).append("%'"); &#125; if(!StringUtil.isNull((String)params.get("title")))&#123; sql.append(" and title like '%").append((String)params.get("title")).append("%'"); &#125; Page page = new Page(sql.toString(), Integer.parseInt(params.get("page").toString()), Integer.parseInt(params.get("rows").toString()), jdbcTemplate); return page; &#125;&#125; 其中值得注意的几个点： jdbcTemplete直接使用@Autowired注解注入的； deleteByIds这个方法是传入的数据是形如”(1,2,3,5)”这样的数据，是在controller里或者前端组装好的； queryLearnResouceList这个方法返回的是一个Page对象,它需要的参数里有一个page，指的是当前页码，下面是Page.java的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.dudu.tools;import org.springframework.jdbc.core.JdbcTemplate;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/11. */public class Page &#123; //一页显示的记录数 private int numPerPage; //记录总数 private int totalRows; //总页数 private int totalPages; //当前页码 private int currentPage; //起始行数 private int startIndex; //结束行数 private int lastIndex; //结果集存放List private List&lt;Map&lt;String, Object&gt;&gt; resultList; /**分页构造函数 * @param sql 包含筛选条件的sql，但不包含分页相关约束，如mysql的limit * @param currentPage 当前页 * @param numPerPage 每页记录数 * @param jdbcTemplate jdbcTemplate实例 */ public Page(String sql,int currentPage,int numPerPage,JdbcTemplate jdbcTemplate)&#123; if(jdbcTemplate == null)&#123; throw new IllegalArgumentException("Page.jdbcTemplate is null"); &#125;else if(sql == null || sql.equals(""))&#123; throw new IllegalArgumentException("Page.sql is empty"); &#125; //设置每页显示记录数 setNumPerPage(numPerPage); //设置要显示的页数 setCurrentPage(currentPage); //计算总记录数 StringBuffer totalSQL = new StringBuffer(" SELECT count(*) FROM ( "); totalSQL.append(sql); totalSQL.append(" ) totalTable "); //总记录数 setTotalRows(jdbcTemplate.queryForObject(totalSQL.toString(),Integer.class)); //计算总页数 setTotalPages(); //计算起始行数 setStartIndex(); //计算结束行数 setLastIndex(); System.out.println("lastIndex="+lastIndex); //使用mysql时直接使用limits StringBuffer paginationSQL = new StringBuffer(); paginationSQL.append(sql); paginationSQL.append(" limit " + startIndex + "," + lastIndex); //装入结果集 setResultList(jdbcTemplate.queryForList(paginationSQL.toString())); &#125; //计算总页数 public void setTotalPages() &#123; if(totalRows % numPerPage == 0)&#123; this.totalPages = totalRows / numPerPage; &#125;else&#123; this.totalPages = (totalRows / numPerPage) + 1; &#125; &#125; //计算结束时候的索引 public void setLastIndex() &#123; System.out.println("totalRows="+totalRows);/////////// System.out.println("numPerPage="+numPerPage);/////////// if( totalRows &lt; numPerPage)&#123; this.lastIndex = totalRows; &#125;else if((totalRows % numPerPage == 0) || (totalRows % numPerPage != 0 &amp;&amp; currentPage &lt; totalPages))&#123; this.lastIndex = currentPage * numPerPage; &#125;else if(totalRows % numPerPage != 0 &amp;&amp; currentPage == totalPages)&#123;//最后一页 this.lastIndex = totalRows ; &#125; &#125; Page的构造函数，将sql和其他条件拼接起来，从而得到每一页的信息。最后返回一个List&lt;Map&lt;String, Object&gt;&gt;对象和一些例如页码数、总数据条数等数据，作为一个Page数据。 Service层没有特点。 Controller层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package com.dudu.controller;import com.alibaba.fastjson.JSONObject;import com.dudu.domain.LearnResouce;import com.dudu.service.LearnService;import com.dudu.tools.Page;import com.dudu.tools.ServletUtil;import com.dudu.tools.StringUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/3/13. */@Controller@RequestMapping("/learn")public class LearnController &#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn()&#123; return "learn-resource"; &#125; @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST,produces="application/json;charset=UTF-8") @ResponseBody public void queryLearnList(HttpServletRequest request ,HttpServletResponse response)&#123; String page = request.getParameter("page"); // 取得当前页数,注意这是jqgrid自身的参数 String rows = request.getParameter("rows"); // 取得每页显示行数，,注意这是jqgrid自身的参数 String author = request.getParameter("author"); String title = request.getParameter("title"); Map&lt;String,Object&gt; params = new HashMap&lt;String,Object&gt;(); params.put("page", page); params.put("rows", rows); params.put("author", author); params.put("title", title); Page pageObj =learnService.queryLearnResouceList(params); List&lt;Map&lt;String, Object&gt;&gt; learnList=pageObj.getResultList(); JSONObject jo=new JSONObject(); jo.put("rows", learnList); jo.put("total", pageObj.getTotalPages()); jo.put("records", pageObj.getTotalRows()); ServletUtil.createSuccessResponse(200, jo, response); &#125; /** * 新添教程 * @param request * @param response */ @RequestMapping(value = "/add",method = RequestMethod.POST) public void addLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; LearnResouce learnResouce = new LearnResouce(); learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.add(learnResouce); System.out.println("结果="+index); if(index&gt;0)&#123; result.put("message","教程信息添加成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息添加失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 修改教程 * @param request * @param response */ @RequestMapping(value = "/update",method = RequestMethod.POST) public void updateLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String id = request.getParameter("id"); LearnResouce learnResouce=learnService.queryLearnResouceById(Long.valueOf(id)); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.update(learnResouce); System.out.println("修改结果="+index); if(index&gt;0)&#123; result.put("message","教程信息修改成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息修改失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 删除教程 * @param request * @param response */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public void deleteUser(HttpServletRequest request ,HttpServletResponse response)&#123; String ids = request.getParameter("ids"); System.out.println("ids==="+ids); JSONObject result = new JSONObject(); //删除操作 int index = learnService.deleteByIds(ids); if(index&gt;0)&#123; result.put("message","教程信息删除成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息删除失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125;&#125; 这里使用了ServletUtil，在此仅举出一例：1234567891011121314151617181920212223242526 public static String createSuccessResponse(Integer httpCode, Object result, SerializerFeature serializerFeature, SerializeFilter filter, HttpServletResponse response)&#123; PrintWriter printWriter = null; String jsonString = ""; try &#123; response.setCharacterEncoding(RESPONSE_CHARACTERENCODING); response.setContentType(RESPONSE_CONTENTTYPE); response.setStatus(httpCode); printWriter = response.getWriter(); if(null != result)&#123; if(null!=filter)&#123; jsonString = JSONObject.toJSONString(result,filter,serializerFeature); &#125;else&#123;// jsonString = JSONObject.toJSONString(result, serializerFeature); jsonString = JSONObject.toJSONStringWithDateFormat(result,"yyyy-MM-dd HH:ss:mm",serializerFeature); &#125; printWriter.write(jsonString); &#125; printWriter.flush(); &#125; catch (Exception e) &#123; log.error("createResponse failed", e); &#125; finally &#123; if(null!=printWriter)printWriter.close(); &#125; return jsonString; &#125; 页面展示]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>JdbcTemplate</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用thymeleaf开发web应用]]></title>
    <url>%2F2018%2F11%2F29%2Fspringboot%E4%BD%BF%E7%94%A8thymeleaf%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.thymeleaf_demo.git Spring Web MVCSpring Web MVC框架（通常简称为”Spring MVC”）是一个富”模型，视图，控制器”的web框架。 Spring MVC允许你创建特定的@Controller或@RestController beans来处理传入的HTTP请求。 示例：12345678910111213141516@RestController@RequestMapping(value="/users")public class MyRestController &#123; @RequestMapping(value="/&#123;user&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long user) &#123; // ... &#125; @RequestMapping(value="/&#123;user&#125;/customers", method=RequestMethod.GET) List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) &#123; // ... &#125; @RequestMapping(value="/&#123;user&#125;", method=RequestMethod.DELETE) public User deleteUser(@PathVariable Long user) &#123; // ... &#125;&#125; Spring MVC自动配置Spring Boot为Spring MVC提供适用于多数应用的自动配置功能。在Spring默认基础上，自动配置添加了以下特性： 引入ContentNegotiatingViewResolver和BeanNameViewResolver beans。 对静态资源的支持，包括对WebJars的支持。 自动注册Converter，GenericConverter，Formatter beans。 对HttpMessageConverters的支持。 自动注册MessageCodeResolver。 对静态index.html的支持。 对自定义Favicon的支持。 如果想全面控制Spring MVC，你可以添加自己的@Configuration，并使用@EnableWebMvc对其注解。如果想保留Spring Boot MVC的特性，并只是添加其他的MVC配置(拦截器，formatters，视图控制器等)，你可以添加自己的WebMvcConfigurerAdapter类型的@Bean（不使用@EnableWebMvc注解）. 静态文件默认情况下，Spring Boot从classpath下一个叫/static（/public，/resources或/META-INF/resources）的文件夹或从ServletContext根目录提供静态内容。这使用了Spring MVC的ResourceHttpRequestHandler，所以你可以通过添加自己的WebMvcConfigurerAdapter并覆写addResourceHandlers方法来改变这个行为（加载静态文件）。 在一个单独的web应用中，容器默认的servlet是开启的，如果Spring决定不处理某些请求，默认的servlet作为一个回退（降级）将从ServletContext根目录加载内容。大多数时候，这不会发生（除非你修改默认的MVC配置），因为Spring总能够通过DispatcherServlet处理请求。 此外，上述标准的静态资源位置有个例外情况是Webjars内容。任何在/webjars/**路径下的资源都将从jar文件中提供，只要它们以Webjars的格式打包。 注：如果你的应用将被打包成jar，那就不要使用src/main/webapp文件夹。尽管该文件夹是一个共同的标准，但它仅在打包成war的情况下起作用，并且如果产生一个jar，多数构建工具都会静悄悄的忽略它。 模版引擎Spring Boot支持多种模版引擎包括： FreeMarker Groovy Thymeleaf(官方推荐) Mustache JSP技术Spring Boot官方是不推荐的，原因有三： tomcat只支持war的打包方式，不支持可执行的jar。 Jetty 嵌套的容器不支持jsp Undertow 创建自定义error.jsp页面不会覆盖错误处理的默认视图，而应该使用自定义错误页面 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 Thymeleaf模版引擎Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。它的功能特性如下： Spring MVC中@Controller中的方法可以直接返回模板名称，接下来Thymeleaf模板引擎会自动进行渲染 模板中的表达式支持Spring表达式语言（Spring EL) 表单支持，并兼容Spring MVC的数据绑定与验证机制 国际化支持 Spring官方也推荐使用Thymeleaf,所以本篇代码整合就使用Thymeleaf来整合。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; domain类1234567891011121314151617@Componentpublic class LearnResource &#123; private String author; private String title; private String url; public LearnResource() &#123; &#125; public LearnResource(String author, String title, String url) &#123; this.author = author; this.title = title; this.url = url; &#125; ...&#125; controller两种写法均可：123456789101112131415161718192021222324252627282930@Controller@RequestMapping("/learn")public class LearnResourceController &#123; @RequestMapping("/") public ModelAndView index()&#123; List&lt;LearnResource&gt; learnList =new ArrayList&lt;LearnResource&gt;(); LearnResource bean =new LearnResource("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResource("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResource("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResource("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResource("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResource("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView("/learning"); modelAndView.addObject("learnList", learnList); return modelAndView; &#125; 1234567891011121314151617181920212223242526@RequestMapping("/learning") public String index(ModelMap map)&#123; List&lt;LearnResource&gt; learnList =new ArrayList&lt;LearnResource&gt;(); LearnResource bean =new LearnResource("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResource("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResource("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResource("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResource("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResource("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); map.addAttribute("learnList", learnList); return "learning"; &#125; 一个访问链接是localhost:8080/learn/(带斜杆)，另一个是http://localhost:8080/learn/learning，但是对应的模版文件均是learning.html。 html编写引入依赖后就在默认的模板路径src/main/resources/templates下编写模板文件即可完成。这里我们新建一个index.html:1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;learn Resources&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center;margin:0 auto;width: 1000px; "&gt; &lt;h1&gt;springboot学习&lt;/h1&gt; &lt;table width="100%" border="1" cellspacing="1" cellpadding="0"&gt; &lt;tr&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;教程名称&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;!--/*@thymesVar id="learnList" type=""*/--&gt; &lt;tr th:each="learn : $&#123;learnList&#125;"&gt; &lt;td th:text="$&#123;learn.author&#125;"&gt;嘟嘟MD&lt;/td&gt; &lt;td th:text="$&#123;learn.title&#125;"&gt;SPringBoot干货系列&lt;/td&gt; &lt;td&gt;&lt;a th:href="$&#123;learn.url&#125;" target="_blank"&gt;点我&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：通过xmlns:th=”http://www.thymeleaf.org“ 命令空间，将静态页面转换为动态的视图，需要进行动态处理的元素将使用“th:”前缀。 直接打开learning.html和启动工程后访问http://localhost:8080/learn/ 看到的效果，Thymeleaf做到了不破坏HTML自身内容的数据逻辑分离。 Thymeleaf的默认参数配置在application.properties中可以配置thymeleaf模板解析器属性12345678910111213141516171819202122232425# THYMELEAF (ThymeleafAutoConfiguration)#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.servlet.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests包的异常处理]]></title>
    <url>%2F2018%2F11%2F26%2Frequests%E5%8C%85%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[可以使用raise_for_status()来获取所有错误，并且在except语句中使用 requests.RequestException来得到错误原因： def get_bs_obj(link): try: response = requests.get(link, headers=headers, timeout=10) response.raise_for_status() bs_obj = bs(response.text) return bs_obj except requests.RequestException as e: print(e) return None 例如会产生报错： HTTPConnectionPool(host=&apos;synthezise.christuniversity.in&apos;, port=80): Max retries exceeded with url: / (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x0000021B9CB8A0F0&gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed&apos;,)) HTTPConnectionPool(host=&apos;icu2018cls.umk.edu.my&apos;, port=80): Max retries exceeded with url: / (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x0000021B9CB8ACF8&gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed&apos;,)) HTTPSConnectionPool(host=&apos;icsah.eu&apos;, port=443): Max retries exceeded with url: /events (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(-1, &apos;Unexpected EOF&apos;)&quot;,),)) HTTPSConnectionPool(host=&apos;icsah.eu&apos;, port=443): Max retries exceeded with url: /events (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(-1, &apos;Unexpected EOF&apos;)&quot;,),))]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy常用函数]]></title>
    <url>%2F2018%2F11%2F26%2Fnumpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)12345678910111213141516171819202122start标量 序列的起始值。stop标量 除非`endpoint`设置为False，否则序列的结束值。 在这种情况下，序列由除``num + 1``的最后一个组成 均匀间隔的样本，以便排除`stop`。注意这一步 当`endpoint`为False时，大小会改变。num：int，可选 要生成的样本数。默认值为50.必须为非负数。endpoint：bool，可选 如果为True，则`stop`是最后一个样本。否则，它不包括在内。 默认为True。 retstep：bool，可选 如果为True，则返回（`samples`，`step`），其中`step`是间距 样本之间。 dtype：dtype，可选 输出数组的类型。如果没有给出`dtype`，推断数据 从其他输入参数中键入。 1234567891011121314x = np.linspace(-1, 1, 5)out:array([-1. , -0.5, 0. , 0.5, 1. ])x = np.linspace(-1, 1, 5,endpoint=False)out:array([-1. , -0.6, -0.2, 0.2, 0.6])x = np.linspace(-1,1,5,endpoint=False,retstep=True)out:(array([-1. , -0.6, -0.2, 0.2, 0.6]), 0.4) np.random.normal(loc=0.0, scale=1.0, size=None)1234567loc：float或array_like浮点数 分布的平均值（“中心”）。scale：float或array_like浮点数 分布的标准偏差（展宽或“宽度”）。size：int或int的元组，可选 输出形状。如果给定的形状是例如“（m，n，k）”，那么 绘制了`m * n * k`样本 输出一个均值为0，标准差为0.05的(4,3)矩阵12345678n = np.random.normal(0,0.05,[4,3])out:array([[ 0.00875909, 0.04187258, 0.03422398], [ 0.04415144, 0.00083901, 0.06574384], [ 0.13169391, 0.09001974, -0.0384982 ], [ 0.00414203, 0.03999768, -0.09010478]]) np.newaxis作用为增加维度。 1x_data=np.linspace(-1,1,300)[:,np.newaxis] 意思为，从-1到1均匀取出300个间隔数字（包括-1,1），得到shape为(300,)的array，增加一个维度，变为(300,1)。 实际上可以使用reshape做到。等价于1x_data=np.linspace(-1,1,300).reshape(300,-1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib画图]]></title>
    <url>%2F2018%2F11%2F26%2Fmatplotlib%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[123456789import matplotlib.pyplot as pltimport numpy as npdata = np.arange(100, 201)plt.plot(data)plt.show() 1.通过np.arange(100, 201)生成一个[100, 200]之间的整数数组，它的值是：[100, 101, 102, … , 200] 2.通过matplotlib.pyplot将其绘制出来。很显然，绘制出来的值对应了图中的纵坐标（y轴）。而matplotlib本身为我们设置了图形的横坐标（x轴）：[0, 100]，因为我们刚好有100个数值 3.通过plt.show()将这个图形显示出来 修改代码：123456789import matplotlib.pyplot as pltimport numpy as npdata = np.arange(1, 200, 20)plt.plot(data, &apos;ro&apos;)plt.show() 加入点也可以用1plt.plot([1,2],[3,4]) 加入的2个点为(1,3),(2,4)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：mysql报错记录]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9Amysql%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.Operand should contain 1 column字面意思是，需要有1个数据列。如下sql：1cursor.execute("INSERT INTO lunwen(url) VALUES (%s)", (url,)) 可能是因为url并不是一个字符串，而是一个tuple或者list。 2.latin-1’ codec can’t encode character u’\u201c’ in position 0pymysql 正常情况下会尝试将所有的内容转为latin1字符集处理，所以在连接数据库的时候应该加上utf8编码：1db = pymysql.connect("localhost","root","00000000","TESTDB" ,use_unicode=True, charset="utf8")]]></content>
      <categories>
        <category>python</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium一些记录]]></title>
    <url>%2F2018%2F11%2F26%2Fselenium%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[selenium中文文档：https://selenium-python-zh.readthedocs.io/en/latest/index.html 使用selenium，安装好对应版本的chromedriver和chrome，然后将driver放入项目，用 driver = webdriver.Chrome()启动。 selenium刷新：123driver.refresh()# 或调用jsdriver.execute_script("location.reload()") 请求头配置参考：https://blog.csdn.net/u013440574/article/details/81911954 仅添加普通请求头：123456opt = webdriver.ChromeOptions() opt.set_headless() opt.add_argument( 'user-agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400') driver = webdriver.Chrome(options=opt) 这里使用opt作为chromedriver的参数，添加user-agent信息，然后调用webdriver.Chrome，并传入opt。 注：这里使用的是无窗口界面的chrome selenium爬虫，所以可以设置，如果使用有界面的，则不必设置，因为带界面必定带请求头和各种信息。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：常用操作]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.生成随机数12import randomprint(3 * random.random()) 生成0-3的随机数。1print(random.randint(0,99)) 生成0-99的随机整数。 还有很多，用的不多，临时百度。 2.MD5加密123456789101112131415161718# 由于MD5模块在python3中被移除# 在python3中使用hashlib模块进行md5操作import hashlib# 待加密信息str = 'this is a md5 test.'# 创建md5对象hl = hashlib.md5()# Tips# 此处必须声明encode# 若写法为hl.update(str) 报错为： Unicode-objects must be encoded before hashinghl.update(str.encode(encoding='utf-8'))print('MD5加密前为 ：' + str)print('MD5加密后为 ：' + hl.hexdigest()) 可以将hl定义在类中，每次类调用该hl，可以不用每次都生成。 3.数据库timestamp时间插入123import timeprint(time.localtime()) 输出：1time.struct_time(tm_year=2018, tm_mon=11, tm_mday=26, tm_hour=16, tm_min=35, tm_sec=51, tm_wday=0, tm_yday=330, tm_isdst=0) 4.list元素拼接为字符串12345b = ['p', 'a', 'n', ';']k = ''.join(b)&gt;&gt;&gt; k = ''.join(b)&gt;&gt;&gt; k'pan;' 5.tuple注意点tuple是不可变的，提供了一种完整的约束性，但是它支持的操作比较少（如果元组中含有一个list或者dict，list和dict还是能改变的）。 6.文件二进制读写文件写入二进制，使用12data = open("a.txt",'rb')data.write(all) 7.单个表达式代替循环1234L = [x + 10 for x in L]# 效率高于 for i in L: res.append(i+10) 8.读取文件最好的方式是不要打开123for line in open('test.txt'): print(line, end='')# end=''是为了除去每一行的\n，可以不用replace 9.去除line里的换行符123f = open('test.text')lines = f.readlines()lines = [line.rstrip() for line in lines] 10.对文件进行简单操作的可行处理方法1lines = [line.upper() for lin in open('test.txt')] 11.对lines进行较为复杂的操作12lines = [line.rstrip() for line in open('test.txt') if line[0] == 'p']# 结果是只留下第一个字符是p的元素 12.两个list进行拼接123&gt;&gt;&gt; z = [x + y for x in 'abc' for y in 'lmn']&gt;&gt;&gt; z['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn'] 13.判断dict是否有该键12345value = d.get('x',0)# 表示如果字典d里有键为x的，返回x的值，如果没有，返回0；# 也可以写为：value = d['x'] if 'x' in d else 0# emmm其实我觉得这个也挺好理解的，但是有点长。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：list差集]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9Alist%E5%B7%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[list并集：1print list(set(a).union(set(b))) 或者：12345678k = [x for x in s1 if x in s2]&gt;&gt;&gt; x1 = [1,2,3,4,5,6,7]&gt;&gt;&gt; s1 = x1&gt;&gt;&gt; s2 = (3,4,6,8)&gt;&gt;&gt; k = [x for x in s1 if x in s2]&gt;&gt;&gt; k[3, 4, 6] list差集：12print list(set(b).difference(set(a)))# b中有而a中没有的]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：页面中存在多个input设置value属性]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AAinput%E8%AE%BE%E7%BD%AEvalue%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[首先要为这些所有的input框绑定上onChange的方法，然后还需要在this.state中去设置不同的input对应不同的值，最后还需要在changeValue的方法中去一一监听input输入时去修改对应的input的值。 也可以写一个changeValue方法，但是input的属性的name要和state里的名字要一样，如下所示：12345678910constructor() &#123; super(); this.state = &#123; login:&#123; username:'', password:'' &#125;, user:&#123;&#125; &#125;&#125; 1234567用户名：&lt;input type=&#123;'text'&#125; name=&#123;'username'&#125; value=&#123;this.state.login.username&#125; className=&#123;'username'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt;&lt;br/&gt;密码：&lt;input type=&#123;'password'&#125; name=&#123;'password'&#125; value=&#123;this.state.login.password&#125; className=&#123;'password'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; 12345changeValue(event) &#123; let newLogin = this.state.login; newLogin[event.target.name] = event.target.value; this.setState(&#123;login: newLogin&#125;) &#125; 使用event.target.name获取input的name属性，使用evnet.target.value获取input的value，令newLogin为this.state.login，然后将newLogin中名为event.target.name的属性的值设为event.target.value，之后再setState，从而可以改变state.login的值。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session-1%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery禁止回车提交]]></title>
    <url>%2F2018%2F11%2F25%2FjQuery%E7%A6%81%E6%AD%A2%E5%9B%9E%E8%BD%A6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[在有input框进行输入提交时，如果有input的type为submit，则默认按回车会提交，可以用jQuery的方法进行阻拦：1234567891011$(function()&#123; $("input").each( function()&#123; $(this).keypress( function(e) &#123; var key = window.event ? e.keyCode : e.which; if(key.toString() === "13")&#123; return false; &#125; &#125;); &#125;);&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：form表单提交]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9Aform%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[由于React在浏览器显示的是虚拟的DOM，我们在表单输入值后直接提交，是无法获取到这个值的。对此，官方给出的解决办法是：先把输入的值存放在组件的状态（state）中，之后通过状态的改变更新页面内容，从而显示出正确的值，用户提交的也是从state里获取的表单的value。 1234567891011constructor() &#123; super(); this.state = &#123; item:&#123; name:'', organization:'', school:'', &#125;, &#125;&#125; 设置提交方法和改变state的状态的方法：1234567891011121314151617181920212223handleSubmit(event) &#123; //阻止表单默认提交 event.preventDefault(); let item = this.state.item; axios.post(host + 'xxx/insert', item).then( response =&gt; &#123; let message = response.data; if (message === 'success') &#123; alert("插入成功"); window.location.href = '/xxx/list'; &#125; else &#123; alert("插入失败，请重试"); &#125; &#125; ); this.setState(&#123;item:item&#125;)&#125;changeValue(event) &#123; let newItem = this.state.item; newItem[event.target.name] = event.target.value; this.setState(&#123;item: newItem&#125;)&#125; 123456789101112131415161718192021&lt;form method=&#123;'post'&#125; onSubmit=&#123;this.handleSubmit.bind(this)&#125;&gt; &lt;label&gt;申请数据集名称： &lt;input type="text" name=&#123;'name'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学校： &lt;input type="text" name=&#123;'organization'&#125; value=&#123;this.state.item.organization&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学院： &lt;input type="text" name=&#123;'school'&#125; value=&#123;this.state.item.school&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;input type=&#123;'submit'&#125; value=&#123;'提交'&#125;/&gt; &lt;input value=&#123;'重置'&#125; type=&#123;'reset'&#125;/&gt;&lt;/form&gt; 注：form中用onSubmit替代action，其中每个input的name需要对应定义state时的状态，在使用axios调接口传值时，如果是java的springmvc的后端，需要将传输的属性与对应的实体类对接好。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot报错记录]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured. Reason: Failed to determine a suitable driver class Action: Consider the following:​ If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.​ If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active). 原因：引入mybatis的jar包时： ​ org.mybatis.spring.boot​ mybatis-spring-boot-starter​ 1.3.1springboot会默认加载org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration这个类，而DataSourceAutoConfiguration类使用了@Configuration注解向spring注入了dataSource bean，又因为项目中并没有关于dataSource相关的配置信息，所以当spring创建dataSource bean时因缺少相关的信息就会报错。 解决办法： 在@SpringBootApplication注解上加上exclude，解除自动加载DataSourceAutoConfiguration。@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }在parent项目的pom.xml文件中保存所有子模块的共有jar依赖，非共有的依赖则在各模块自身的pom.xml文件中进行申明。建议采用此方法，好处在于各模块的依赖不会相互产生干扰。2.maven配置时，测试出现“’mvn’ 不是内部或外部命令,也不是可运行的程序”错误 配置maven。 在环境变量的PATH中配置maven的bin目录。 使用mvn package打包成功后显示日志： [INFO] BUILD SUCCESS[INFO] ————————————————————————[INFO] Total time: 46.791 s[INFO] Finished at: 2018-11-21T16:12:36+08:00[INFO] Final Memory: 35M/275M[INFO] ————————————————————————3.java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents…….. 具体错误： Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Tue May 15 21:38:04 CST 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71)​ at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76) at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862) at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:444) at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230) at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226) at java.sql.DriverManager.getConnection(Unknown Source) at java.sql.DriverManager.getConnection(Unknown Source) at zhu.jdbc.unit.UnitMysql.getConnection(UnitMysql.java:34) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:55) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1) at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87) at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)​ at java.lang.reflect.Constructor.newInstance(Unknown Source)​ at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:59)​ at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:83)​ at com.mysql.cj.util.TimeUtil.getCanonicalTimezone(TimeUtil.java:128)​ at com.mysql.cj.protocol.a.NativeProtocol.configureTimezone(NativeProtocol.java:2201)​ at com.mysql.cj.protocol.a.NativeProtocol.initServerSession(NativeProtocol.java:2225)​ at com.mysql.cj.jdbc.ConnectionImpl.initializePropsFromServer(ConnectionImpl.java:1391)​ at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:993)​ at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:852)​ … 36 more五月 15, 2018 9:38:04 下午 org.apache.catalina.core.StandardWrapperValve invoke严重: Servlet.service() for servlet [Servlet_TbUser] in context with path [/myweb2] threw exceptionjava.lang.NullPointerException​ at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:59)​ at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1)​ at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35)​ at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1)​ at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87)​ at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41)​ at javax.servlet.http.HttpServlet.service(HttpServlet.java:661)​ at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)​ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)​ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)​ at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)​ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)​ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)​ at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)​ at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)​ at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496)​ at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)​ at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)​ at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650)​ at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)​ at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)​ at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)​ at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)​ at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)​ at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)​ at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)​ at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)​ at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)​ at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) 出现这个的原因是因为 mysql返回的时间总是有问题，比实际时间要早8小时。 解决办法： 在jdbc连接的url后面加上serverTimezone=GMT即可解决问题，如果需要使用gmt+8时区，需要写成GMT%2B8。 为了防止因为日期为null报错，可以直接加上： ?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 例如链接数据库，可以写为： jdbc.url=jdbc:mysql://xxx.xxx.xxx.xxx/xxxxx?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 4.Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdbc.Driver. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 这个问题是 使用了新的mysql驱动包，但驱动声明不是最新的： DriverClassName 从 “com.mysql.jdbc.Driver” 换成 “com.mysql.cj.jdbc.Driver” 即可。 5.spring Failed to convert property value of type ‘java.lang.String’ to required type ‘int’ for property 原错误是不能将long的null属性转化出来，但是没找到原来的错误。采取的方式是，把pojo类中的long全改为Integer。 如果是date出错，参考问题3，在数据库连接时加上zeroDateTimeBehavior=convertToNull。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用JdbcTemplate（一）]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E4%BD%BF%E7%94%A8JdbcTemplate%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mysql.git 环境配置修改 POM 文件，添加spring-boot-starter-jdbc依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 添加mysql依赖（spring-boot-starter-jdbc 默认使用tomcat-jdbc数据源，如果要使用其他数据源，需要添加额外的依赖，这里使用了阿里巴巴的数据池管理）：12345678&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt; 数据源配置在src/main/resources/application.properties中配置数据源信息:1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/sss?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=123456 在Application.java中配置：123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootApplicationpublic class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125; @Autowired private Environment environment; /** * destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. * @return */ @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(environment.getProperty("spring.datasource.url")); dataSource.setUsername(environment.getProperty("spring.datasource.username")); //用户名 dataSource.setPassword(environment.getProperty("spring.datasource.password")); //密码 dataSource.setDriverClassName(environment.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2); //初始化时建立物理连接的个数 dataSource.setMaxActive(20); //最大连接池数量 dataSource.setMinIdle(0); //最小连接池数量 dataSource.setMaxWait(60000); //获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery("SELECT 1"); //用来检测连接是否有效的sql dataSource.setTestOnBorrow(false); //申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true); //建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false); //是否缓存preparedStatement，也就是PSCache return dataSource; &#125;&#125; 数据12345678910111213-- auto-generated definitionCREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id)) ENGINE = InnoDB; 代码实体类：1234567891011package com.example.myproject.domain;@Componentpublic class TbStudent &#123; private Integer id; private String name; private String sex; private Integer age; private Integer clazzId; //getter,setter 可以用idea自动生成，将long类型的全改为Integer，为了以后不报错。 DAO层123456789101112131415161718package com.example.myproject.dao;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentDao &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.myproject.dao.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class TbStudentDaoImpl implements TbStudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int insert(TbStudent tbStudent) &#123; return jdbcTemplate.update("insert into tb_student(NAME) VALUES (?)",tbStudent.getName()); &#125; @Override public int update(TbStudent tbStudent) &#123; return jdbcTemplate.update("update tb_student set NAME=? where id=?",tbStudent.getName(),tbStudent.getId()); &#125; @Override public int delete(long id) &#123; return jdbcTemplate.update("delete from tb_student where id=?", id); &#125; @Override public TbStudent findTbStudent(long id) &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student WHERE id=?", new Object[]&#123;id&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); if(list != null &amp;&amp; list.size() &gt; 0) &#123; TbStudent tbStudent = list.get(0); return tbStudent; &#125;else &#123; return null; &#125; &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student", new Object[]&#123;&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); return list; &#125;&#125; 注：使用jdbcTemplate.query时，需要注意这个写法：new Object[]{id}, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)。并且如果只需要一个，需要进行null和size判定，之后取出一个，不然会报错。 Service层1234567891011121314151617181920package com.example.myproject.service;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentService &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.myproject.service.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TbStudentServiceImpl implements TbStudentService&#123; @Resource(name = "tbStudentDaoImpl") private TbStudentDao tbStudentDao; @Override public int insert(TbStudent tbStudent) &#123; return tbStudentDao.insert(tbStudent); &#125; @Override public int update(TbStudent tbStudent) &#123; return tbStudentDao.update(tbStudent); &#125; @Override public int delete(long id) &#123; return tbStudentDao.delete(id); &#125; @Override public TbStudent findTbStudent(long id) &#123; return tbStudentDao.findTbStudent(id); &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; return tbStudentDao.findAll(); &#125;&#125; Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.myproject.web;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author 34924 */@RestController@RequestMapping("/tbStudent")public class TbStudentController &#123; @Resource(name = "tbStudentServiceImpl") private TbStudentService tbStudentService; @RequestMapping("/findAll") public List&lt;TbStudent&gt; findAll() &#123; return tbStudentService.findAll(); &#125; @RequestMapping("/delete/&#123;id&#125;") public int delete(@PathVariable long id) &#123; return tbStudentService.delete(id); &#125; @RequestMapping(value = "/insert",method = RequestMethod.POST) public int insert(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.insert(tbStudent); &#125; @RequestMapping(value = "/update",method = RequestMethod.GET) public int update(@RequestParam Integer id,@RequestParam String name) &#123; TbStudent tbStudent = tbStudentService.findTbStudent(id); tbStudent.setName(name); return tbStudentService.update(tbStudent); &#125; @RequestMapping(value = "/findOne",method = RequestMethod.POST) public TbStudent findOne(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.findTbStudent(tbStudent.getId()); &#125;&#125; 注：此处全写的是接口 findAll用的是普通的get请求; delete用的restful的形式； insert用的post请求； update用的get请求，使用@RequestParam，注意post请求使用@RequestBody，而get请求只能使用@RequestParam或者是使用@ModelAttribute（此处未使用）； findOne用的post请求。 如果将update改为使用@ModelAttribute，如下：1234@RequestMapping(value = "/update",method = RequestMethod.GET)public int update(@ModelAttribute TbStudent tbStudent) &#123; return tbStudentService.update(tbStudent);&#125; 使用JSONObject改insert为JSONObject接受参数：123456@RequestMapping(value = "/insert2",method = RequestMethod.POST)public int insert2(@RequestBody JSONObject tbStudent) &#123; TbStudent tbStudent1 = new TbStudent(); tbStudent1.setName((String)tbStudent.get("name")); return tbStudentService.insert(tbStudent1);&#125; 引入的包为：1import net.minidev.json.JSONObject; 在pom.xml中加入：12345&lt;dependency&gt; &lt;groupId&gt;net.minidev&lt;/groupId&gt; &lt;artifactId&gt;json-smart&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 测试效果findAll： delete： insert： update： 使用@ModelAttribute的注解： findOne： 使用thymeleaf添加文件：1234567891011121314151617181920212223242526272829package com.example.myproject.web;import com.example.myproject.service.TbStudentService;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * @author 34924 */@Controller@RequestMapping("/tbStudent/html")public class TbStudentControllerForHtml &#123; @Resource(name = "tbStudentServiceImpl") private TbStudentService tbStudentService; @RequestMapping("/findAll") public String findAll(ModelMap model) &#123; model.addAttribute("items", tbStudentService.findAll()); return "student"; &#125;&#125; student.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;student&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;student&lt;/h1&gt;this is student.&lt;br&gt;&lt;div th:each="item : $&#123;items&#125;"&gt; &lt;a th:text="$&#123;item.id&#125;"&gt;123&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:text="$&#123;item.name&#125;"&gt;name&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:text="$&#123;item.clazzId&#125;"&gt;name&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:if="$&#123;item.clazzId &#125;"&gt;123132&lt;/a&gt; &lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 即可显示。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>JdbcTemplate</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod命令]]></title>
    <url>%2F2018%2F11%2F24%2Fchmod%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/home/user/java/jdk1.7.0/bin/java:permission denied处理方法：提升java为执行权限1chmod +x /home/user/java/jdk1.7.0/bin/java 以及javac权限不够也是如此处理。 chmod命令详解使用格式和方法Linux/Ubuntu 系统中文件调用的权限分为三级:文件拥有者(u)、群组(g)、其他(o)。用chmod就可以更改文件的权限。chmod是一个相当灵活的命令，对同一个文件的权限的修改可以用多种风格的命令格式来实现。 方式一语法格式： chmod [-vR] mode 文件名 参数说明: mode 权限设置字串,格式为[ugoa] [+-=] [rwx] u 表示文件的拥有者 g 表示与此文件拥有者属于一个组群的人 o 表示其他人 a 表示包含以上三者即文件拥有者(u)、群组(g)、其他(o) +表示增加权限 -表示取消权限 =表示唯一设置权限 r 表示有读取的权限 w 表示有写入的权限 x 表示有执行的权限 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改例： 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取、写入、执行的权限。 在这里就需要结合sudo命令来使用123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 或者使用123ownlinux@server:/var/www$ sudo chmod ugo+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 命令不一样，但执行后的效果是一样的。 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod a+rwx -R ownlinux[sudo] password for ownlinux: （此时输入你的密码） 语法格式： chmod [-vR] [No] 文件名 参数说明:No 三位代表相应权限的数字 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改 可能这种方式对于初学者来说有一定的难度，但这种方法学会后在更改文件权限就变得非常的简单。 刚才已经说过了，[No]参数 是三位代表相应权限的数字。从左向右，第一位数学代表文件拥有者(u)的权限、群组(g)的权限、其他(o)的权限。每一个数字就对应该级用户拥有的权限即为rwx相应的数字之和。 类似于二进制，如果是所有用户拥有该文件的读取、写入、执行的权限就是拥有者(u)的权限(4+2+1=7)群组(g)的权限(4+2+1=7)其他(o)的权限(4+2+1=7即为777。注意：如果没有读取的权限则”r”相应的数字编号就为”0″,写入(w)、执行(x)同理。 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取(r)、写入(w)、执行(x)的权限。回顾一下方式一的命令格式。123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 可以改为：123ownlinux@server:/var/www$ sudo chmod 777 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 如果要让当前目录下ownlinux这个文件的权限修为该文件的拥有者(u)有该文件的读取(r)、写入(w)、执行(x)的权限,群组(g)和其他(o)的用户只有读取(r)和执行(x)的权限,运行以下命令：123ownlinux@server:/var/www$ sudo chmod 755 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod 777 -R ownlinux[sudo] password for ownlinux: （此时输入你的密码）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放端口查看和打开关闭]]></title>
    <url>%2F2018%2F11%2F24%2F%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[查看打开端口1sudo iptables -L -n 打开80端口1sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F24%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot配置文件]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.config_test.git Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里:12com.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 在类中引入可以用@Value(“${….}”)的注解形式，也可以如下引用：12345678910111213package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "com.example.myproject.customer")public class Customer &#123; private String id; private String name; //getter,setter,toString&#125; 需要在springboot入口类上加上@EnableConfigurationProperties({Customer.class})注解，指明使用了配置文件的类。 12345678910111213141516package com.example.myproject;import com.example.myproject.domain.Customer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;@SpringBootApplication@EnableConfigurationProperties(&#123;Customer.class&#125;)public class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125;&#125; 参数间引用在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置：123com.example.myproject.customer.id = 001com.example.myproject.customer.name = jlcom.example.myproject.customer.title = 序号$&#123;com.example.myproject.customer.id&#125;,姓名$&#123;com.example.myproject.customer.name&#125; 运行测试，如果出现中文乱码，则进行以下步骤： java开发工具Idea下解决方案： File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 注意：做了上面操作后，一定要重新创建application.properties，才有效。 输出效果：1Customer&#123;id='001', name='jl', title='序号001,姓名jl'&#125; 使用自定义配置文件有时候我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里我明取名为test.properties,路径跟也放在src/main/resources下面。123com.example.myproject.customer2.id = 0011com.example.myproject.customer2.name = jlsdfcom.example.myproject.customer2.title = 序号$&#123;com.example.myproject.customer2.id&#125;,姓名$&#123;com.example.myproject.customer2.name&#125; 注意，这里的自定义配置名字不能与之前相同，不然会读取不到（踩坑贼开心）。 我们新建一个bean类,如下：12345678910111213141516package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:test.properties")@ConfigurationProperties(prefix = "com.example.myproject.customer2")public class Customer2 &#123; private String id; private String name; private String title; //getter,setter,toString &#125; 其中使用@PropertySource(value = “classpath:test.properties”)指向了properties文件，使用@ConfigurationProperties(prefix = “com.example.myproject.customer2”)指向了前缀。 在CustomerService和CustomerController中增加函数与调用：1234567891011121314CustomerService.java public Customer2 getCustomer2()&#123; return customer2; &#125;CustomerController.java @RequestMapping("/customer") public String customer(ModelMap map) &#123;// Customer customer = customerService.getCustomer(); Customer2 customer = customerService.getCustomer2(); map.addAttribute("customer", customer); return "index"; &#125; 也可以在Test中进行输出测试。 注：出现错误Spring Boot Configuration Annotion Processor not found in classpath。在pom.xml中引入：12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; 重启idea，会出现Re-run Spring Boot Configuration Annotation Processor to update generated metadata，这个问题可以忽略，不影响代码执行。只是提醒用户，进行必要的重新编译。 随机值配置配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。 range.properties写入：123456range.secret=$&#123;random.value&#125;range.number=$&#123;random.int&#125;range.bignumber=$&#123;random.long&#125;range.uuid=$&#123;random.uuid&#125;range.number.less.than.ten=$&#123;random.int(10)&#125;range.number.in.range=$&#123;random.int[1024,65536]&#125; 使用java接收，Range.java1234567891011121314151617181920212223package com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:range.properties")@ConfigurationProperties(prefix = "range")public class Range &#123; private String secret; private int number; private long bignumber; private String uuid; @Value("$&#123;range.number.less.than.ten&#125;") private int lessThanTen; @Value("$&#123;range.number.in.range&#125;") private int rangeNumber; //setter,getter,toString&#125; 配置相应的service和controller。显示效果如下： 注意，不重启springboot应用，这些值不会改变。 外部配置-命令行参数配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：1java -jar xx.jar 可以以下命令修改tomcat端口号：1java -jar xx.jar --server.port=9090 可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。 如果怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。 测试中的@TestPropertySource注解。 测试中的@SpringBootTest#properties注解特性。 命令行参数 SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。 ServletConfig初始化参数。 ServletContext初始化参数。 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}） 应用程序以外的application.properties或者appliaction.yml文件 打包在应用程序内的application.properties或者appliaction.yml文件 通过@PropertySource标注的属性源 默认属性(通过SpringApplication.setDefaultProperties指定). 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，列如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件的优先级application.properties和application.yml文件可以放在一下四个位置： 外置，在相对于应用程序运行目录的/congfig子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.yml里面的属性就会覆盖application.properties里的属性。 当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。 如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 当然你也可以用命令行启动的时候带上参数：1java -jar xxx.jar --spring.profiles.active=dev 给不同的环境添加不同的端口属性server.port，然后根据指定不同的spring.profiles.active来切换使用。 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口：1public interface DBConnector &#123; public void configure(); &#125; 定义2个类实现：1234567891011121314151617181920@Component@Profile("devDb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125;@Component@Profile("testDb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125; 在application.properties配置，激活其中一个类：1spring.profiles.active=testDb PS：这里一定要写对，如果写成testdb就会报错。 因为这里用的是thyemleaf模版，使用@RestController注解，应该是作为接口，所以可以用postman做测试，可以看到输出了testdb。 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile 12spring.profiles.active: testdb spring.profiles.include: proddb,prodmq]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot常用属性汇总]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[可以在application.properties/application.yml文件中或作为命令行开关指定各种属性。本节提供了常用的Spring Boot属性列表，以及对使用它们的底层类的引用。 属性贡献可以来自您的类路径上的其他jar文件，因此您不应该考虑这是一个详尽的列表。定义您自己的属性也是完全合法的。此示例文件仅作为指南。不要将整个内容复制/粘贴到您的应用程序中;而只是选择你需要的属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184# ===================================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^# ===================================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)# LOGGINGlogging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logbacklogging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.logging.file= # Log file name. For instance `myapp.log`logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`logging.path= # Location of the log file. For instance `/var/log`logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.# AOPspring.aop.auto=true # Add @EnableAspectJAutoProxy.spring.aop.proxy-target-class=false # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false).# IDENTITY (ContextIdApplicationContextInitializer)spring.application.index= # Application index.spring.application.name= # Application name.# ADMIN (SpringApplicationAdminJmxAutoConfiguration)spring.application.admin.enabled=false # Enable admin features for the application.spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.# AUTO-CONFIGURATIONspring.autoconfigure.exclude= # Auto-configuration classes to exclude.# SPRING COREspring.beaninfo.ignore=true # Skip search of BeanInfo classes.# SPRING CACHE (CacheProperties)spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.spring.cache.caffeine.spec= # The spec to use to create caches. Check CaffeineSpec for more details on the spec format.spring.cache.couchbase.expiration=0 # Entry expiration in milliseconds. By default the entries never expire.spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.spring.cache.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.spring.cache.type= # Cache type, auto-detected according to the environment by default.# SPRING CONFIG - using environment property only (ConfigFileApplicationListener)spring.config.location= # Config file locations.spring.config.name=application # Config file name.# HAZELCAST (HazelcastProperties)spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.# PROJECT INFORMATION (ProjectInfoProperties)spring.info.build.location=classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.spring.info.git.location=classpath:git.properties # Location of the generated git.properties file.# JMXspring.jmx.default-domain= # JMX domain name.spring.jmx.enabled=true # Expose management beans to the JMX domain.spring.jmx.server=mbeanServer # MBeanServer bean name.# Email (MailProperties)spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.spring.mail.host= # SMTP server host. For instance `smtp.example.com`spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.spring.mail.password= # Login password of the SMTP server.spring.mail.port= # SMTP server port.spring.mail.properties.*= # Additional JavaMail session properties.spring.mail.protocol=smtp # Protocol used by the SMTP server.spring.mail.test-connection=false # Test that the mail server is available on startup.spring.mail.username= # Login user of the SMTP server.# APPLICATION SETTINGS (SpringApplication)spring.main.banner-mode=console # Mode used to display the banner when the application runs.spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.spring.main.web-environment= # Run the application in a web environment (auto-detected by default).# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding= # Expected character encoding the application must use.# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.always-use-message-format=false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.spring.messages.encoding=UTF-8 # Message bundles encoding.spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.# OUTPUTspring.output.ansi.enabled=detect # Configure the ANSI output.# PID FILE (ApplicationPidFileWriter)spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).# PROFILESspring.profiles.active= # Comma-separated list (or list if using YAML) of active profiles.spring.profiles.include= # Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).# SENDGRID (SendGridAutoConfiguration)spring.sendgrid.api-key= # SendGrid api key (alternative to username/password)spring.sendgrid.username= # SendGrid account usernamespring.sendgrid.password= # SendGrid account passwordspring.sendgrid.proxy.host= # SendGrid proxy hostspring.sendgrid.proxy.port= # SendGrid proxy port# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.address= # Network address to which the server should bind to.server.compression.enabled=false # If response compression is enabled.server.compression.excluded-user-agents= # List of user-agents to exclude from compression.server.compression.mime-types= # Comma-separated list of MIME types that should be compressed. For instance `text/html,text/css,application/json`server.compression.min-response-size= # Minimum response size that is required for compression to be performed. For instance 2048server.connection-timeout= # Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector's container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`server.context-path= # Context path of the application.server.display-name=application # Display name of the application.server.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.server.error.include-stacktrace=never # When to include a "stacktrace" attribute.server.error.path=/error # Path of the error controller.server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.server.jetty.acceptors= # Number of acceptor threads to use.server.jetty.max-http-post-size=0 # Maximum size in bytes of the HTTP post or put content.server.jetty.selectors= # Number of selector threads to use.server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servletserver.jsp-servlet.registered=true # Whether or not the JSP servlet is registeredserver.port=8080 # Server HTTP port.server.server-header= # Value to use for the Server response header (no header is sent if empty)server.servlet-path=/ # Path of the main dispatcher servlet.server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.server.session.cookie.comment= # Comment for the session cookie.server.session.cookie.domain= # Domain for the session cookie.server.session.cookie.http-only= # "HttpOnly" flag for the session cookie.server.session.cookie.max-age= # Maximum age of the session cookie in seconds.server.session.cookie.name= # Session cookie name.server.session.cookie.path= # Path of the session cookie.server.session.cookie.secure= # "Secure" flag for the session cookie.server.session.persistent=false # Persist session data between restarts.server.session.store-dir= # Directory used to store session data.server.session.timeout= # Session timeout in seconds.server.session.tracking-modes= # Session tracking modes (one or more of the following: "cookie", "url", "ssl").server.ssl.ciphers= # Supported SSL ciphers.server.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store.server.ssl.enabled= # Enable SSL support.server.ssl.enabled-protocols= # Enabled SSL protocols.server.ssl.key-alias= # Alias that identifies the key in the key store.server.ssl.key-password= # Password used to access the key in the key store.server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password= # Password used to access the key store.server.ssl.key-store-provider= # Provider for the key store.server.ssl.key-store-type= # Type of the key store.server.ssl.protocol=TLS # SSL protocol to use.server.ssl.trust-store= # Trust store that holds SSL certificates.server.ssl.trust-store-password= # Password used to access the trust store.server.ssl.trust-store-provider= # Provider for the trust store.server.ssl.trust-store-type= # Type of the trust store.server.tomcat.accept-count= # Maximum queue length for incoming connection requests when all possible request processing threads are in use.server.tomcat.accesslog.buffered=true # Buffer output such that it is only flushed periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address, Hostname, protocol and port used for the request.server.tomcat.accesslog.rotate=true # Enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-connections= # Maximum number of connections that the server will accept and process at any given time.server.tomcat.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.tomcat.max-threads=0 # Maximum amount of worker threads.server.tomcat.min-spare-threads=0 # Minimum amount of worker threads.server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named "X-Forwarded-Proto".server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected by appending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.server.undertow.accesslog.dir= # Undertow access log directory.server.undertow.accesslog.enabled=false # Enable access log.server.undertow.accesslog.pattern=common # Format pattern for access logs.server.undertow.accesslog.prefix=access_log. # Log file name prefix.server.undertow.accesslog.rotate=true # Enable access log rotation.server.undertow.accesslog.suffix=log # Log file name suffix.server.undertow.buffer-size= # Size of each buffer in bytes.server.undertow.buffers-per-region= # Number of buffer per region.server.undertow.direct-buffers= # Allocate buffers outside the Java heap.server.undertow.io-threads= # Number of I/O threads to create for the worker.server.undertow.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.undertow.worker-threads= # Number of worker threads.# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.cache=false # Enable template caching.spring.freemarker.charset=UTF-8 # Template encoding.spring.freemarker.check-template-location=true # Check that the templates location exists.spring.freemarker.content-type=text/html # Content-Type value.spring.freemarker.enabled=true # Enable MVC view resolution for this technology.spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker's Configuration.spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.spring.freemarker.view-names= # White list of view names that can be resolved.# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.cache= # Enable template caching.spring.groovy.template.charset=UTF-8 # Template encoding.spring.groovy.template.check-template-location=true # Check that the templates location exists.spring.groovy.template.configuration.*= # See GroovyMarkupConfigurerspring.groovy.template.content-type=test/html # Content-Type value.spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.spring.groovy.template.view-names= # White list of view names that can be resolved.# SPRING HATEOAS (HateoasProperties)spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.# HTTP message conversionspring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to "gson" to force the use of Gson when both it and Jackson are on the classpath.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.spring.http.encoding.enabled=true # Enable http encoding support.spring.http.encoding.force= # Force the encoding to the configured charset on HTTP requests and responses.spring.http.encoding.force-request= # Force the encoding to the configured charset on HTTP requests. Defaults to true when "force" has not been specified.spring.http.encoding.force-response= # Force the encoding to the configured charset on HTTP responses.spring.http.encoding.mapping= # Locale to Encoding mapping.# MULTIPART (MultipartProperties)spring.http.multipart.enabled=true # Enable support of multi-part uploads.spring.http.multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.location= # Intermediate location of uploaded files.spring.http.multipart.max-file-size=1MB # Max file size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.max-request-size=10MB # Max request size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.resolve-lazily=false # Whether to resolve the multipart request lazily at the time of file or parameter access.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization.spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.spring.jackson.generator.*= # Jackson on/off features for generators.spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" will be used as a fallback if it is configured with a format string.spring.jackson.locale= # Locale used for formatting.spring.jackson.mapper.*= # Jackson general purpose on/off features.spring.jackson.parser.*= # Jackson on/off features for parsers.spring.jackson.property-naming-strategy= # One of the constants on Jackson's PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`# JERSEY (JerseyProperties)spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of "@ApplicationPath" if specified.spring.jersey.filter.order=0 # Jersey filter chain order.spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.spring.jersey.servlet.load-on-startup=-1 # Load on startup priority of the Jersey servlet.spring.jersey.type=servlet # Jersey integration type.# SPRING LDAP (LdapProperties)spring.ldap.urls= # LDAP URLs of the server.spring.ldap.base= # Base suffix from which all operations should originate.spring.ldap.username= # Login user of the server.spring.ldap.password= # Login password of the server.spring.ldap.base-environment.*= # LDAP specification settings.# EMBEDDED LDAP (EmbeddedLdapProperties)spring.ldap.embedded.port= # Embedded LDAP port.spring.ldap.embedded.credential.username= # Embedded LDAP username.spring.ldap.embedded.credential.password= # Embedded LDAP password.spring.ldap.embedded.base-dn= # The base DNspring.ldap.embedded.ldif=classpath:schema.ldif # Schema (LDIF) script resource reference.# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.# MUSTACHE TEMPLATES (MustacheAutoConfiguration)spring.mustache.allow-request-override= # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.allow-session-override= # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.cache= # Enable template caching.spring.mustache.charset= # Template encoding.spring.mustache.check-template-location= # Check that the templates location exists.spring.mustache.content-type= # Content-Type value.spring.mustache.enabled= # Enable MVC view resolution for this technology.spring.mustache.expose-request-attributes= # Set whether all request attributes should be added to the model prior to merging with the template.spring.mustache.expose-session-attributes= # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.mustache.expose-spring-macro-helpers= # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.spring.mustache.request-context-attribute= # Name of the RequestContext attribute for all views.spring.mustache.suffix=.html # Suffix to apply to template names.spring.mustache.view-names= # White list of view names that can be resolved.# SPRING MVC (WebMvcProperties)spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.spring.mvc.dispatch-options-request=true # Dispatch OPTIONS requests to the FrameworkServlet doService method.spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.spring.mvc.formcontent.putfilter.enabled=true # Enable Spring's HttpPutFormContentFilter.spring.mvc.ignore-default-model-on-redirect=true # If the content of the "default" model should be ignored during redirect scenarios.spring.mvc.locale= # Locale to use. By default, this locale is overridden by the "Accept-Language" header.spring.mvc.locale-resolver=accept-header # Define how the locale should be resolved.spring.mvc.log-resolved-exception=false # Enable warn logging of exceptions resolved by a "HandlerExceptionResolver".spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.throw-exception-if-no-handler-found=false # If a "NoHandlerFoundException" should be thrown if no Handler was found to process a request.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# SPRING RESOURCES HANDLING (ResourceProperties)spring.resources.add-mappings=true # Enable default resource handling.spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.spring.resources.chain.cache=true # Enable caching in the Resource chain.spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.spring.resources.chain.gzipped=false # Enable resolution of already gzipped resources.spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.spring.resources.chain.strategy.fixed.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.# SPRING SESSION (SessionProperties)spring.session.hazelcast.flush-mode=on-save # Sessions flush mode.spring.session.hazelcast.map-name=spring:session:sessions # Name of the map used to store sessions.spring.session.jdbc.initializer.enabled= # Create the required session tables on startup if necessary. Enabled automatically if the default table name is set or a custom schema is configured.spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.session.jdbc.table-name=SPRING_SESSION # Name of database table used to store sessions.spring.session.mongo.collection-name=sessions # Collection name used to store sessions.spring.session.redis.flush-mode=on-save # Sessions flush mode.spring.session.redis.namespace= # Namespace for keys used to store sessions.spring.session.store-type= # Session store type.# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=false # Enable the connection status view for supported providers.# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application's Facebook App IDspring.social.facebook.app-secret= # your application's Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application's LinkedIn App IDspring.social.linkedin.app-secret= # your application's LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application's Twitter App IDspring.social.twitter.app-secret= # your application's Twitter App Secret# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.cache=true # Enable template caching.spring.thymeleaf.check-template=true # Check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Check that the templates location exists.spring.thymeleaf.content-type=text/html # Content-Type value.spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.spring.thymeleaf.encoding=UTF-8 # Template encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.# SPRING WEB SERVICES (WebServicesProperties)spring.webservices.path=/services # Path that serves as the base URI for the services.spring.webservices.servlet.init= # Servlet init parameters to pass to Spring Web Services.spring.webservices.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)security.basic.authorize-mode=role # Security authorize mode to apply.security.basic.enabled=true # Enable basic authentication.security.basic.path=/** # Comma-separated list of paths to secure.security.basic.realm=Spring # HTTP basic realm name.security.enable-csrf=false # Enable Cross Site Request Forgery support.security.filter-order=0 # Security filter chain order.security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.security.headers.cache=true # Enable cache control HTTP headers.security.headers.content-security-policy= # Value for content security policy header.security.headers.content-security-policy-mode=default # Content security policy mode.security.headers.content-type=true # Enable "X-Content-Type-Options" header.security.headers.frame=true # Enable "X-Frame-Options" header.security.headers.hsts=all # HTTP Strict Transport Security (HSTS) mode (none, domain, all).security.headers.xss=true # Enable cross site scripting (XSS) protection.security.ignored= # Comma-separated list of paths to exclude from the default secured paths.security.require-ssl=false # Enable secure channel for all requests.security.sessions=stateless # Session creation policy (always, never, if_required, stateless).security.user.name=user # Default user name.security.user.password= # Password for the default user name. A random password is logged on startup by default.security.user.role=USER # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)security.oauth2.client.client-id= # OAuth2 client id.security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default# SECURITY OAUTH2 RESOURCES (ResourceServerProperties)security.oauth2.resource.filter-order= # The order of the filter chain used to authenticate tokens.security.oauth2.resource.id= # Identifier of the resource.security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.security.oauth2.resource.service-id=resource #security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.security.oauth2.resource.user-info-uri= # URI of the user endpoint.# SECURITY OAUTH2 SSO (OAuth2SsoProperties)security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdaptersecurity.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server# ----------------------------------------# DATA PROPERTIES# ----------------------------------------# FLYWAY (FlywayProperties)flyway.baseline-description= #flyway.baseline-version=1 # version to start migrationflyway.baseline-on-migrate= #flyway.check-location=false # Check that migration scripts location exists.flyway.clean-on-validation-error= #flyway.enabled=true # Enable flyway.flyway.encoding= #flyway.ignore-failed-future-migration= #flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.flyway.locations=classpath:db/migration # locations of migrations scriptsflyway.out-of-order= #flyway.password= # JDBC password if you want Flyway to create its own DataSourceflyway.placeholder-prefix= #flyway.placeholder-replacement= #flyway.placeholder-suffix= #flyway.placeholders.*= #flyway.schemas= # schemas to updateflyway.sql-migration-prefix=V #flyway.sql-migration-separator= #flyway.sql-migration-suffix=.sql #flyway.table= #flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.flyway.user= # Login user of the database to migrate.flyway.validate-on-migrate= ## LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.liquibase.check-change-log-location=true # Check the change log location exists.liquibase.contexts= # Comma-separated list of runtime contexts to use.liquibase.default-schema= # Default database schema.liquibase.drop-first=false # Drop the database schema first.liquibase.enabled=true # Enable liquibase support.liquibase.labels= # Comma-separated list of runtime labels to use.liquibase.parameters.*= # Change log parameters.liquibase.password= # Login password of the database to migrate.liquibase.rollback-file= # File to which rollback SQL will be written when an update is performed.liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.liquibase.user= # Login user of the database to migrate.# COUCHBASE (CouchbaseProperties)spring.couchbase.bootstrap-hosts= # Couchbase nodes (host or IP address) to bootstrap from.spring.couchbase.bucket.name=default # Name of the bucket to connect to.spring.couchbase.bucket.password= # Password of the bucket.spring.couchbase.env.endpoints.key-value=1 # Number of sockets per node against the Key/value service.spring.couchbase.env.endpoints.query=1 # Number of sockets per node against the Query (N1QL) service.spring.couchbase.env.endpoints.view=1 # Number of sockets per node against the view service.spring.couchbase.env.ssl.enabled= # Enable SSL support. Enabled automatically if a "keyStore" is provided unless specified otherwise.spring.couchbase.env.ssl.key-store= # Path to the JVM key store that holds the certificates.spring.couchbase.env.ssl.key-store-password= # Password used to access the key store.spring.couchbase.env.timeouts.connect=5000 # Bucket connections timeout in milliseconds.spring.couchbase.env.timeouts.key-value=2500 # Blocking operations performed on a specific key timeout in milliseconds.spring.couchbase.env.timeouts.query=7500 # N1QL query operations timeout in milliseconds.spring.couchbase.env.timeouts.socket-connect=1000 # Socket connect connections timeout in milliseconds.spring.couchbase.env.timeouts.view=7500 # Regular and geospatial view operations timeout in milliseconds.# DAO (PersistenceExceptionTranslationAutoConfiguration)spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.# CASSANDRA (CassandraProperties)spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.spring.data.cassandra.compression=none # Compression supported by the Cassandra binary protocol.spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.spring.data.cassandra.consistency-level= # Queries consistency level.spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.spring.data.cassandra.fetch-size= # Queries default fetch size.spring.data.cassandra.keyspace-name= # Keyspace name to use.spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.spring.data.cassandra.port= # Port of the Cassandra server.spring.data.cassandra.password= # Login password of the server.spring.data.cassandra.read-timeout-millis= # Socket option: read time out.spring.data.cassandra.reconnection-policy= # Reconnection policy class.spring.data.cassandra.retry-policy= # Class name of the retry policy.spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.spring.data.cassandra.schema-action=none # Schema action to take at startup.spring.data.cassandra.ssl=false # Enable SSL support.spring.data.cassandra.username= # Login user of the server.# DATA COUCHBASE (CouchbaseDataProperties)spring.data.couchbase.auto-index=false # Automatically create views and indexes.spring.data.couchbase.consistency=read-your-own-writes # Consistency to apply by default on generated queries.spring.data.couchbase.repositories.enabled=true # Enable Couchbase repositories.# ELASTICSEARCH (ElasticsearchProperties)spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.# DATA LDAPspring.data.ldap.repositories.enabled=true # Enable LDAP repositories.# MONGODB (MongoProperties)spring.data.mongodb.authentication-database= # Authentication database name.spring.data.mongodb.database=test # Database name.spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database= # GridFS database name.spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.# DATA REDISspring.data.redis.repositories.enabled=true # Enable Redis repositories.# NEO4J (Neo4jProperties)spring.data.neo4j.compiler= # Compiler to use.spring.data.neo4j.embedded.enabled=true # Enable embedded mode if the embedded driver is available.spring.data.neo4j.open-in-view=false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.spring.data.neo4j.password= # Login password of the server.spring.data.neo4j.repositories.enabled=true # Enable Neo4j repositories.spring.data.neo4j.uri= # URI used by the driver. Auto-detected by default.spring.data.neo4j.username= # Login user of the server.# DATA REST (RepositoryRestProperties)spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.spring.data.rest.default-page-size= # Default size of pages.spring.data.rest.detection-strategy=default # Strategy to use to determine which repositories get exposed.spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.spring.data.rest.max-page-size= # Maximum size of pages.spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.spring.data.rest.return-body-on-create= # Return a response body after creating an entity.spring.data.rest.return-body-on-update= # Return a response body after updating an entity.spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.# SOLR (SolrProperties)spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if "zk-host" is set.spring.data.solr.repositories.enabled=true # Enable Solr repositories.spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.spring.datasource.data= # Data (DML) script resource references.spring.datasource.data-username= # User of the database to execute DML scripts (if different).spring.datasource.data-password= # Password of the database to execute DML scripts (if different).spring.datasource.dbcp2.*= # Commons DBCP2 specific settingsspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.generate-unique-name=false # Generate a random datasource name.spring.datasource.hikari.*= # Hikari specific settingsspring.datasource.initialize=true # Populate the database using 'data.sql'.spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.spring.datasource.name=testdb # Name of the datasource.spring.datasource.password= # Login password of the database.spring.datasource.platform=all # Platform to use in the schema resource (schema-$&#123;platform&#125;.sql).spring.datasource.schema= # Schema (DDL) script resource references.spring.datasource.schema-username= # User of the database to execute DDL scripts (if different).spring.datasource.schema-password= # Password of the database to execute DDL scripts (if different).spring.datasource.separator=; # Statement separator in SQL initialization scripts.spring.datasource.sql-script-encoding= # SQL scripts encoding.spring.datasource.tomcat.*= # Tomcat datasource specific settingsspring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.spring.datasource.url= # JDBC url of the database.spring.datasource.username=# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.connection-timeout=3000 # Connection timeout in milliseconds.spring.elasticsearch.jest.multi-threaded=true # Enable connection requests from multiple execution threads.spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3000 # Read timeout in milliseconds.spring.elasticsearch.jest.uris=http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.spring.elasticsearch.jest.username= # Login user.# H2 Web Console (H2ConsoleProperties)spring.h2.console.enabled=false # Enable the console.spring.h2.console.path=/h2-console # Path at which the console will be available.spring.h2.console.settings.trace=false # Enable trace output.spring.h2.console.settings.web-allow-others=false # Enable remote access.# JOOQ (JooqAutoConfiguration)spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.data.jpa.repositories.enabled=true # Enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the "databasePlatform" property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the "Database" enum.spring.jpa.generate-ddl=false # Initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto" property. Default to "create-drop" when using an embedded database, "none" otherwise.spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.naming.strategy= # Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate 5.spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Enable logging of SQL statements.# JTA (JtaAutoConfiguration)spring.jta.enabled=true # Enable JTA support.spring.jta.log-dir= # Transaction logs directory.spring.jta.transaction-manager-id= # Transaction manager unique identifier.# ATOMIKOS (AtomikosProperties)spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.atomikos.properties.checkpoint-interval=500 # Interval between checkpoints.spring.jta.atomikos.properties.console-file-count=1 # Number of debug logs files that can be created.spring.jta.atomikos.properties.console-file-limit=-1 # How many bytes can be stored at most in debug logs files.spring.jta.atomikos.properties.console-file-name=tm.out # Debug logs file name.spring.jta.atomikos.properties.console-log-level=warn # Console log level.spring.jta.atomikos.properties.default-jta-timeout=10000 # Default timeout for JTA transactions.spring.jta.atomikos.properties.enable-logging=true # Enable disk logging.spring.jta.atomikos.properties.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.spring.jta.atomikos.properties.log-base-dir= # Directory in which the log files should be stored.spring.jta.atomikos.properties.log-base-name=tmlog # Transactions log file base name.spring.jta.atomikos.properties.max-actives=50 # Maximum number of active transactions.spring.jta.atomikos.properties.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.spring.jta.atomikos.properties.output-dir= # Directory in which to store the debug log files.spring.jta.atomikos.properties.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.spring.jta.atomikos.properties.service= # Transaction manager implementation that should be started.spring.jta.atomikos.properties.threaded-two-phase-commit=true # Use different (and concurrent) threads for two-phase commit on the participating resources.spring.jta.atomikos.properties.transaction-manager-unique-name= # Transaction manager's unique name.# BITRONIXspring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.spring.jta.bitronix.connectionfactory.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.spring.jta.bitronix.datasource.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.properties.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.spring.jta.bitronix.properties.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.spring.jta.bitronix.properties.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.spring.jta.bitronix.properties.current-node-only-recovery=true # Recover only the current node.spring.jta.bitronix.properties.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.spring.jta.bitronix.properties.default-transaction-timeout=60 # Default transaction timeout in seconds.spring.jta.bitronix.properties.disable-jmx=false # Enable JMX support.spring.jta.bitronix.properties.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.spring.jta.bitronix.properties.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.spring.jta.bitronix.properties.force-batching-enabled=true # Set if disk forces are batched.spring.jta.bitronix.properties.forced-write-enabled=true # Set if logs are forced to disk.spring.jta.bitronix.properties.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.spring.jta.bitronix.properties.jndi-user-transaction-name= # JNDI name of the UserTransaction.spring.jta.bitronix.properties.journal=disk # Name of the journal. Can be 'disk', 'null' or a class name.spring.jta.bitronix.properties.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.spring.jta.bitronix.properties.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.spring.jta.bitronix.properties.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.spring.jta.bitronix.properties.resource-configuration-filename= # ResourceLoader configuration file name.spring.jta.bitronix.properties.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine's IP address.spring.jta.bitronix.properties.skip-corrupted-logs=false # Skip corrupted transactions log entries.spring.jta.bitronix.properties.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.# NARAYANA (NarayanaProperties)spring.jta.narayana.default-timeout=60 # Transaction timeout in seconds.spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.spring.jta.narayana.log-dir= # Transaction object store directory.spring.jta.narayana.one-phase-commit=true # Enable one phase commit optimisation.spring.jta.narayana.periodic-recovery-period=120 # Interval in which periodic recovery scans are performed in seconds.spring.jta.narayana.recovery-backoff-period=10 # Back off period between first and second phases of the recovery scan in seconds.spring.jta.narayana.recovery-db-pass= # Database password to be used by recovery manager.spring.jta.narayana.recovery-db-user= # Database username to be used by recovery manager.spring.jta.narayana.recovery-jms-pass= # JMS password to be used by recovery manager.spring.jta.narayana.recovery-jms-user= # JMS username to be used by recovery manager.spring.jta.narayana.recovery-modules= # Comma-separated list of recovery modules.spring.jta.narayana.transaction-manager-id=1 # Unique transaction manager id.spring.jta.narayana.xa-resource-orphan-filters= # Comma-separated list of orphan filters.# EMBEDDED MONGODB (EmbeddedMongoProperties)spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.spring.mongodb.embedded.storage.database-dir= # Directory used for data storage.spring.mongodb.embedded.storage.oplog-size= # Maximum size of the oplog in megabytes.spring.mongodb.embedded.storage.repl-set-name= # Name of the replica set.spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.# REDIS (RedisProperties)spring.redis.cluster.max-redirects= # Maximum number of redirects to follow when executing commands across the cluster.spring.redis.cluster.nodes= # Comma-separated list of "host:port" pairs to bootstrap from.spring.redis.database=0 # Database index used by the connection factory.spring.redis.url= # Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.ssl=false # Enable SSL support.spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.spring.redis.pool.max-idle=8 # Max number of "idle" connections in the pool. Use a negative value to indicate an unlimited number of idle connections.spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.spring.redis.port=6379 # Redis server port.spring.redis.sentinel.master= # Name of Redis server.spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.spring.redis.timeout=0 # Connection timeout in milliseconds.# TRANSACTION (TransactionProperties)spring.transaction.default-timeout= # Default transaction timeout in seconds.spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.# ----------------------------------------# INTEGRATION PROPERTIES# ----------------------------------------# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default. For instance `tcp://localhost:61616`spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.spring.activemq.password= # Login password of the broker.spring.activemq.user= # Login user of the broker.spring.activemq.packages.trust-all=false # Trust all packages.spring.activemq.packages.trusted= # Comma-separated list of specific packages to trust (when not trusting all packages).spring.activemq.pool.configuration.*= # See PooledConnectionFactory.spring.activemq.pool.enabled=false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.spring.activemq.pool.expiry-timeout=0 # Connection expiration timeout in milliseconds.spring.activemq.pool.idle-timeout=30000 # Connection idle timeout in milliseconds.spring.activemq.pool.max-connections=1 # Maximum number of pooled connections.# ARTEMIS (ArtemisProperties)spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.spring.artemis.embedded.persistent=false # Enable persistent store.spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.spring.artemis.host=localhost # Artemis broker host.spring.artemis.mode= # Artemis deployment mode, auto-detected by default.spring.artemis.password= # Login password of the broker.spring.artemis.port=61616 # Artemis broker port.spring.artemis.user= # Login user of the broker.# SPRING BATCH (BatchProperties)spring.batch.initializer.enabled= # Create the required batch tables on startup if necessary. Enabled automatically if no custom table prefix is set or if a custom schema is configured.spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.# JMS (JmsProperties)spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.spring.jms.listener.auto-startup=true # Start the container automatically on startup.spring.jms.listener.concurrency= # Minimum number of concurrent consumers.spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.spring.jms.template.default-destination= # Default destination to use on send/receive operations that do not have a destination parameter.spring.jms.template.delivery-delay= # Delivery delay to use for send calls in milliseconds.spring.jms.template.delivery-mode= # Delivery mode. Enable QoS when set.spring.jms.template.priority= # Priority of a message when sending. Enable QoS when set.spring.jms.template.qos-enabled= # Enable explicit QoS when sending a message.spring.jms.template.receive-timeout= # Timeout to use for receive calls in milliseconds.spring.jms.template.time-to-live= # Time-to-live of a message when sending in milliseconds. Enable QoS when set.# APACHE KAFKA (KafkaProperties)spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.consumer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.enable-auto-commit= # If true the consumer's offset will be periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch.min.bytes".spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request in bytes.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group this consumer belongs to.spring.kafka.consumer.heartbeat-interval= # Expected time in milliseconds between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".spring.kafka.listener.ack-mode= # Listener AckMode; see the spring-kafka documentation.spring.kafka.listener.ack-time= # Time in milliseconds between offset commits when ackMode is "TIME" or "COUNT_TIME".spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.poll-timeout= # Timeout in milliseconds to use when polling the consumer.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Number of records to batch before sending.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.producer.buffer-memory= # Total bytes of memory the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.keystore-location= # Location of the key store file.spring.kafka.ssl.keystore-password= # Store password for the key store file.spring.kafka.ssl.truststore-location= # Location of the trust store file.spring.kafka.ssl.truststore-password= # Store password for the trust store file.spring.kafka.template.default-topic= # Default topic to which messages will be sent.# RABBIT (RabbitProperties)spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect.spring.rabbitmq.cache.channel.checkout-timeout= # Number of milliseconds to wait to obtain a channel if the cache size has been reached.spring.rabbitmq.cache.channel.size= # Number of channels to retain in the cache.spring.rabbitmq.cache.connection.mode=channel # Connection factory cache mode.spring.rabbitmq.cache.connection.size= # Number of connections to cache.spring.rabbitmq.connection-timeout= # Connection timeout, in milliseconds; zero for infinite.spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.spring.rabbitmq.host=localhost # RabbitMQ host.spring.rabbitmq.listener.acknowledge-mode= # Acknowledge mode of container.spring.rabbitmq.listener.auto-startup=true # Start the container automatically on startup.spring.rabbitmq.listener.concurrency= # Minimum number of consumers.spring.rabbitmq.listener.default-requeue-rejected= # Whether or not to requeue delivery failures; default `true`.spring.rabbitmq.listener.idle-event-interval= # How often idle container events should be published in milliseconds.spring.rabbitmq.listener.max-concurrency= # Maximum number of consumers.spring.rabbitmq.listener.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).spring.rabbitmq.listener.retry.enabled=false # Whether or not publishing retries are enabled.spring.rabbitmq.listener.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message.spring.rabbitmq.listener.retry.max-attempts=3 # Maximum number of attempts to deliver a message.spring.rabbitmq.listener.retry.max-interval=10000 # Maximum interval between attempts.spring.rabbitmq.listener.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval.spring.rabbitmq.listener.retry.stateless=true # Whether or not retry is stateless or stateful.spring.rabbitmq.listener.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.spring.rabbitmq.password= # Login to authenticate against the broker.spring.rabbitmq.port=5672 # RabbitMQ port.spring.rabbitmq.publisher-confirms=false # Enable publisher confirms.spring.rabbitmq.publisher-returns=false # Enable publisher returns.spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.spring.rabbitmq.ssl.enabled=false # Enable SSL support.spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.spring.rabbitmq.template.mandatory=false # Enable mandatory messages.spring.rabbitmq.template.receive-timeout=0 # Timeout for `receive()` methods.spring.rabbitmq.template.reply-timeout=5000 # Timeout for `sendAndReceive()` methods.spring.rabbitmq.template.retry.enabled=false # Set to true to enable retries in the `RabbitTemplate`.spring.rabbitmq.template.retry.initial-interval=1000 # Interval between the first and second attempt to publish a message.spring.rabbitmq.template.retry.max-attempts=3 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.max-interval=10000 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.multiplier=1.0 # A multiplier to apply to the previous publishing retry interval.spring.rabbitmq.username= # Login user to authenticate to the broker.spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# ENDPOINTS (AbstractEndpoint subclasses)endpoints.enabled=true # Enable endpoints.endpoints.sensitive= # Default endpoint sensitive setting.endpoints.actuator.enabled=true # Enable the endpoint.endpoints.actuator.path= # Endpoint URL path.endpoints.actuator.sensitive=false # Enable security on the endpoint.endpoints.auditevents.enabled= # Enable the endpoint.endpoints.auditevents.path= # Endpoint path.endpoints.auditevents.sensitive=false # Enable security on the endpoint.endpoints.autoconfig.enabled= # Enable the endpoint.endpoints.autoconfig.id= # Endpoint identifier.endpoints.autoconfig.path= # Endpoint path.endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.beans.enabled= # Enable the endpoint.endpoints.beans.id= # Endpoint identifier.endpoints.beans.path= # Endpoint path.endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.configprops.enabled= # Enable the endpoint.endpoints.configprops.id= # Endpoint identifier.endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.configprops.path= # Endpoint path.endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.docs.curies.enabled=false # Enable the curie generation.endpoints.docs.enabled=true # Enable actuator docs endpoint.endpoints.docs.path=/docs #endpoints.docs.sensitive=false #endpoints.dump.enabled= # Enable the endpoint.endpoints.dump.id= # Endpoint identifier.endpoints.dump.path= # Endpoint path.endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.env.enabled= # Enable the endpoint.endpoints.env.id= # Endpoint identifier.endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.env.path= # Endpoint path.endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.flyway.enabled= # Enable the endpoint.endpoints.flyway.id= # Endpoint identifier.endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.enabled= # Enable the endpoint.endpoints.health.id= # Endpoint identifier.endpoints.health.mapping.*= # Mapping of health statuses to HttpStatus codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).endpoints.health.path= # Endpoint path.endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.endpoints.heapdump.enabled= # Enable the endpoint.endpoints.heapdump.path= # Endpoint path.endpoints.heapdump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.hypermedia.enabled=false # Enable hypermedia support for endpoints.endpoints.info.enabled= # Enable the endpoint.endpoints.info.id= # Endpoint identifier.endpoints.info.path= # Endpoint path.endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.jolokia.enabled=true # Enable Jolokia endpoint.endpoints.jolokia.path=/jolokia # Endpoint URL path.endpoints.jolokia.sensitive=true # Enable security on the endpoint.endpoints.liquibase.enabled= # Enable the endpoint.endpoints.liquibase.id= # Endpoint identifier.endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.logfile.enabled=true # Enable the endpoint.endpoints.logfile.external-file= # External Logfile to be accessed.endpoints.logfile.path=/logfile # Endpoint URL path.endpoints.logfile.sensitive=true # Enable security on the endpoint.endpoints.loggers.enabled=true # Enable the endpoint.endpoints.loggers.id= # Endpoint identifier.endpoints.loggers.path=/logfile # Endpoint path.endpoints.loggers.sensitive=true # Mark if the endpoint exposes sensitive information.endpoints.mappings.enabled= # Enable the endpoint.endpoints.mappings.id= # Endpoint identifier.endpoints.mappings.path= # Endpoint path.endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.metrics.enabled= # Enable the endpoint.endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.endpoints.metrics.filter.gauge-submissions=merged # Http filter gauge submissions (merged, per-http-method)endpoints.metrics.filter.counter-submissions=merged # Http filter counter submissions (merged, per-http-method)endpoints.metrics.id= # Endpoint identifier.endpoints.metrics.path= # Endpoint path.endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.shutdown.enabled= # Enable the endpoint.endpoints.shutdown.id= # Endpoint identifier.endpoints.shutdown.path= # Endpoint path.endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.trace.enabled= # Enable the endpoint.endpoints.trace.id= # Endpoint identifier.endpoints.trace.path= # Endpoint path.endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.# ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. '*' allows all headers.endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. '*' allows all methods.endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. '*' allows all origins. When not set, CORS support is disabled.endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.domain= # JMX domain name. Initialized with the value of 'spring.jmx.default-domain' if set.endpoints.jmx.enabled=true # Enable JMX export of all endpoints.endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.add-application-context-header=true # Add the "X-Application-Context" HTTP header in each response.management.address= # Network address that the management endpoints should bind to.management.context-path= # Management endpoint context-path. For instance `/actuator`management.cloudfoundry.enabled= # Enable extended Cloud Foundry actuator endpointsmanagement.cloudfoundry.skip-ssl-validation= # Skip SSL verification for Cloud Foundry actuator endpoint security callsmanagement.port= # Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.management.security.enabled=true # Enable security.management.security.roles=ACTUATOR # Comma-separated list of roles that can access the management endpoint.management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).management.ssl.ciphers= # Supported SSL ciphers. Requires a custom management.port.management.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store. Requires a custom management.port.management.ssl.enabled= # Enable SSL support. Requires a custom management.port.management.ssl.enabled-protocols= # Enabled SSL protocols. Requires a custom management.port.management.ssl.key-alias= # Alias that identifies the key in the key store. Requires a custom management.port.management.ssl.key-password= # Password used to access the key in the key store. Requires a custom management.port.management.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.management.ssl.key-store-password= # Password used to access the key store. Requires a custom management.port.management.ssl.key-store-provider= # Provider for the key store. Requires a custom management.port.management.ssl.key-store-type= # Type of the key store. Requires a custom management.port.management.ssl.protocol=TLS # SSL protocol to use. Requires a custom management.port.management.ssl.trust-store= # Trust store that holds SSL certificates. Requires a custom management.port.management.ssl.trust-store-password= # Password used to access the trust store. Requires a custom management.port.management.ssl.trust-store-provider= # Provider for the trust store. Requires a custom management.port.management.ssl.trust-store-type= # Type of the trust store. Requires a custom management.port.# HEALTH INDICATORSmanagement.health.db.enabled=true # Enable database health check.management.health.cassandra.enabled=true # Enable cassandra health check.management.health.couchbase.enabled=true # Enable couchbase health check.management.health.defaults.enabled=true # Enable default health indicators.management.health.diskspace.enabled=true # Enable disk space health check.management.health.diskspace.path= # Path used to compute the available disk space.management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.management.health.elasticsearch.enabled=true # Enable elasticsearch health check.management.health.elasticsearch.indices= # Comma-separated index names.management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.management.health.jms.enabled=true # Enable JMS health check.management.health.ldap.enabled=true # Enable LDAP health check.management.health.mail.enabled=true # Enable Mail health check.management.health.mongo.enabled=true # Enable MongoDB health check.management.health.rabbit.enabled=true # Enable RabbitMQ health check.management.health.redis.enabled=true # Enable Redis health check.management.health.solr.enabled=true # Enable Solr health check.management.health.status.order=DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.# INFO CONTRIBUTORS (InfoContributorProperties)management.info.build.enabled=true # Enable build info.management.info.defaults.enabled=true # Enable default info contributors.management.info.env.enabled=true # Enable environment info.management.info.git.enabled=true # Enable git info.management.info.git.mode=simple # Mode to use to expose git information.# REMOTE SHELL (ShellProperties)management.shell.auth.type=simple # Authentication type. Auto-detected according to the environment.management.shell.auth.jaas.domain=my-domain # JAAS domain.management.shell.auth.key.path= # Path to the authentication key. This should point to a valid ".pem" file.management.shell.auth.simple.user.name=user # Login user.management.shell.auth.simple.user.password= # Login password.management.shell.auth.spring.roles=ACTUATOR # Comma-separated list of required roles to login to the CRaSH console.management.shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.management.shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).management.shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.management.shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.management.shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.management.shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.management.shell.ssh.enabled=true # Enable CRaSH SSH support.management.shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.management.shell.ssh.key-path= # Path to the SSH server key.management.shell.ssh.port=2000 # SSH port.management.shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is available.management.shell.telnet.port=5000 # Telnet port.# TRACING (TraceProperties)management.trace.include=request-headers,response-headers,cookies,errors # Items to be included in the trace.# METRICS EXPORT (MetricExportProperties)spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.spring.metrics.export.includes= # List of patterns for metric names to include.spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.# ----------------------------------------# DEVTOOLS PROPERTIES# ----------------------------------------# DEVTOOLS (DevToolsProperties)spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.spring.devtools.livereload.port=35729 # Server port.spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-paths= # Additional paths to watch for changes.spring.devtools.restart.enabled=true # Enable automatic restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.# REMOTE DEVTOOLS (RemoteDevToolsProperties)spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.spring.devtools.remote.debug.enabled=true # Enable remote debug support.spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.spring.devtools.remote.restart.enabled=true # Enable remote restart.spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.# ----------------------------------------# TESTING PROPERTIES# ----------------------------------------spring.test.database.replace=any # Type of existing DataSource to replace.spring.test.mockmvc.print=default # MVC Print option.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot工程结构推荐]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.myproject.git Spring Boot框架本身并没有对工程结构有特别的要求，但是按照最佳实践的工程结构可以帮助我们减少可能会遇见的坑，尤其是Spring包扫描机制的存在，如果您使用最佳实践的工程结构，可以免去不少特殊的配置工作。 典型示例 root package结构：com.example.myproject 应用主类Application.java置于root package下，通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web | +- CustomerController.java | 创建： 项目结构： 工程构建在上述基础，构建项目：1234567891011121314151617181920212223242526272829Customer.javapackage com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Customer &#123; @Value("$&#123;com.example.myproject.customer.id&#125;") private String id; @Value("$&#123;com.example.myproject.customer.name&#125;") private String name; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920CustomerService.javapackage com.example.myproject.service;import com.example.myproject.domain.Customer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class CustomerService &#123; @Autowired private Customer customer; public void printCustomer() &#123; System.out.println(customer.getName()); &#125; public Customer getCustomer()&#123; return customer; &#125;&#125; 1234567891011121314151617181920212223242526CustomerController.javapackage com.example.myproject.web;import com.example.myproject.domain.Customer;import com.example.myproject.service.CustomerService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;/** * @author 34924 */@Controllerpublic class CustomerController &#123; @Autowired CustomerService customerService; @RequestMapping("/customer") public String customer(ModelMap map) &#123; Customer customer = customerService.getCustomer(); map.addAttribute("customer", customer); return "index"; &#125;&#125; 123456789101112index.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;customer.id&#125;"&gt;Hello World&lt;/h1&gt;&lt;h2 th:text="$&#123;customer.name&#125;"&gt;name&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234application.propertiescom.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 运行项目，访问localhost:8080/customer 也可以test：1234567891011121314151617181920212223242526272829MyprojectApplicationTests.javapackage com.example.myproject;import com.example.myproject.service.CustomerService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class MyprojectApplicationTests &#123; @Autowired private CustomerService customerService; @Test public void contextLoads() &#123; &#125; @Test public void testCustomer() &#123; customerService.printCustomer(); System.out.println(customerService.getCustomer()); &#125;&#125; 输出：12jlCustomer&#123;id='001', name='jl'&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>工程</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot开发web应用]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_thymeleaf_demo 静态资源访问js,css,图片等文件，放在main/resources/static里。 页面放在main/resources/templates里。 配置文件内容可以添加在main/resources、application.properties里。 举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/D.jpg。如能显示图片，配置成功。 springboot提供默认配置的一些模版： Thymeleaf FreeMarker Velocity Groovy Mustache 使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。 Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。 示例：1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text="#&#123;msgs.headers.name&#125;"&gt;Name&lt;/td&gt; &lt;th th:text="#&#123;msgs.headers.price&#125;"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="prod : $&#123;allProducts&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Oranges&lt;/td&gt; &lt;td th:text="$&#123;#numbers.formatDecimal(prod.price,1,2)&#125;"&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。12345678910111213141516171819202122232425262728package com.example.demo.web;import com.example.demo.properties.BlobProperties;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;@Controllerpublic class HelloController &#123; @Resource(name = "blobProperties") private BlobProperties blobProperties; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125; @RequestMapping("/") public String index(ModelMap map) &#123; // 加入一个属性，用来在模板中读取 map.addAttribute("host", "http://www.baidu.com"); // return模板文件的名称，对应src/main/resources/templates/index.html return "index"; &#125;&#125; index.html页面：12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;host&#125;"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://blog.baidu.com，做到了不破坏HTML自身内容的数据逻辑分离。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 12345678910111213141516171819# Enable template caching.spring.thymeleaf.cache=true# Check that the templates location exists.spring.thymeleaf.check-template-location=true# Content-Type value.spring.thymeleaf.servlet.content-type=text/html# Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true# Template encoding.spring.thymeleaf.encoding=utf-8# Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names=# Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5# Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/# Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html#spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot热启动]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E7%83%AD%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在pom.xml中的dependencies中添加：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 改build： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 之后reimport，成功之后进行如下设置： 打开idea ，File-&gt;Settings-&gt; Build-Execution-Deployment -&gt; Compiler勾选 Build Project Automatically. 之后按 Shift+Ctrl+A 将看到弹窗 Enter Action or option name，输入”registry”，双击第一项”Registry…” ，会弹出另一个窗口，寻找compiler.automake.allow.when.app.running并且勾选： 之后重启项目，在修改resources文件和java文件时会自动加载或者重启。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：hello world]]></title>
    <url>%2F2018%2F11%2F19%2Fspringboot%EF%BC%9Ahello-world%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_helloworld.git Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 快速入门主要目标是完成Spring Boot基础项目的构建，并且实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 使用Maven构建项目 通过SPRING INITIALIZR工具产生基础项目 访问：http://start.spring.io/ 选择构建工具Maven Project、Spring Boot版本1.3.2以及一些工程基本信息，可参考下图所示点击Generate Project下载项目压缩包 解压项目包，并用IDE以Maven项目导入 菜单中选择File–&gt;New–&gt;Project from Existing Sources 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 选择Java SDK的时候请选择Java 7以上的版本 项目结构 通过上面步骤完成了基础项目的创建，如上图所示，Spring Boot的基础结构共三个文件（具体路径根据用户生成项目时填写的Group所有差异）： src/main/java下的程序入口：Chapter1Application src/main/resources下的配置文件：application.properties src/test/下的测试入口：Chapter1ApplicationTests 生成的Chapter1Application和Chapter1ApplicationTests类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。 其中，@SpringBootApplication的这个注解是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 引入Web模块引入Web模块，需在pom.xml中添加spring-boot-starter-web模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写HelloWorld服务 创建package命名为com.example.demo.web（根据实际情况修改） 创建HelloController类，内容如下 123456789101112package com.exmaple.demo.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 启动主程序（可以在命令行中使用mvn spring-boot:run，或者通过idea启动），打开浏览器访问http://localhost:8080/hello，可以看到页面输出Hello World 编写单元测试用例打开的src/test/下的测试入口Chapter1ApplicationTests类。下面编写一个简单的单元测试来模拟http请求，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.exmaple.demo;import com.exmaple.demo.web.HelloController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.hamcrest.Matchers.equalTo;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)@WebAppConfigurationpublic class Chapter1ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 使用MockServletContext来构建一个空的WebApplicationContext，这样我们创建的HelloController就可以在@Before函数中创建并传递到MockMvcBuilders.standaloneSetup（）函数中。 其中的SpringBootTest注解，原来为SpringApplicationConfiguration，现在已弃用。如果在判断equalTo时判断不一致，会报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243java.lang.AssertionError: Response contentExpected: "Hello World1" but: was "Hello World"Expected :Hello World1Actual :Hello World &lt;Click to see difference&gt; at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) at org.springframework.test.web.servlet.result.ContentResultMatchers.lambda$string$3(ContentResultMatchers.java:130) at org.springframework.test.web.servlet.MockMvc$1.andExpect(MockMvc.java:195) at com.exmaple.demo.Chapter1ApplicationTests.getHello(Chapter1ApplicationTests.java:36) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 打包在 POM 文件添加插件： 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 当运行“mvn package”进行打包时，会打包成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行。 开箱即用模块Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。下面列举一些常用的模块。 spring-boot-starter-logging ：使用 Spring Boot 默认的日志框架 Logback。 spring-boot-starter-log4j ：添加 Log4j 的支持。 spring-boot-starter-web ：支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 spring-boot-starter-tomcat ：使用 Spring Boot 默认的 Tomcat 作为应用服务器。 spring-boot-starter-jetty ：使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-test ：包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-aop ：包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 spring-boot-starter-security ：包含 spring-security。 spring-boot-starter-jdbc ：支持使用 JDBC 访问数据库。 spring-boot-starter-redis ：支持使用 Redis。 spring-boot-starter-data-mongodb ：包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-jpa ：包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-amqp ：通过 spring-rabbit 支持 AMQP。 spring-boot-starter-actuator ： 添加适用于生产环境的功能，如性能指标和监测等功能。 Java Config 自动配置Spring Boot 推荐采用基于 Java Config 的配置方式，而不是传统的 XML。例如，@Configuration、@Bean、@EnableAutoConfiguration、@CompomentScan、@PropertySource、@Repository、@Service、@RestController等。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库处理tips]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86tips%2F</url>
    <content type="text"><![CDATA[1.mysql 开放，关闭 远程授权默认安装mysql是关闭远程连接的 这样也有助于系统的安全 但是有时候需要开启下远程连接方便操作 开启连接 mysql -uroot -p 进入mysql 输入密码1GRANT ALL PRIVILEGES ON * . * TO ‘root’@&apos;%’ IDENTIFIED BY ‘你的mysql密码’ 1WITH GRANT OPTION MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 1MAX_UPDATES_PER_HOUR 0 ; 1flush privileges; 输入这两个命令即可开启mysql远程连接 关闭授权1234REVOKE ALL PRIVILEGES ON *.* FROM root@”%”;USE mysql;DELETE FROM user WHERE User=”root” and Host=”%”;FLUSH PRIVILEGES; 1234567891011121314151617mysql&gt; DELETE FROM `user` WHERE Host='10.155.123.55' AND User='kaka';Query OK, 1 row affected (0.00 sec) mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT Host,User,Password FROM `user`;+----------------+------+-------------------------------------------+| Host | User | Password |+----------------+------+-------------------------------------------+| localhost | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || tony\_ts\_tian | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || 127.0.0.1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || ::1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || % | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 |+----------------+------+-------------------------------------------+5 rows in set (0.00 sec) 2.删除重复数据，只留下唯一不重复1.先多建立一列 temp，用来合并meetingId和speakerId,用“-”连接，之后就判断这一列是否相同。1234567891011121314151617ALTER TABLE cekasp_meeting_speaker ADD temp VARCHAR(20) NULL;update cekasp_meeting_speaker set temp = concat(meetingId, '-', speakerId);delete from cekasp_meeting_speaker where temp in (SELECT * from (SELECT b.temp from cekasp_meeting_speaker b GROUP BY b.temp HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg);ALTER TABLE cekasp_meeting_speaker DROP temp;``` 2.或者直接以meetingId和speakerId作为查询```sqldelete from cekasp_meeting_speaker where (meetingId,speakerId) in (SELECT * from (SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg); 问题：delete/update里，有in的查询语句时，要使用临时表才能进行删除： 原本的1SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1 应该要使用1select * from ... as NAME 包起来，作为一个临时表。 3.两张表表结构一样，将一张表中数据插入另一张表1insert into table1 (SELECT * from table2 WHERE id not in (SELECT id from table1)) 4.查询某张表的信息1select * from information_schema.COLUMNS where TABLE_SCHEMA = (select database()) and TABLE_NAME="paper";]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis简单测试]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[0.准备工具因为配置文件都是读取相同的，所以可以进行工厂类封装。 12345678910111213141516171819202122232425262728package org.fkit.factory;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;public class FKSqlSessionFactory &#123; private static SqlSessionFactory sqlSessionFactory = null; static &#123; try &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125; public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125;&#125; 1.简单的select，insert，update，delete测试在UserMapper.xml中配置：1234567891011121314&lt;insert id="saveUser" parameterType="user" useGeneratedKeys="true"&gt; INSERT INTO tb_user(name, sex, age) VALUES (#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;select id="selectUser" parameterType="int" resultType="user"&gt; SELECT * from tb_user where id = #&#123;id&#125;&lt;/select&gt;&lt;update id="modifyUser" parameterType="user" &gt; UPDATE tb_user set name = #&#123;name&#125;, sex = #&#123;sex&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;&lt;/update&gt;&lt;delete id="removeUser" parameterType="int"&gt; DELETE from tb_user where id=#&#123;id&#125;&lt;/delete&gt; 注：均包含在中。 可以看到，在saveUser和modifyUser中，都是传入的User对象，而在selectUser和removeUser传入的是int值，所以在测试时，需要进行对应。resultType是返回类型，返回User类型，需要使用User user = …获取到该对象，默认返回的是int类型（好像是。。忘记了）。 分别对其进行测试及结果：123456789101112131415//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("jack", "男", 22); sqlSession.insert("org.fkit.mapper.UserMapper.saveUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: INSERT INTO tb_user(name, sex, age) VALUES (?,?,?) DEBUG [main] - ==&gt; Parameters: jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213141516//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); System.out.println(user.getName()); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=1, name='hello?', sex='g', age=11&#125; 12345678910111213141516171819//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); user.setName("hello?"); sqlSession.update("org.fkit.mapper.UserMapper.modifyUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: UPDATE tb_user set name = ?, sex = ?, age = ? WHERE id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), g(String), 11(Integer), 1(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); sqlSession.selectOne("org.fkit.mapper.UserMapper.removeUser", 3); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: DELETE from tb_user where id=? DEBUG [main] - ==&gt; Parameters: 3(Integer) 2.测试ResultMapsresultMap是mybatis中最重要最强大的元素，它的作用是告诉mybatis将从结果集中取出的数据转化成开发者所需要的对象。123456&lt;select id="selectUsersToMap" resultType="map"&gt; SELECT * from tb_user&lt;/select&gt;&lt;select id="selectUsers" resultType="org.fkit.domain.User"&gt; SELECT * from tb_user&lt;/select&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//SelectMapTest.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.User;import org.fkit.factory.FKSqlSessionFactory;import java.util.List;import java.util.Map;public class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取map对象集，每个user映射为一个map List&lt;Map&lt;String, Object&gt;&gt; list = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsersToMap"); for (Map&lt;String, Object&gt; row : list) &#123; System.out.println(row); &#125;// 获取user对象集 List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers"); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12&#123;sex=g, name=hello?, id=1, age=11&#125;&#123;sex=男, name=gg, id=4, age=26&#125;&#123;sex=男, name=gg, id=5, age=26&#125;&#123;sex=男, name=gg, id=6, age=26&#125;&#123;sex=男, name=gg, id=7, age=26&#125;&#123;sex=男, name=gg, id=8, age=26&#125;&#123;sex=男, name=gg, id=9, age=26&#125;&#123;sex=男, name=gg, id=10, age=26&#125;&#123;sex=男, name=gg, id=11, age=26&#125;&#123;sex=男, name=gg, id=12, age=26&#125;&#123;sex=男, name=jack, id=13, age=22&#125;&#123;sex=男, name=jack, id=14, age=22&#125;DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='gg', sex='男', age=26&#125;User&#123;id=13, name='jack', sex='男', age=22&#125;User&#123;id=14, name='jack', sex='男', age=22&#125; 查询语句返回的每一条数据都被封装成了一个Map集合，列名作为Map集合的key，而列的值作为Map的value。 虽然数据被封装成Map集合返回，但是Map集合并不能很好描述一个领域的模型，如果像后一个测试一样，使用POJO类来作为领域模型描述数据，会更加准确。 比较特殊的情况：查询到的数据的列和需要返回的对象（User）的属性不一致，则mybatis不会自动赋值，可以使用resultMap进行处理。 在数据库中创建一个tb_user2表，并且插入一定数据：12345678CREATE TABLE tb_user2( user_id INT AUTO_INCREMENT PRIMARY KEY, user_name VARCHAR(18) NULL, user_sex CHAR(2) NULL, user_age INT NULL) User映射表使用原来的User.java。在UserMapper.xml中添加：12345678910&lt;resultMap id="userResultMap" type="org.fkit.domain.User"&gt; &lt;id property="id" column="user_id"/&gt; &lt;!--column对应数据库中的属性--&gt; &lt;result property="name" column="user_name"/&gt; &lt;result property="sex" column="user_sex"/&gt; &lt;result property="age" column="user_age"/&gt;&lt;/resultMap&gt;&lt;select id="selectUsers2" resultMap="userResultMap"&gt; SELECT * from tb_user2&lt;/select&gt; 测试：1234567891011121314151617//ResultMapTest.javapublic class ResultMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers2"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user2 DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 2User&#123;id=1, name='qq1', sex='q', age=12&#125;User&#123;id=2, name='qq2', sex='b', age=13&#125; （待补充 3.多表查询两个表：123456789101112131415161718192021CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id)) 插入2个班级，4个学生，其中每2个学生对应一个班级。建立pojo类：1234567891011121314public class Clazz &#123; private Integer id; private String code; //setter,getter&#125;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz; //getter,setter UserMapper.xml映射：123456789101112&lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" column="clazz_id" javaType="org.fkit.domain.Clazz" select="selectClazzWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectClazzWithId" resultType="org.fkit.domain.Clazz"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125;&lt;/select&gt; 测试：123456789101112131415161718192021222324252627//SelectStudentTest.javapublic class SelectStudentTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Student&gt; students = sqlSession.selectList("org.fkit.mapper.UserMapper.selectStudent"); for (Student student : students) &#123; System.out.println(student); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_student DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - &lt;== Total: 4Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125; 查询每个班级的学生： 修改clazz.java1234567891011121314public class Clazz &#123; private Integer id; private String code; private List&lt;Student&gt; students; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125;...&#125; UserMapper.xml添加：12345678910111213&lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="selectStudentWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectStudentWithId" resultType="org.fkit.domain.Student"&gt; SELECT * FROM tb_student where clazz_id = #&#123;id&#125;&lt;/select&gt;&lt;select id="selectClazz" resultMap="clazzResultMap"&gt; SELECT * from tb_clazz&lt;/select&gt; 测试：123456789101112131415161718192021222324252627282930313233//SelectClazzTest.javapublic class SelectClazzTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Clazz&gt; clazzes = sqlSession.selectList("org.fkit.mapper.UserMapper.selectClazz"); for (Clazz clazz : clazzes) &#123; System.out.println(clazz); List&lt;Student&gt; students = clazz.getStudents(); for (Student student : students) &#123; System.out.println(student); &#125; &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_clazz DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - &lt;== Total: 2Clazz&#123;id=1, code='j1601'&#125;Student&#123;id=1, name='jack', sex='男', age=22, clazz=null&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=null&#125;Clazz&#123;id=2, code='j1602'&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=null&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=null&#125; 看到student没有clazz属性，应该是不能递归查询。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748CREATE TABLE tb_article( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, price DOUBLE NULL, remark VARCHAR(18) NULL, CONSTRAINT tb_article_id_uindex UNIQUE (id))CREATE TABLE tb_consumer( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(18) NULL, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, phone VARCHAR(18) NULL, address VARCHAR(18) NULL, CONSTRAINT tb_consumer_id_uindex UNIQUE (id))CREATE TABLE tb_order( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(32) NULL, total DOUBLE NULL, user_id INT NULL, CONSTRAINT tb_order_id_uindex UNIQUE (id), CONSTRAINT tb_order_tb_consumer_id_fk FOREIGN KEY (user_id) REFERENCES tb_consumer (id)) ENGINE = InnoDB;CREATE INDEX tb_order_tb_consumer_id_fk ON tb_order (user_id);CREATE TABLE tb_item( order_id INT NOT NULL, amount INT NULL, code VARCHAR(18) NULL, article_id INT NOT NULL, PRIMARY KEY (order_id, article_id)) ENGINE = InnoDB; 其中，consumer和order是一对多关系，一个顾客有多个订单；order和article是多对多的关系，中间表是item，一个订单可以有多个商品，一个商品也可以在多个订单上，所以是多对多关系。POJO类：123456789101112131415161718192021222324252627282930313233//TbConsumer.javapublic class TbConsumer &#123; private long id; private String username; private String loginname; private String password; private String phone; private String address; private List&lt;TbOrder&gt; tbOrders;//setter,getter//TbOrder.javapublic class TbOrder &#123; private long id; private String code; private double total; private long userId; private TbConsumer tbConsumer; private List&lt;TbArticle&gt; articleList;//setter,getter//TbArticle.javapublic class TbArticle &#123; private long id; private String name; private double price; private String remark; private List&lt;TbOrder&gt; tbOrders;//getter,setter 1.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//ConsumerMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ConsumerMapper"&gt; &lt;resultMap id="consumerResultMap" type="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="loginname" column="loginname"/&gt; &lt;result property="password" column="password"/&gt; &lt;result property="phone" column="phone"/&gt; &lt;result property="address" column="address"/&gt; &lt;collection property="tbOrders" javaType="arrayList" column="id" ofType="org.fkit.domain.TbOrder" fetchType="lazy" select="org.fkit.mapper.OrderMapper.selectOrderByConsumerId"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="total" column="total"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectConsumerById" parameterType="int" resultMap="consumerResultMap"&gt; SELECT * from tb_consumer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;//OrderMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.OrderMapper"&gt; &lt;resultMap id="orderResultMap" type="org.fkit.domain.TbOrder"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="total" property="total"/&gt; &lt;result column="code" property="code"/&gt; &lt;association property="tbConsumer" javaType="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="loginname" property="loginname"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;/association&gt; &lt;collection property="articleList" javaType="ArrayList" column="oid" ofType="org.fkit.domain.TbArticle" select="org.fkit.mapper.ArticleMapper.selectArticleByOrderId" fetchType="lazy"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="price" property="price"/&gt; &lt;result property="remark" column="remark"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectOrderById" resultMap="orderResultMap" parameterType="int"&gt; SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectOrderByConsumerId" parameterType="int" resultType="org.fkit.domain.TbOrder"&gt; select * from tb_order where user_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt;//ArticleMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ArticleMapper"&gt; &lt;select id="selectArticleByOrderId" parameterType="int" resultType="org.fkit.domain.TbArticle"&gt; SELECT * from tb_article where id in (select article_id from tb_item where order_id = #&#123;id&#125;) &lt;/select&gt;&lt;/mapper&gt; 因为多表查询返回结果中tb_consumer中有id列，tb_order中也有id列，所以需要区分，例如使o.id as oid，resultMap中的column=”oid”就是指tb_order表中的id值。 相应Java类：12345678910111213public interface ConsumerMapper &#123; TbConsumer selectConsumerById(Integer id);&#125;public interface OrderMapper &#123; TbOrder selectOrderById(Integer id); TbOrder selectOrderByUserId(Integer id);&#125;public interface ArticleMapper &#123; TbArticle selectArticleByOrderId(Integer id);&#125; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ManyToManyTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); ManyToManyTest manyToManyTest = new ManyToManyTest(); manyToManyTest.testSelectUserById(sqlSession); manyToManyTest.testSelectOrderById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectUserById(SqlSession sqlSession) &#123; ConsumerMapper consumerMapper = sqlSession.getMapper(ConsumerMapper.class); TbConsumer tbConsumer = consumerMapper.selectConsumerById(1); System.out.println(tbConsumer); List&lt;TbOrder&gt; tbOrders = tbConsumer.getTbOrders(); for (TbOrder tbOrder : tbOrders) &#123; System.out.println(tbOrder); &#125; &#125; public void testSelectOrderById(SqlSession sqlSession) &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); TbOrder tbOrder = orderMapper.selectOrderById(2); System.out.println(tbOrder); TbConsumer tbConsumer = tbOrder.getTbConsumer(); System.out.println(tbConsumer); List&lt;TbArticle&gt; tbArticles = tbOrder.getArticleList(); for (TbArticle tbArticle : tbArticles) &#123; System.out.println("tbArticle:"); System.out.println(tbArticle); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_consumer where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select * from tb_order where user_id = ?; DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=[TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;, TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;]&#125;TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;DEBUG [main] - ==&gt; Preparing: SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: SELECT * from tb_article where id in (select article_id from tb_item where order_id = ?) DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 2TbOrder&#123;id=1, code='23624', total=1.0, userId=0, tbConsumer=TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;&#125;TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;tbArticle:TbArticle&#123;id=1, name='洗发水', price=23.3, remark='bilibili', tbOrders=null&#125;tbArticle:TbArticle&#123;id=2, name='java书', price=111.0, remark='blingbling', tbOrders=null&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, name VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id))CREATE INDEX TB_STUDENT_tb_clazz_id_fk ON tb_student (clazz_id); 一个clazz对应多个student。 log4j.properties需要进行配置：1234567log4j.rootLogger=ERROR, stdout#log4j.logger.org.fkit.mapper.UserMapper=DEBUGlog4j.logger.org.fkit.mapper=DEBUGlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 在mybatis-config.xml中配置一下mapper和懒加载：12&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt; 配置pojo类：12345678910111213141516171819202122//Student.javapackage org.fkit.domain;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz;//getter,setter//Clazz.javapackage org.fkit.domain;import java.util.List;public class Clazz &#123; private Integer id; private String code; private String name; private List&lt;Student&gt; students;//getter,setter 1.配置StudentMapper和ClazzMapper1234567891011121314151617181920212223242526//StudentMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.StudentMapper"&gt; &lt;select id="selectStudentById" parameterType="int" resultMap="studentResultMap"&gt; SELECT * from tb_clazz c,tb_student s where c.id = s.clazz_id and s.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectStudentByClazzId" parameterType="int" resultMap="studentResultMap"&gt; select * from tb_student where clazz_id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" javaType="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678910//StudentMapper.javapackage org.fkit.mapper;import org.fkit.domain.Student;public interface StudentMapper &#123; Student selectStudentById(Integer id); Student selectStudentByClazzId(Integer id);&#125; 1234567891011121314151617181920212223//ClazzMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ClazzMapper"&gt; &lt;select id="selectClazzById" parameterType="int" resultMap="clazzResultMap"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="org.fkit.mapper.StudentMapper.selectStudentByClazzId" fetchType="lazy"&gt; &lt;id property="studentId" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678//ClazzMapper.javapackage org.fkit.mapper;import org.fkit.domain.Clazz;public interface ClazzMapper &#123; Clazz selectClazzById(Integer id);&#125; 测试代码：1234567891011121314151617181920212223242526272829303132333435363738//OneToMany.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.Clazz;import org.fkit.factory.FKSqlSessionFactory;import org.fkit.mapper.ClazzMapper;public class OneToMany &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); OneToMany oneToMany = new OneToMany(); oneToMany.testSelectClazzById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectClazzById(SqlSession sqlSession) &#123; ClazzMapper clazzMapper = sqlSession.getMapper(ClazzMapper.class); Clazz clazz = clazzMapper.selectClazzById(1); System.out.println(clazz.getId() + " " + clazz.getCode()); System.out.println(clazz.getStudents()); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 11 j1601DEBUG [main] - ==&gt; Preparing: select * from tb_student where clazz_id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2[Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='null', name='jack', students=null&#125;&#125;, Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=2, code='null', name='rose', students=null&#125;&#125;] 可以看出，懒加载会只加载需要使用的(PS:如果做接口，json传数据，则冷加载相当于失效，但是可以在pojo类上加上@JsonIgnoreProperties(“fieldname”)）。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对一]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_card( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(18) NULL, CONSTRAINT tb_card_id_uindex UNIQUE (id))CREATE TABLE tb_person( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, sex VARCHAR(18) NULL, age INT NULL, card_id INT NULL, CONSTRAINT tb_person_id_uindex UNIQUE (id), CONSTRAINT tb_person_card_id_uindex UNIQUE (card_id), CONSTRAINT tb_person_tb_card_id_fk FOREIGN KEY (card_id) REFERENCES tb_card (id)) ENGINE = Inno 身份证和人是一对一的关系，在tb_person表中，card_id为外键，对应tb_card主键，且card_id唯一，就满足了一对一的关系。 2.POJO类 两个pojo类： 12345public class Card implements Serializable&#123; private Integer id; private String code; //getter，setter 12345678public class Person implements Serializable&#123; private Integer id; private String name; private String sex; private Integer age; private Card card; //getter,setter 3.mapper和mybatis-config.xml配置mapper配置：12345678//CardMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.CardMapper"&gt; &lt;select id="selectCardById" parameterType="int" resultType="org.fkit.domain.Card"&gt; SELECT * FROM tb_card WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617//PersonMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.PersonMapper"&gt; &lt;select id="selectPersonById" parameterType="int" resultMap="personMapper"&gt; select * from tb_person where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="personMapper" type="org.fkit.domain.Person"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="card" column="card_id" select="org.fkit.mapper.CardMapper.selectCardById" javaType="org.fkit.domain.Card"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在此可以给PersonMapper设置一个接口：123456789101112//PersonMapper.javapackage org.fkit.mapper;import org.fkit.domain.Person;public interface PersonMapper &#123; /** * @param id * @return Person */ Person selectPersonById(Integer id);&#125; 在mybatis-config.xml中配置这2个mapper：12&lt;mapper resource="org/fkit/mapper/PersonMapper.xml"/&gt;&lt;mapper resource="org/fkit/mapper/CardMapper.xml"/&gt; 4.测试测试代码：12345678910//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); Person person = sqlSession.selectOne("org.fkit.mapper.PersonMapper.selectPersonById", 1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125; 因为设置了接口，也可以如此测试：123456789101112131415//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); PersonMapper personMapper = session.getMapper(PersonMapper.class); Person person = personMapper.selectPersonById(1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册登录测试]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.domain2.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping("/user")public class UserController &#123; private static List&lt;User&gt; userList; public UserController() &#123; super(); userList = new ArrayList&lt;User&gt;(); &#125; private static Log logger = LogFactory.getLog(UserController.class); @RequestMapping(value = "/register", method = RequestMethod.GET) public String requireForm() &#123; logger.info("register GET被调用"); System.out.println("register GET被调用"); return "registerForm"; &#125; @RequestMapping(value = "/register", method = RequestMethod.POST) public String register( @RequestParam("loginname") String loginname, @RequestParam("password") String password, @RequestParam("username") String username) &#123; logger.info("register POST被调用"); System.out.println("register POST被调用"); User user = new User(); user.setLoginname(loginname); user.setUsername(username); user.setPassword(password); userList.add(user); System.out.println(userList); return "loginForm"; &#125; @RequestMapping("/login") public String login( @RequestParam("loginname") String loginname, @RequestParam("password") String password, Model model)&#123; logger.info("登录名" + loginname + " 密码" + password); for (User user : userList) &#123; if (user.getLoginname().equals(loginname) &amp;&amp; user.getPassword().equals(password)) &#123; model.addAttribute("user", user); return "welcome"; &#125; &#125; return "loginForm"; &#125;&#125; springmvc-config2.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean name="/hello" class="org.fkit.controller.HelloController"/&gt;--&gt; &lt;context:component-scan base-package="org.fkit.controller"/&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;value&gt;/WEB-INF/content/&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-config2.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathVariable，RequestHeader，CookieValue注解测试]]></title>
    <url>%2F2018%2F11%2F14%2FPathVariable%EF%BC%8CRequestHeader%EF%BC%8CCookieValue%E6%B3%A8%E8%A7%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DataBindingController &#123; private static final Log logger = LogFactory.getLog(DataBindingController.class); @RequestMapping(value = "/pathVariableTest/&#123;userId&#125;") public void pathVariableTest(@PathVariable Integer userId) &#123; logger.info("通过@PathVariable获得的数据：" + userId); &#125; @RequestMapping(value = "/requestHeaderTest") public void requestHeaderTest( @RequestHeader("User-Agent") String userAgent, @RequestHeader(value = "Accept") String[] accepts) &#123; logger.info("通过@requestHeaderTest获得的数据:" + userAgent); for (String accept : accepts) &#123; logger.info(accept); &#125; &#125; @RequestMapping(value = "/cookieValueTest") public void cookieValueTest( @CookieValue(value = "JSESSIONID", defaultValue = "") String sessionId) &#123; logger.info("通过@CookieValue获得的数据：" + sessionId); &#125; @RequestMapping(value = "/testWebsite") public String testWebsite()&#123; return "index"; &#125;&#125; jsp:1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: 34924 Date: 2018/8/1 Time: 22:40 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/pathVariableTest/1"&gt;测试注解1&lt;/a&gt;&lt;br&gt;&lt;a href="/requestHeaderTest"&gt;注解2&lt;/a&gt;&lt;br&gt;&lt;a href="/cookieValueTest"&gt;注解3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4.properties配置]]></title>
    <url>%2F2018%2F11%2F14%2Flog4-properties%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[放在WEB-INF的目录下：123456789101112131415161718192021222324# Logging levelsolr.log=$&#123;solr.solr.home&#125;/../logslog4j.rootLogger=INFO, filelog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%-4r [%t] %-5p %c %x \u2013 %m%n#- size rotation with log cleanup.log4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.MaxFileSize=4MBlog4j.appender.file.MaxBackupIndex=9#- File to log to and log formatlog4j.appender.file.File=$&#123;solr.log&#125;/solr.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%-5p - %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;; %C; %m\nlog4j.logger.org.apache.zookeeper=WARNlog4j.logger.org.apache.hadoop=WARN# set to INFO to enable infostream log messageslog4j.logger.org.apache.solr.update.LoggingInfoStream=OFF 在web.xml中配置：12345678910&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <categories>
        <category>日志配置</category>
      </categories>
      <tags>
        <tag>日志配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的router路由跳转获取url参数方法]]></title>
    <url>%2F2018%2F11%2F14%2Freact%E7%9A%84route%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[例如一个页面分为三块，导航栏，左栏右栏，左栏为页面跳转，右栏为显示list页面或者detail页面，如下所示： 如果使用如下代码进行路由，url改变了，但是接收不到：12345678910&lt;div className='content-right'&gt; &lt;Layout.Content &gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path='/development/list' component=&#123;Com_dev_list&#125; /&gt; &lt;Route path="/development/list:type" component=&#123;Com_dev_list&#125; /&gt; &lt;Route path='/development/detail:id' component=&#123;Com_dev_detail&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Layout.Content&gt; 使用component接收：12345678910componentWillReceiveProps(nextProps)&#123; axios.get(host + 'development/list/' + nextProps.match.params.type.replace(":type=","") +'/' +1).then( response =&gt; &#123; let items = response.data; items = items.list; this.setState(&#123;list:items&#125;); window.scrollTo(0, 0) &#125; );&#125; 实际上nextProps.match.params.type.replace(“:type=”,””)并未接收到url每次的改变，需要使用window.location.href，这样每次都可以接收到。但是是否真的这么暴力美学，还需要进行之后的学习。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解写法]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E6%B3%A8%E8%A7%A3%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.普通增删改查使用表：User在mybatis-config.xml里配置1&lt;mapper class="org.fkit.mapper.UserMapper"/&gt; 注释掉原来的xml配置路径。注解java类：123456789101112131415161718192021222324252627282930313233//UserMapper.javapackage org.fkit.mapper;import org.apache.ibatis.annotations.*;import org.fkit.domain.Clazz;import org.fkit.domain.User;import java.util.List;public interface UserMapper &#123; @Insert("insert into tb_user(name,sex,age) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)") @Options(useGeneratedKeys = true, keyProperty = "id") int saveUser(User user); @Delete("delete from tb_user where id = #&#123;id&#125; or name = #&#123;cctv&#125;") int removeUser(@Param("id") Integer id, @Param("cctv") String n); @Update("update tb_user set name = #&#123;name&#125;,sex = #&#123;sex&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;") void modifyUser(User user); @Select("select * from tb_user where id = #&#123;id&#125;") @Results(&#123; @Result(id = true, column = "id", property = "id"), @Result(column = "name", property = "name"), @Result(column = "sex", property = "sex"), @Result(column = "age", property = "age") &#125;) User selectUserById(Integer id); @Select("select * from tb_user") List&lt;User&gt; selectAllUser();&#125; 测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("1111jack", "男", 22); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.saveUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: insert into tb_user(name,sex,age) values(?,?,?) DEBUG [main] - ==&gt; Parameters: 1111jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.removeUser(16,"jack"); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: delete from tb_user where id = ? or name = ? DEBUG [main] - ==&gt; Parameters: 16(Integer), jack(String)DEBUG [main] - &lt;== Updates: 1//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); user.setName("hello?"); userMapper.modifyUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: update tb_user set name = ?,sex = ?, age = ? where id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), 男(String), 26(Integer), 12(Integer)DEBUG [main] - &lt;== Updates: 1//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); System.out.println(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=12, name='hello?', sex='男', age=26&#125;//SelectMapTest.javapublic class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取user对象集 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAllUser(); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 10User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='hello?', sex='男', age=26&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mabatis逆向工程]]></title>
    <url>%2F2018%2F11%2F13%2Fmabatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文使用idea编译器，安装Mybatisplus插件后可以使用逆向工程。 配置：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" &gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="C:/Users/34924/Desktop/mysql-connector-java-5.1.46.jar"/&gt; &lt;context id="context" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;property name="suppressDate" value="false"/&gt; &lt;/commentGenerator&gt; &lt;!--&lt;jdbcConnection userId="root" password="123456" driverClass="com.mysql.jdbc.Driver"--&gt; &lt;!--connectionURL="jdbc:mysql://localhost:3306/sss"/&gt;--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="org.model" targetProject="."&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="org.mapper" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="org.mapper" type="MIXEDMAPPER" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;table schema="sn349245467" tableName="polls_question" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;table schema="sn349245467" tableName="polls_choice" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注意：jdbc版本最好用5.x左右的，targetRuntime使用Mybatis3，使用简略版的会少东西。javaClientGenerator的type选用MIXEDMAPPER。 使用了逆向工程后，在一对多等关系的时候，需要把默认的查找方式由select param1,param2,…改为select *，以及改resultMap的BaseResultMap。]]></content>
      <categories>
        <category>java</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>java</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea创建maven项目时显示“Loading archetype list ”]]></title>
    <url>%2F2018%2F11%2F13%2Fidea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%98%BE%E7%A4%BA%E2%80%9CLoading%20archetype%20list%20%E2%80%9D%2F</url>
    <content type="text"><![CDATA[本文参考https://blog.csdn.net/u011403655/article/details/46843331 1.idea创建maven项目时一直显示“Loading archetype list ”删除{User_Home}/.IntelliJIdea{Version}/system/Maven/Indices下面的文件，然后重启idea。 2.IntelliJ IDEA 创建maven-archetype-webapp超时问题 File -&gt; Other Settings -&gt; Default Settings… Build, Execution, Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner, 在VM Options中填写如下 -DarchetypeCatalog=internal Apply -&gt; OK即可 3.创建完项目后命令行卡在 [INFO] Generating project in Batch modeMaven命令执行到Generating Project in Batch mode 卡住，原因是网络带宽不足，需要下载一个约4.1M的archetype-catalog.xml文件。 在maven的五分钟入门里面，有这样一个命令： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false这句话的命令是创建一个默认的项目，但我在执行这个命令时，命令行会停在 [INFO] Generating project in Batch mode这句话会停很久。【当然，也有人的一下就过去。】 增加一个-X参数，可以查看详细信息1mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -X 可以看到，程序停在了下面这一行。1[DEBUG] Searching for remote catalog: http://repo1.maven.org/maven2/archetype-catalog.xml 去查询这个文件的时候网络比较差或者其他原因，导致挂在那里。 解决方法很简单。 把上述地址复制到浏览器中，下载这个文件到本地。 把文件archetype-catalog.xml复制到目录.m2\repository\org\apache\maven\archetype\archetype-catalog\2.2下面。 在上述命令后增加参数-DarchetypeCatalog=local，变成读取本地文件即可。4.庆祝一下123456789101112131415161718192021[INFO] ----------------------------------------------------------------------------[INFO] Using following parameters for creating project from Archetype: maven-archetype-webapp:RELEASE[INFO] ----------------------------------------------------------------------------[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: packageInPathFormat, Value: com/ssm/study[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Project created from Archetype in dir: C:\Users\34924\AppData\Local\Temp\archetypetmp\ssmframe[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 16:09 min[INFO] Finished at: 2018-07-20T21:16:52+08:00[INFO] Final Memory: 12M/87M[INFO] ------------------------------------------------------------------------[INFO] Maven execution finished]]></content>
      <categories>
        <category>Maven</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态sql]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E7%9A%84%E5%8A%A8%E6%80%81sql%2F</url>
    <content type="text"><![CDATA[本文是关于mybatis的早期使用方法。 0.前期准备123456789101112131415CREATE TABLE tb_employee( id INT AUTO_INCREMENT PRIMARY KEY, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, name VARCHAR(18) NULL, sex CHAR(2) NULL, age INT NULL, phone VARCHAR(21) NULL, sal DOUBLE NULL, state VARCHAR(18) NULL, CONSTRAINT tb_employee_id_uindex UNIQUE (id)) POJO类：123456789101112public class TbEmployee &#123; private long id; private String loginname; private String password; private String name; private String sex; private long age; private String phone; private double sal; private String state;//getter,setter 1.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.EmployeeMapper"&gt; &lt;select id="selectEmployeeByIdLike" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee &lt;where&gt; &lt;if test="id != null"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeChoose" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee &lt;where&gt; &lt;choose&gt; &lt;when test="id != null"&gt; and id = #&#123;id&#125; &lt;/when&gt; &lt;when test="loginname != null and password != null"&gt; and loginname = #&#123;loginname&#125; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and sex = '1' &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeWithId" parameterType="int" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;update id="updateEmployeeIfNecessary" parameterType="org.fkit.domain.TbEmployee"&gt; UPDATE tb_employee &lt;set&gt; &lt;if test="loginname != null"&gt;loginname = #&#123;loginname&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="sex != null"&gt;sex = #&#123;sex&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;if test="phone != null"&gt;phone = #&#123;phone&#125;,&lt;/if&gt; &lt;if test="sal != null"&gt;sal = #&#123;sal&#125;,&lt;/if&gt; &lt;if test="state != null"&gt;state = #&#123;state&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id="selectEmployeeIn" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee where id in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;select id="selectEmployeeLikeName" resultType="org.fkit.domain.TbEmployee"&gt; &lt;bind name="pattern" value="'%' + _parameter.getName() + '%'"/&gt; &lt;bind name="pattern2" value="'%' + _parameter.getLoginname() +'%' "/&gt; SELECT * FROM tb_employee where name like #&#123;pattern&#125; and loginname like #&#123;pattern2&#125; &lt;/select&gt;&lt;/mapper&gt; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class DynamicSQLTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); DynamicSQLTest dynamicSQLTest = new DynamicSQLTest(); dynamicSQLTest.testSelectEmployeeByIdLike(sqlSession); dynamicSQLTest.testSelectEmployeeChoose(sqlSession); dynamicSQLTest.testUpdateEmployeeIfNecessary(sqlSession); dynamicSQLTest.testSelectEmployeeIn(sqlSession); dynamicSQLTest.testSelectEmployeeLikeName(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectEmployeeByIdLike(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("id", 1); params.put("sex", 1); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeByIdLike(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeChoose(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginname", "jack"); params.put("password", "123"); params.put("id", 2); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeChoose(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testUpdateEmployeeIfNecessary(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = employeeMapper.selectEmployeeWithId(1); System.out.println(tbEmployee); tbEmployee.setLoginname("newJack"); employeeMapper.updateEmployeeIfNecessary(tbEmployee); &#125; public void testSelectEmployeeIn(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); integers.add(1); integers.add(3); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeIn(integers); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeLikeName(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = new TbEmployee(); tbEmployee.setName("a"); tbEmployee.setLoginname("J"); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeLikeName(tbEmployee); tbEmployees.forEach(tbEmployee1 -&gt; System.out.println(tbEmployee1)); &#125;&#125; 12345678910111213141516171819202122232425//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee WHERE id = ? and sex = ? DEBUG [main] - ==&gt; Parameters: 1(Integer), 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: select * from tb_employee WHERE id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=2, loginname='rose', password='456', name='rooose', sex='2', age=21, phone='654321', sal=1121.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: UPDATE tb_employee SET loginname = ?, password = ?, name = ?, sex = ?, age = ?, phone = ?, sal = ?, state = ? where id = ? DEBUG [main] - ==&gt; Parameters: newJack(String), 123(String), jaccck(String), 1(String), 26(Long), 123456(String), 3211.0(Double), active(String), 1(Long)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - ==&gt; Preparing: select * from tb_employee where id in ( ? , ? ) DEBUG [main] - ==&gt; Parameters: 1(Integer), 3(Integer)DEBUG [main] - &lt;== Total: 2TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;TbEmployee&#123;id=3, loginname='tom', password='tom', name='tooom', sex='1', age=12, phone='132', sal=32.2, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where name like ? and loginname like ? DEBUG [main] - ==&gt; Parameters: %a%(String), %J%(String)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125; 使用like的另一种写法：123456789101112&lt;select id="getUsersByConditionIf" resultType="com.model.User" parameterType="com.model.User"&gt; select * from user where &lt;if test="id!=null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username !=''"&gt; or username like "%"#&#123;username&#125;"%" &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 使用”%”#{parameter}”%”，运行结果如下：1234567891011DEBUG [main] - ==&gt; Preparing: select id, username,birthday, sex, address,dept_id from user where id = ? DEBUG [main] - ==&gt; Parameters: 27(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select id, name from department where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;DEBUG [main] - ==&gt; Preparing: select * from user where id = ? or username like "%"?"%" and sex = ? DEBUG [main] - ==&gt; Parameters: 27(Integer), 1(String), 1(String)DEBUG [main] - &lt;== Total: 2[User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;, User&#123;id=32, username='11231', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;] 要使每个都写为and xxx= #{xx}的形式，而不是第一个需要去掉and，可以在sql前面的语句中写为1select * from xxx where 1=1 这样保证每个都可以写为and xxx = #{xx}的形式。 也可以使用where标签将所有拼接的动态条件放入。 但是where只能去掉第一个and。 一次更新多条数据：1void addUsers(@Param("userList") List&lt;User&gt; userList); 123456&lt;insert id="addUsers" &gt; insert into user(username,address) VALUES &lt;foreach collection="userList" item="user" separator=","&gt; (#&#123;user.username&#125;,#&#123;user.address&#125;) &lt;/foreach&gt;&lt;/insert&gt; 需要插入别的字段需要自己加入。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范数]]></title>
    <url>%2F2018%2F11%2F13%2F%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[p-范数: $||x||_p = (|x_1|^p + |x_2|^p + |x_3|^3 + … + |x_n|^p)^{1/p} =\sqrt[p]{ \sum_{i=1}^n|x_i|^p}$ 2-范数(欧式范数): $||x||_2 = (|x_1|^2 + |x_2|^2 + |x_3|^2 + … + |x_n|^2)^{1/2} = \sqrt{ \sum_{i=1}^n x_i^2}$ ∞-范数: $||x||_∞ = max(x_1,x_2,x_3,…,x_n) = max_i|x_i|$ 1-范数即向量元素绝对值之和； 2-范数为Euclid范数（欧几里得范数，常用计算向量长度），即向量元素绝对值的平方和再开方； ∞-范数即所有向量元素绝对值中的最大值； -∞-范数即所有向量元素绝对值中的最小值； p-范数即向量元素绝对值的p次方和的1/p次幂。 可以参考：https://blog.csdn.net/susanzhang1231/article/details/52127011 https://www.jianshu.com/p/bf860ad177dd https://blog.csdn.net/bitcarmanlee/article/details/51945271]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>范数</tag>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
</search>
