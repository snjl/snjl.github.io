<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react：页面中存在多个input设置value属性]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AAinput%E8%AE%BE%E7%BD%AEvalue%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[首先要为这些所有的input框绑定上onChange的方法，然后还需要在this.state中去设置不同的input对应不同的值，最后还需要在changeValue的方法中去一一监听input输入时去修改对应的input的值。 也可以写一个changeValue方法，但是input的属性的name要和state里的名字要一样，如下所示：12345678910constructor() &#123; super(); this.state = &#123; login:&#123; username:'', password:'' &#125;, user:&#123;&#125; &#125;&#125; 1234567用户名：&lt;input type=&#123;'text'&#125; name=&#123;'username'&#125; value=&#123;this.state.login.username&#125; className=&#123;'username'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt;&lt;br/&gt;密码：&lt;input type=&#123;'password'&#125; name=&#123;'password'&#125; value=&#123;this.state.login.password&#125; className=&#123;'password'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; 12345changeValue(event) &#123; let newLogin = this.state.login; newLogin[event.target.name] = event.target.value; this.setState(&#123;login: newLogin&#125;) &#125; 使用event.target.name获取input的name属性，使用evnet.target.value获取input的value，令newLogin为this.state.login，然后将newLogin中名为event.target.name的属性的值设为event.target.value，之后再setState，从而可以改变state.login的值。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session-1%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery禁止回车提交]]></title>
    <url>%2F2018%2F11%2F25%2FjQuery%E7%A6%81%E6%AD%A2%E5%9B%9E%E8%BD%A6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[在有input框进行输入提交时，如果有input的type为submit，则默认按回车会提交，可以用jQuery的方法进行阻拦：1234567891011$(function()&#123; $("input").each( function()&#123; $(this).keypress( function(e) &#123; var key = window.event ? e.keyCode : e.which; if(key.toString() === "13")&#123; return false; &#125; &#125;); &#125;);&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：form表单提交]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9Aform%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[由于React在浏览器显示的是虚拟的DOM，我们在表单输入值后直接提交，是无法获取到这个值的。对此，官方给出的解决办法是：先把输入的值存放在组件的状态（state）中，之后通过状态的改变更新页面内容，从而显示出正确的值，用户提交的也是从state里获取的表单的value。 1234567891011constructor() &#123; super(); this.state = &#123; item:&#123; name:'', organization:'', school:'', &#125;, &#125;&#125; 设置提交方法和改变state的状态的方法：1234567891011121314151617181920212223handleSubmit(event) &#123; //阻止表单默认提交 event.preventDefault(); let item = this.state.item; axios.post(host + 'xxx/insert', item).then( response =&gt; &#123; let message = response.data; if (message === 'success') &#123; alert("插入成功"); window.location.href = '/xxx/list'; &#125; else &#123; alert("插入失败，请重试"); &#125; &#125; ); this.setState(&#123;item:item&#125;)&#125;changeValue(event) &#123; let newItem = this.state.item; newItem[event.target.name] = event.target.value; this.setState(&#123;item: newItem&#125;)&#125; 123456789101112131415161718192021&lt;form method=&#123;'post'&#125; onSubmit=&#123;this.handleSubmit.bind(this)&#125;&gt; &lt;label&gt;申请数据集名称： &lt;input type="text" name=&#123;'name'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学校： &lt;input type="text" name=&#123;'organization'&#125; value=&#123;this.state.item.organization&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学院： &lt;input type="text" name=&#123;'school'&#125; value=&#123;this.state.item.school&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;input type=&#123;'submit'&#125; value=&#123;'提交'&#125;/&gt; &lt;input value=&#123;'重置'&#125; type=&#123;'reset'&#125;/&gt;&lt;/form&gt; 注：form中用onSubmit替代action，其中每个input的name需要对应定义state时的状态，在使用axios调接口传值时，如果是java的springmvc的后端，需要将传输的属性与对应的实体类对接好。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot报错记录]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured. Reason: Failed to determine a suitable driver class Action: Consider the following:​ If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.​ If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active). 原因：引入mybatis的jar包时： ​ org.mybatis.spring.boot​ mybatis-spring-boot-starter​ 1.3.1springboot会默认加载org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration这个类，而DataSourceAutoConfiguration类使用了@Configuration注解向spring注入了dataSource bean，又因为项目中并没有关于dataSource相关的配置信息，所以当spring创建dataSource bean时因缺少相关的信息就会报错。 解决办法： 在@SpringBootApplication注解上加上exclude，解除自动加载DataSourceAutoConfiguration。@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }在parent项目的pom.xml文件中保存所有子模块的共有jar依赖，非共有的依赖则在各模块自身的pom.xml文件中进行申明。建议采用此方法，好处在于各模块的依赖不会相互产生干扰。2.maven配置时，测试出现“’mvn’ 不是内部或外部命令,也不是可运行的程序”错误 配置maven。 在环境变量的PATH中配置maven的bin目录。 使用mvn package打包成功后显示日志： [INFO] BUILD SUCCESS[INFO] ————————————————————————[INFO] Total time: 46.791 s[INFO] Finished at: 2018-11-21T16:12:36+08:00[INFO] Final Memory: 35M/275M[INFO] ————————————————————————3.java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents…….. 具体错误： Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Tue May 15 21:38:04 CST 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61)​ at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71)​ at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76) at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862) at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:444) at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230) at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226) at java.sql.DriverManager.getConnection(Unknown Source) at java.sql.DriverManager.getConnection(Unknown Source) at zhu.jdbc.unit.UnitMysql.getConnection(UnitMysql.java:34) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:55) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1) at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87) at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)​ at java.lang.reflect.Constructor.newInstance(Unknown Source)​ at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:59)​ at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:83)​ at com.mysql.cj.util.TimeUtil.getCanonicalTimezone(TimeUtil.java:128)​ at com.mysql.cj.protocol.a.NativeProtocol.configureTimezone(NativeProtocol.java:2201)​ at com.mysql.cj.protocol.a.NativeProtocol.initServerSession(NativeProtocol.java:2225)​ at com.mysql.cj.jdbc.ConnectionImpl.initializePropsFromServer(ConnectionImpl.java:1391)​ at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:993)​ at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:852)​ … 36 more五月 15, 2018 9:38:04 下午 org.apache.catalina.core.StandardWrapperValve invoke严重: Servlet.service() for servlet [Servlet_TbUser] in context with path [/myweb2] threw exceptionjava.lang.NullPointerException​ at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:59)​ at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1)​ at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35)​ at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1)​ at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87)​ at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41)​ at javax.servlet.http.HttpServlet.service(HttpServlet.java:661)​ at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)​ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)​ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)​ at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)​ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)​ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)​ at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)​ at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)​ at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496)​ at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)​ at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)​ at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650)​ at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)​ at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)​ at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)​ at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)​ at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)​ at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)​ at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)​ at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)​ at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)​ at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) 出现这个的原因是因为 mysql返回的时间总是有问题，比实际时间要早8小时。 解决办法： 在jdbc连接的url后面加上serverTimezone=GMT即可解决问题，如果需要使用gmt+8时区，需要写成GMT%2B8。 为了防止因为日期为null报错，可以直接加上： ?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 例如链接数据库，可以写为： jdbc.url=jdbc:mysql://xxx.xxx.xxx.xxx/xxxxx?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 4.Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdbc.Driver. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 这个问题是 使用了新的mysql驱动包，但驱动声明不是最新的： DriverClassName 从 “com.mysql.jdbc.Driver” 换成 “com.mysql.cj.jdbc.Driver” 即可。 5.spring Failed to convert property value of type ‘java.lang.String’ to required type ‘int’ for property 原错误是不能将long的null属性转化出来，但是没找到原来的错误。采取的方式是，把pojo类中的long全改为Integer。 如果是date出错，参考问题3，在数据库连接时加上zeroDateTimeBehavior=convertToNull。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用JdbcTemplate]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E4%BD%BF%E7%94%A8JdbcTemplate%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mysql.git 环境配置修改 POM 文件，添加spring-boot-starter-jdbc依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 添加mysql依赖（spring-boot-starter-jdbc 默认使用tomcat-jdbc数据源，如果要使用其他数据源，需要添加额外的依赖，这里使用了阿里巴巴的数据池管理）： 12345678&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt; 数据源配置在src/main/resources/application.properties中配置数据源信息:1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/sss?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=123456 在Application.java中配置：123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootApplicationpublic class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125; @Autowired private Environment environment; /** * destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. * @return */ @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(environment.getProperty("spring.datasource.url")); dataSource.setUsername(environment.getProperty("spring.datasource.username")); //用户名 dataSource.setPassword(environment.getProperty("spring.datasource.password")); //密码 dataSource.setDriverClassName(environment.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2); //初始化时建立物理连接的个数 dataSource.setMaxActive(20); //最大连接池数量 dataSource.setMinIdle(0); //最小连接池数量 dataSource.setMaxWait(60000); //获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery("SELECT 1"); //用来检测连接是否有效的sql dataSource.setTestOnBorrow(false); //申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true); //建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false); //是否缓存preparedStatement，也就是PSCache return dataSource; &#125;&#125; 数据12345678910111213-- auto-generated definitionCREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id)) ENGINE = InnoDB; 代码实体类：1234567891011package com.example.myproject.domain;@Componentpublic class TbStudent &#123; private Integer id; private String name; private String sex; private Integer age; private Integer clazzId; //getter,setter 可以用idea自动生成，将long类型的全改为Integer，为了以后不报错。 DAO层123456789101112131415161718package com.example.myproject.dao;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentDao &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.myproject.dao.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class TbStudentDaoImpl implements TbStudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int insert(TbStudent tbStudent) &#123; return jdbcTemplate.update("insert into tb_student(NAME) VALUES (?)",tbStudent.getName()); &#125; @Override public int update(TbStudent tbStudent) &#123; return jdbcTemplate.update("update tb_student set NAME=? where id=?",tbStudent.getName(),tbStudent.getId()); &#125; @Override public int delete(long id) &#123; return jdbcTemplate.update("delete from tb_student where id=?", id); &#125; @Override public TbStudent findTbStudent(long id) &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student WHERE id=?", new Object[]&#123;id&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); if(list != null &amp;&amp; list.size() &gt; 0) &#123; TbStudent tbStudent = list.get(0); return tbStudent; &#125;else &#123; return null; &#125; &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student", new Object[]&#123;&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); return list; &#125;&#125; 注：使用jdbcTemplate.query时，需要注意这个写法：new Object[]{id}, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)。并且如果只需要一个，需要进行null和size判定，之后取出一个，不然会报错。 Service层1234567891011121314151617181920package com.example.myproject.service;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentService &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.myproject.service.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TbStudentServiceImpl implements TbStudentService&#123; @Resource(name = "tbStudentDaoImpl") private TbStudentDao tbStudentDao; @Override public int insert(TbStudent tbStudent) &#123; return tbStudentDao.insert(tbStudent); &#125; @Override public int update(TbStudent tbStudent) &#123; return tbStudentDao.update(tbStudent); &#125; @Override public int delete(long id) &#123; return tbStudentDao.delete(id); &#125; @Override public TbStudent findTbStudent(long id) &#123; return tbStudentDao.findTbStudent(id); &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; return tbStudentDao.findAll(); &#125;&#125; Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.myproject.web;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author 34924 */@RestController@RequestMapping("/tbStudent")public class TbStudentController &#123; @Resource(name = "tbStudentServiceImpl") private TbStudentService tbStudentService; @RequestMapping("/findAll") public List&lt;TbStudent&gt; findAll() &#123; return tbStudentService.findAll(); &#125; @RequestMapping("/delete/&#123;id&#125;") public int delete(@PathVariable long id) &#123; return tbStudentService.delete(id); &#125; @RequestMapping(value = "/insert",method = RequestMethod.POST) public int insert(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.insert(tbStudent); &#125; @RequestMapping(value = "/update",method = RequestMethod.GET) public int update(@RequestParam Integer id,@RequestParam String name) &#123; TbStudent tbStudent = tbStudentService.findTbStudent(id); tbStudent.setName(name); return tbStudentService.update(tbStudent); &#125; @RequestMapping(value = "/findOne",method = RequestMethod.POST) public TbStudent findOne(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.findTbStudent(tbStudent.getId()); &#125;&#125; 注：此处全写的是接口 findAll用的是普通的get请求; delete用的restful的形式； insert用的post请求； update用的get请求，使用@RequestParam，注意post请求使用@RequestBody，而get请求只能使用@RequestParam； findOne用的post请求。 测试效果findAll： delete： insert： update： findOne：]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>JdbcTemplate</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod命令]]></title>
    <url>%2F2018%2F11%2F24%2Fchmod%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/home/user/java/jdk1.7.0/bin/java:permission denied处理方法：提升java为执行权限1chmod +x /home/user/java/jdk1.7.0/bin/java 以及javac权限不够也是如此处理。 chmod命令详解使用格式和方法Linux/Ubuntu 系统中文件调用的权限分为三级:文件拥有者(u)、群组(g)、其他(o)。用chmod就可以更改文件的权限。chmod是一个相当灵活的命令，对同一个文件的权限的修改可以用多种风格的命令格式来实现。 方式一语法格式： chmod [-vR] mode 文件名 参数说明: mode 权限设置字串,格式为[ugoa] [+-=] [rwx] u 表示文件的拥有者 g 表示与此文件拥有者属于一个组群的人 o 表示其他人 a 表示包含以上三者即文件拥有者(u)、群组(g)、其他(o) +表示增加权限 -表示取消权限 =表示唯一设置权限 r 表示有读取的权限 w 表示有写入的权限 x 表示有执行的权限 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改例： 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取、写入、执行的权限。 在这里就需要结合sudo命令来使用123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 或者使用123ownlinux@server:/var/www$ sudo chmod ugo+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 命令不一样，但执行后的效果是一样的。 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod a+rwx -R ownlinux[sudo] password for ownlinux: （此时输入你的密码） 语法格式： chmod [-vR] [No] 文件名 参数说明:No 三位代表相应权限的数字 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改 可能这种方式对于初学者来说有一定的难度，但这种方法学会后在更改文件权限就变得非常的简单。 刚才已经说过了，[No]参数 是三位代表相应权限的数字。从左向右，第一位数学代表文件拥有者(u)的权限、群组(g)的权限、其他(o)的权限。每一个数字就对应该级用户拥有的权限即为rwx相应的数字之和。 类似于二进制，如果是所有用户拥有该文件的读取、写入、执行的权限就是拥有者(u)的权限(4+2+1=7)群组(g)的权限(4+2+1=7)其他(o)的权限(4+2+1=7即为777。注意：如果没有读取的权限则”r”相应的数字编号就为”0″,写入(w)、执行(x)同理。 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取(r)、写入(w)、执行(x)的权限。回顾一下方式一的命令格式。123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 可以改为：123ownlinux@server:/var/www$ sudo chmod 777 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 如果要让当前目录下ownlinux这个文件的权限修为该文件的拥有者(u)有该文件的读取(r)、写入(w)、执行(x)的权限,群组(g)和其他(o)的用户只有读取(r)和执行(x)的权限,运行以下命令：123ownlinux@server:/var/www$ sudo chmod 755 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod 777 -R ownlinux[sudo] password for ownlinux: （此时输入你的密码）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放端口查看和打开关闭]]></title>
    <url>%2F2018%2F11%2F24%2F%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[查看打开端口1sudo iptables -L -n 打开80端口1sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F24%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot配置文件]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.config_test.git Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里:12com.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 在类中引入可以用@Value(“${….}”)的注解形式，也可以如下引用：12345678910111213package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "com.example.myproject.customer")public class Customer &#123; private String id; private String name; //getter,setter,toString&#125; 需要在springboot入口类上加上@EnableConfigurationProperties({Customer.class})注解，指明使用了配置文件的类。 12345678910111213141516package com.example.myproject;import com.example.myproject.domain.Customer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;@SpringBootApplication@EnableConfigurationProperties(&#123;Customer.class&#125;)public class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125;&#125; 参数间引用在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置：123com.example.myproject.customer.id = 001com.example.myproject.customer.name = jlcom.example.myproject.customer.title = 序号$&#123;com.example.myproject.customer.id&#125;,姓名$&#123;com.example.myproject.customer.name&#125; 运行测试，如果出现中文乱码，则进行以下步骤： java开发工具Idea下解决方案： File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 注意：做了上面操作后，一定要重新创建application.properties，才有效。 输出效果：1Customer&#123;id='001', name='jl', title='序号001,姓名jl'&#125; 使用自定义配置文件有时候我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里我明取名为test.properties,路径跟也放在src/main/resources下面。123com.example.myproject.customer2.id = 0011com.example.myproject.customer2.name = jlsdfcom.example.myproject.customer2.title = 序号$&#123;com.example.myproject.customer2.id&#125;,姓名$&#123;com.example.myproject.customer2.name&#125; 注意，这里的自定义配置名字不能与之前相同，不然会读取不到（踩坑贼开心）。 我们新建一个bean类,如下：12345678910111213141516package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:test.properties")@ConfigurationProperties(prefix = "com.example.myproject.customer2")public class Customer2 &#123; private String id; private String name; private String title; //getter,setter,toString &#125; 其中使用@PropertySource(value = “classpath:test.properties”)指向了properties文件，使用@ConfigurationProperties(prefix = “com.example.myproject.customer2”)指向了前缀。 在CustomerService和CustomerController中增加函数与调用：1234567891011121314CustomerService.java public Customer2 getCustomer2()&#123; return customer2; &#125;CustomerController.java @RequestMapping("/customer") public String customer(ModelMap map) &#123;// Customer customer = customerService.getCustomer(); Customer2 customer = customerService.getCustomer2(); map.addAttribute("customer", customer); return "index"; &#125; 也可以在Test中进行输出测试。 注：出现错误Spring Boot Configuration Annotion Processor not found in classpath。在pom.xml中引入：12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; 重启idea，会出现Re-run Spring Boot Configuration Annotation Processor to update generated metadata，这个问题可以忽略，不影响代码执行。只是提醒用户，进行必要的重新编译。 随机值配置配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。 range.properties写入：123456range.secret=$&#123;random.value&#125;range.number=$&#123;random.int&#125;range.bignumber=$&#123;random.long&#125;range.uuid=$&#123;random.uuid&#125;range.number.less.than.ten=$&#123;random.int(10)&#125;range.number.in.range=$&#123;random.int[1024,65536]&#125; 使用java接收，Range.java1234567891011121314151617181920212223package com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:range.properties")@ConfigurationProperties(prefix = "range")public class Range &#123; private String secret; private int number; private long bignumber; private String uuid; @Value("$&#123;range.number.less.than.ten&#125;") private int lessThanTen; @Value("$&#123;range.number.in.range&#125;") private int rangeNumber; //setter,getter,toString&#125; 配置相应的service和controller。显示效果如下： 注意，不重启springboot应用，这些值不会改变。 外部配置-命令行参数配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：1java -jar xx.jar 可以以下命令修改tomcat端口号：1java -jar xx.jar --server.port=9090 可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。 如果怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。 测试中的@TestPropertySource注解。 测试中的@SpringBootTest#properties注解特性。 命令行参数 SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。 ServletConfig初始化参数。 ServletContext初始化参数。 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}） 应用程序以外的application.properties或者appliaction.yml文件 打包在应用程序内的application.properties或者appliaction.yml文件 通过@PropertySource标注的属性源 默认属性(通过SpringApplication.setDefaultProperties指定). 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，列如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件的优先级application.properties和application.yml文件可以放在一下四个位置： 外置，在相对于应用程序运行目录的/congfig子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.yml里面的属性就会覆盖application.properties里的属性。 当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。 如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 当然你也可以用命令行启动的时候带上参数：1java -jar xxx.jar --spring.profiles.active=dev 给不同的环境添加不同的端口属性server.port，然后根据指定不同的spring.profiles.active来切换使用。 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口：1public interface DBConnector &#123; public void configure(); &#125; 定义2个类实现：1234567891011121314151617181920@Component@Profile("devDb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125;@Component@Profile("testDb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125; 在application.properties配置，激活其中一个类：1spring.profiles.active=testDb PS：这里一定要写对，如果写成testdb就会报错。 因为这里用的是thyemleaf模版，使用@RestController注解，应该是作为接口，所以可以用postman做测试，可以看到输出了testdb。 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile 12spring.profiles.active: testdb spring.profiles.include: proddb,prodmq]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot常用属性汇总]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[可以在application.properties/application.yml文件中或作为命令行开关指定各种属性。本节提供了常用的Spring Boot属性列表，以及对使用它们的底层类的引用。 属性贡献可以来自您的类路径上的其他jar文件，因此您不应该考虑这是一个详尽的列表。定义您自己的属性也是完全合法的。此示例文件仅作为指南。不要将整个内容复制/粘贴到您的应用程序中;而只是选择你需要的属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184# ===================================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^# ===================================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)# LOGGINGlogging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logbacklogging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.logging.file= # Log file name. For instance `myapp.log`logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`logging.path= # Location of the log file. For instance `/var/log`logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.# AOPspring.aop.auto=true # Add @EnableAspectJAutoProxy.spring.aop.proxy-target-class=false # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false).# IDENTITY (ContextIdApplicationContextInitializer)spring.application.index= # Application index.spring.application.name= # Application name.# ADMIN (SpringApplicationAdminJmxAutoConfiguration)spring.application.admin.enabled=false # Enable admin features for the application.spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.# AUTO-CONFIGURATIONspring.autoconfigure.exclude= # Auto-configuration classes to exclude.# SPRING COREspring.beaninfo.ignore=true # Skip search of BeanInfo classes.# SPRING CACHE (CacheProperties)spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.spring.cache.caffeine.spec= # The spec to use to create caches. Check CaffeineSpec for more details on the spec format.spring.cache.couchbase.expiration=0 # Entry expiration in milliseconds. By default the entries never expire.spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.spring.cache.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.spring.cache.type= # Cache type, auto-detected according to the environment by default.# SPRING CONFIG - using environment property only (ConfigFileApplicationListener)spring.config.location= # Config file locations.spring.config.name=application # Config file name.# HAZELCAST (HazelcastProperties)spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.# PROJECT INFORMATION (ProjectInfoProperties)spring.info.build.location=classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.spring.info.git.location=classpath:git.properties # Location of the generated git.properties file.# JMXspring.jmx.default-domain= # JMX domain name.spring.jmx.enabled=true # Expose management beans to the JMX domain.spring.jmx.server=mbeanServer # MBeanServer bean name.# Email (MailProperties)spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.spring.mail.host= # SMTP server host. For instance `smtp.example.com`spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.spring.mail.password= # Login password of the SMTP server.spring.mail.port= # SMTP server port.spring.mail.properties.*= # Additional JavaMail session properties.spring.mail.protocol=smtp # Protocol used by the SMTP server.spring.mail.test-connection=false # Test that the mail server is available on startup.spring.mail.username= # Login user of the SMTP server.# APPLICATION SETTINGS (SpringApplication)spring.main.banner-mode=console # Mode used to display the banner when the application runs.spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.spring.main.web-environment= # Run the application in a web environment (auto-detected by default).# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding= # Expected character encoding the application must use.# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.always-use-message-format=false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.spring.messages.encoding=UTF-8 # Message bundles encoding.spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.# OUTPUTspring.output.ansi.enabled=detect # Configure the ANSI output.# PID FILE (ApplicationPidFileWriter)spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).# PROFILESspring.profiles.active= # Comma-separated list (or list if using YAML) of active profiles.spring.profiles.include= # Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).# SENDGRID (SendGridAutoConfiguration)spring.sendgrid.api-key= # SendGrid api key (alternative to username/password)spring.sendgrid.username= # SendGrid account usernamespring.sendgrid.password= # SendGrid account passwordspring.sendgrid.proxy.host= # SendGrid proxy hostspring.sendgrid.proxy.port= # SendGrid proxy port# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.address= # Network address to which the server should bind to.server.compression.enabled=false # If response compression is enabled.server.compression.excluded-user-agents= # List of user-agents to exclude from compression.server.compression.mime-types= # Comma-separated list of MIME types that should be compressed. For instance `text/html,text/css,application/json`server.compression.min-response-size= # Minimum response size that is required for compression to be performed. For instance 2048server.connection-timeout= # Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector's container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`server.context-path= # Context path of the application.server.display-name=application # Display name of the application.server.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.server.error.include-stacktrace=never # When to include a "stacktrace" attribute.server.error.path=/error # Path of the error controller.server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.server.jetty.acceptors= # Number of acceptor threads to use.server.jetty.max-http-post-size=0 # Maximum size in bytes of the HTTP post or put content.server.jetty.selectors= # Number of selector threads to use.server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servletserver.jsp-servlet.registered=true # Whether or not the JSP servlet is registeredserver.port=8080 # Server HTTP port.server.server-header= # Value to use for the Server response header (no header is sent if empty)server.servlet-path=/ # Path of the main dispatcher servlet.server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.server.session.cookie.comment= # Comment for the session cookie.server.session.cookie.domain= # Domain for the session cookie.server.session.cookie.http-only= # "HttpOnly" flag for the session cookie.server.session.cookie.max-age= # Maximum age of the session cookie in seconds.server.session.cookie.name= # Session cookie name.server.session.cookie.path= # Path of the session cookie.server.session.cookie.secure= # "Secure" flag for the session cookie.server.session.persistent=false # Persist session data between restarts.server.session.store-dir= # Directory used to store session data.server.session.timeout= # Session timeout in seconds.server.session.tracking-modes= # Session tracking modes (one or more of the following: "cookie", "url", "ssl").server.ssl.ciphers= # Supported SSL ciphers.server.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store.server.ssl.enabled= # Enable SSL support.server.ssl.enabled-protocols= # Enabled SSL protocols.server.ssl.key-alias= # Alias that identifies the key in the key store.server.ssl.key-password= # Password used to access the key in the key store.server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password= # Password used to access the key store.server.ssl.key-store-provider= # Provider for the key store.server.ssl.key-store-type= # Type of the key store.server.ssl.protocol=TLS # SSL protocol to use.server.ssl.trust-store= # Trust store that holds SSL certificates.server.ssl.trust-store-password= # Password used to access the trust store.server.ssl.trust-store-provider= # Provider for the trust store.server.ssl.trust-store-type= # Type of the trust store.server.tomcat.accept-count= # Maximum queue length for incoming connection requests when all possible request processing threads are in use.server.tomcat.accesslog.buffered=true # Buffer output such that it is only flushed periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address, Hostname, protocol and port used for the request.server.tomcat.accesslog.rotate=true # Enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-connections= # Maximum number of connections that the server will accept and process at any given time.server.tomcat.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.tomcat.max-threads=0 # Maximum amount of worker threads.server.tomcat.min-spare-threads=0 # Minimum amount of worker threads.server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named "X-Forwarded-Proto".server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected by appending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.server.undertow.accesslog.dir= # Undertow access log directory.server.undertow.accesslog.enabled=false # Enable access log.server.undertow.accesslog.pattern=common # Format pattern for access logs.server.undertow.accesslog.prefix=access_log. # Log file name prefix.server.undertow.accesslog.rotate=true # Enable access log rotation.server.undertow.accesslog.suffix=log # Log file name suffix.server.undertow.buffer-size= # Size of each buffer in bytes.server.undertow.buffers-per-region= # Number of buffer per region.server.undertow.direct-buffers= # Allocate buffers outside the Java heap.server.undertow.io-threads= # Number of I/O threads to create for the worker.server.undertow.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.undertow.worker-threads= # Number of worker threads.# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.cache=false # Enable template caching.spring.freemarker.charset=UTF-8 # Template encoding.spring.freemarker.check-template-location=true # Check that the templates location exists.spring.freemarker.content-type=text/html # Content-Type value.spring.freemarker.enabled=true # Enable MVC view resolution for this technology.spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker's Configuration.spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.spring.freemarker.view-names= # White list of view names that can be resolved.# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.cache= # Enable template caching.spring.groovy.template.charset=UTF-8 # Template encoding.spring.groovy.template.check-template-location=true # Check that the templates location exists.spring.groovy.template.configuration.*= # See GroovyMarkupConfigurerspring.groovy.template.content-type=test/html # Content-Type value.spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.spring.groovy.template.view-names= # White list of view names that can be resolved.# SPRING HATEOAS (HateoasProperties)spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.# HTTP message conversionspring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to "gson" to force the use of Gson when both it and Jackson are on the classpath.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.spring.http.encoding.enabled=true # Enable http encoding support.spring.http.encoding.force= # Force the encoding to the configured charset on HTTP requests and responses.spring.http.encoding.force-request= # Force the encoding to the configured charset on HTTP requests. Defaults to true when "force" has not been specified.spring.http.encoding.force-response= # Force the encoding to the configured charset on HTTP responses.spring.http.encoding.mapping= # Locale to Encoding mapping.# MULTIPART (MultipartProperties)spring.http.multipart.enabled=true # Enable support of multi-part uploads.spring.http.multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.location= # Intermediate location of uploaded files.spring.http.multipart.max-file-size=1MB # Max file size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.max-request-size=10MB # Max request size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.resolve-lazily=false # Whether to resolve the multipart request lazily at the time of file or parameter access.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization.spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.spring.jackson.generator.*= # Jackson on/off features for generators.spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" will be used as a fallback if it is configured with a format string.spring.jackson.locale= # Locale used for formatting.spring.jackson.mapper.*= # Jackson general purpose on/off features.spring.jackson.parser.*= # Jackson on/off features for parsers.spring.jackson.property-naming-strategy= # One of the constants on Jackson's PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`# JERSEY (JerseyProperties)spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of "@ApplicationPath" if specified.spring.jersey.filter.order=0 # Jersey filter chain order.spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.spring.jersey.servlet.load-on-startup=-1 # Load on startup priority of the Jersey servlet.spring.jersey.type=servlet # Jersey integration type.# SPRING LDAP (LdapProperties)spring.ldap.urls= # LDAP URLs of the server.spring.ldap.base= # Base suffix from which all operations should originate.spring.ldap.username= # Login user of the server.spring.ldap.password= # Login password of the server.spring.ldap.base-environment.*= # LDAP specification settings.# EMBEDDED LDAP (EmbeddedLdapProperties)spring.ldap.embedded.port= # Embedded LDAP port.spring.ldap.embedded.credential.username= # Embedded LDAP username.spring.ldap.embedded.credential.password= # Embedded LDAP password.spring.ldap.embedded.base-dn= # The base DNspring.ldap.embedded.ldif=classpath:schema.ldif # Schema (LDIF) script resource reference.# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.# MUSTACHE TEMPLATES (MustacheAutoConfiguration)spring.mustache.allow-request-override= # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.allow-session-override= # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.cache= # Enable template caching.spring.mustache.charset= # Template encoding.spring.mustache.check-template-location= # Check that the templates location exists.spring.mustache.content-type= # Content-Type value.spring.mustache.enabled= # Enable MVC view resolution for this technology.spring.mustache.expose-request-attributes= # Set whether all request attributes should be added to the model prior to merging with the template.spring.mustache.expose-session-attributes= # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.mustache.expose-spring-macro-helpers= # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.spring.mustache.request-context-attribute= # Name of the RequestContext attribute for all views.spring.mustache.suffix=.html # Suffix to apply to template names.spring.mustache.view-names= # White list of view names that can be resolved.# SPRING MVC (WebMvcProperties)spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.spring.mvc.dispatch-options-request=true # Dispatch OPTIONS requests to the FrameworkServlet doService method.spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.spring.mvc.formcontent.putfilter.enabled=true # Enable Spring's HttpPutFormContentFilter.spring.mvc.ignore-default-model-on-redirect=true # If the content of the "default" model should be ignored during redirect scenarios.spring.mvc.locale= # Locale to use. By default, this locale is overridden by the "Accept-Language" header.spring.mvc.locale-resolver=accept-header # Define how the locale should be resolved.spring.mvc.log-resolved-exception=false # Enable warn logging of exceptions resolved by a "HandlerExceptionResolver".spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.throw-exception-if-no-handler-found=false # If a "NoHandlerFoundException" should be thrown if no Handler was found to process a request.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# SPRING RESOURCES HANDLING (ResourceProperties)spring.resources.add-mappings=true # Enable default resource handling.spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.spring.resources.chain.cache=true # Enable caching in the Resource chain.spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.spring.resources.chain.gzipped=false # Enable resolution of already gzipped resources.spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.spring.resources.chain.strategy.fixed.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.# SPRING SESSION (SessionProperties)spring.session.hazelcast.flush-mode=on-save # Sessions flush mode.spring.session.hazelcast.map-name=spring:session:sessions # Name of the map used to store sessions.spring.session.jdbc.initializer.enabled= # Create the required session tables on startup if necessary. Enabled automatically if the default table name is set or a custom schema is configured.spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.session.jdbc.table-name=SPRING_SESSION # Name of database table used to store sessions.spring.session.mongo.collection-name=sessions # Collection name used to store sessions.spring.session.redis.flush-mode=on-save # Sessions flush mode.spring.session.redis.namespace= # Namespace for keys used to store sessions.spring.session.store-type= # Session store type.# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=false # Enable the connection status view for supported providers.# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application's Facebook App IDspring.social.facebook.app-secret= # your application's Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application's LinkedIn App IDspring.social.linkedin.app-secret= # your application's LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application's Twitter App IDspring.social.twitter.app-secret= # your application's Twitter App Secret# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.cache=true # Enable template caching.spring.thymeleaf.check-template=true # Check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Check that the templates location exists.spring.thymeleaf.content-type=text/html # Content-Type value.spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.spring.thymeleaf.encoding=UTF-8 # Template encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.# SPRING WEB SERVICES (WebServicesProperties)spring.webservices.path=/services # Path that serves as the base URI for the services.spring.webservices.servlet.init= # Servlet init parameters to pass to Spring Web Services.spring.webservices.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)security.basic.authorize-mode=role # Security authorize mode to apply.security.basic.enabled=true # Enable basic authentication.security.basic.path=/** # Comma-separated list of paths to secure.security.basic.realm=Spring # HTTP basic realm name.security.enable-csrf=false # Enable Cross Site Request Forgery support.security.filter-order=0 # Security filter chain order.security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.security.headers.cache=true # Enable cache control HTTP headers.security.headers.content-security-policy= # Value for content security policy header.security.headers.content-security-policy-mode=default # Content security policy mode.security.headers.content-type=true # Enable "X-Content-Type-Options" header.security.headers.frame=true # Enable "X-Frame-Options" header.security.headers.hsts=all # HTTP Strict Transport Security (HSTS) mode (none, domain, all).security.headers.xss=true # Enable cross site scripting (XSS) protection.security.ignored= # Comma-separated list of paths to exclude from the default secured paths.security.require-ssl=false # Enable secure channel for all requests.security.sessions=stateless # Session creation policy (always, never, if_required, stateless).security.user.name=user # Default user name.security.user.password= # Password for the default user name. A random password is logged on startup by default.security.user.role=USER # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)security.oauth2.client.client-id= # OAuth2 client id.security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default# SECURITY OAUTH2 RESOURCES (ResourceServerProperties)security.oauth2.resource.filter-order= # The order of the filter chain used to authenticate tokens.security.oauth2.resource.id= # Identifier of the resource.security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.security.oauth2.resource.service-id=resource #security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.security.oauth2.resource.user-info-uri= # URI of the user endpoint.# SECURITY OAUTH2 SSO (OAuth2SsoProperties)security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdaptersecurity.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server# ----------------------------------------# DATA PROPERTIES# ----------------------------------------# FLYWAY (FlywayProperties)flyway.baseline-description= #flyway.baseline-version=1 # version to start migrationflyway.baseline-on-migrate= #flyway.check-location=false # Check that migration scripts location exists.flyway.clean-on-validation-error= #flyway.enabled=true # Enable flyway.flyway.encoding= #flyway.ignore-failed-future-migration= #flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.flyway.locations=classpath:db/migration # locations of migrations scriptsflyway.out-of-order= #flyway.password= # JDBC password if you want Flyway to create its own DataSourceflyway.placeholder-prefix= #flyway.placeholder-replacement= #flyway.placeholder-suffix= #flyway.placeholders.*= #flyway.schemas= # schemas to updateflyway.sql-migration-prefix=V #flyway.sql-migration-separator= #flyway.sql-migration-suffix=.sql #flyway.table= #flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.flyway.user= # Login user of the database to migrate.flyway.validate-on-migrate= ## LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.liquibase.check-change-log-location=true # Check the change log location exists.liquibase.contexts= # Comma-separated list of runtime contexts to use.liquibase.default-schema= # Default database schema.liquibase.drop-first=false # Drop the database schema first.liquibase.enabled=true # Enable liquibase support.liquibase.labels= # Comma-separated list of runtime labels to use.liquibase.parameters.*= # Change log parameters.liquibase.password= # Login password of the database to migrate.liquibase.rollback-file= # File to which rollback SQL will be written when an update is performed.liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.liquibase.user= # Login user of the database to migrate.# COUCHBASE (CouchbaseProperties)spring.couchbase.bootstrap-hosts= # Couchbase nodes (host or IP address) to bootstrap from.spring.couchbase.bucket.name=default # Name of the bucket to connect to.spring.couchbase.bucket.password= # Password of the bucket.spring.couchbase.env.endpoints.key-value=1 # Number of sockets per node against the Key/value service.spring.couchbase.env.endpoints.query=1 # Number of sockets per node against the Query (N1QL) service.spring.couchbase.env.endpoints.view=1 # Number of sockets per node against the view service.spring.couchbase.env.ssl.enabled= # Enable SSL support. Enabled automatically if a "keyStore" is provided unless specified otherwise.spring.couchbase.env.ssl.key-store= # Path to the JVM key store that holds the certificates.spring.couchbase.env.ssl.key-store-password= # Password used to access the key store.spring.couchbase.env.timeouts.connect=5000 # Bucket connections timeout in milliseconds.spring.couchbase.env.timeouts.key-value=2500 # Blocking operations performed on a specific key timeout in milliseconds.spring.couchbase.env.timeouts.query=7500 # N1QL query operations timeout in milliseconds.spring.couchbase.env.timeouts.socket-connect=1000 # Socket connect connections timeout in milliseconds.spring.couchbase.env.timeouts.view=7500 # Regular and geospatial view operations timeout in milliseconds.# DAO (PersistenceExceptionTranslationAutoConfiguration)spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.# CASSANDRA (CassandraProperties)spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.spring.data.cassandra.compression=none # Compression supported by the Cassandra binary protocol.spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.spring.data.cassandra.consistency-level= # Queries consistency level.spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.spring.data.cassandra.fetch-size= # Queries default fetch size.spring.data.cassandra.keyspace-name= # Keyspace name to use.spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.spring.data.cassandra.port= # Port of the Cassandra server.spring.data.cassandra.password= # Login password of the server.spring.data.cassandra.read-timeout-millis= # Socket option: read time out.spring.data.cassandra.reconnection-policy= # Reconnection policy class.spring.data.cassandra.retry-policy= # Class name of the retry policy.spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.spring.data.cassandra.schema-action=none # Schema action to take at startup.spring.data.cassandra.ssl=false # Enable SSL support.spring.data.cassandra.username= # Login user of the server.# DATA COUCHBASE (CouchbaseDataProperties)spring.data.couchbase.auto-index=false # Automatically create views and indexes.spring.data.couchbase.consistency=read-your-own-writes # Consistency to apply by default on generated queries.spring.data.couchbase.repositories.enabled=true # Enable Couchbase repositories.# ELASTICSEARCH (ElasticsearchProperties)spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.# DATA LDAPspring.data.ldap.repositories.enabled=true # Enable LDAP repositories.# MONGODB (MongoProperties)spring.data.mongodb.authentication-database= # Authentication database name.spring.data.mongodb.database=test # Database name.spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database= # GridFS database name.spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.# DATA REDISspring.data.redis.repositories.enabled=true # Enable Redis repositories.# NEO4J (Neo4jProperties)spring.data.neo4j.compiler= # Compiler to use.spring.data.neo4j.embedded.enabled=true # Enable embedded mode if the embedded driver is available.spring.data.neo4j.open-in-view=false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.spring.data.neo4j.password= # Login password of the server.spring.data.neo4j.repositories.enabled=true # Enable Neo4j repositories.spring.data.neo4j.uri= # URI used by the driver. Auto-detected by default.spring.data.neo4j.username= # Login user of the server.# DATA REST (RepositoryRestProperties)spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.spring.data.rest.default-page-size= # Default size of pages.spring.data.rest.detection-strategy=default # Strategy to use to determine which repositories get exposed.spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.spring.data.rest.max-page-size= # Maximum size of pages.spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.spring.data.rest.return-body-on-create= # Return a response body after creating an entity.spring.data.rest.return-body-on-update= # Return a response body after updating an entity.spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.# SOLR (SolrProperties)spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if "zk-host" is set.spring.data.solr.repositories.enabled=true # Enable Solr repositories.spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.spring.datasource.data= # Data (DML) script resource references.spring.datasource.data-username= # User of the database to execute DML scripts (if different).spring.datasource.data-password= # Password of the database to execute DML scripts (if different).spring.datasource.dbcp2.*= # Commons DBCP2 specific settingsspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.generate-unique-name=false # Generate a random datasource name.spring.datasource.hikari.*= # Hikari specific settingsspring.datasource.initialize=true # Populate the database using 'data.sql'.spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.spring.datasource.name=testdb # Name of the datasource.spring.datasource.password= # Login password of the database.spring.datasource.platform=all # Platform to use in the schema resource (schema-$&#123;platform&#125;.sql).spring.datasource.schema= # Schema (DDL) script resource references.spring.datasource.schema-username= # User of the database to execute DDL scripts (if different).spring.datasource.schema-password= # Password of the database to execute DDL scripts (if different).spring.datasource.separator=; # Statement separator in SQL initialization scripts.spring.datasource.sql-script-encoding= # SQL scripts encoding.spring.datasource.tomcat.*= # Tomcat datasource specific settingsspring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.spring.datasource.url= # JDBC url of the database.spring.datasource.username=# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.connection-timeout=3000 # Connection timeout in milliseconds.spring.elasticsearch.jest.multi-threaded=true # Enable connection requests from multiple execution threads.spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3000 # Read timeout in milliseconds.spring.elasticsearch.jest.uris=http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.spring.elasticsearch.jest.username= # Login user.# H2 Web Console (H2ConsoleProperties)spring.h2.console.enabled=false # Enable the console.spring.h2.console.path=/h2-console # Path at which the console will be available.spring.h2.console.settings.trace=false # Enable trace output.spring.h2.console.settings.web-allow-others=false # Enable remote access.# JOOQ (JooqAutoConfiguration)spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.data.jpa.repositories.enabled=true # Enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the "databasePlatform" property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the "Database" enum.spring.jpa.generate-ddl=false # Initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto" property. Default to "create-drop" when using an embedded database, "none" otherwise.spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.naming.strategy= # Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate 5.spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Enable logging of SQL statements.# JTA (JtaAutoConfiguration)spring.jta.enabled=true # Enable JTA support.spring.jta.log-dir= # Transaction logs directory.spring.jta.transaction-manager-id= # Transaction manager unique identifier.# ATOMIKOS (AtomikosProperties)spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.atomikos.properties.checkpoint-interval=500 # Interval between checkpoints.spring.jta.atomikos.properties.console-file-count=1 # Number of debug logs files that can be created.spring.jta.atomikos.properties.console-file-limit=-1 # How many bytes can be stored at most in debug logs files.spring.jta.atomikos.properties.console-file-name=tm.out # Debug logs file name.spring.jta.atomikos.properties.console-log-level=warn # Console log level.spring.jta.atomikos.properties.default-jta-timeout=10000 # Default timeout for JTA transactions.spring.jta.atomikos.properties.enable-logging=true # Enable disk logging.spring.jta.atomikos.properties.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.spring.jta.atomikos.properties.log-base-dir= # Directory in which the log files should be stored.spring.jta.atomikos.properties.log-base-name=tmlog # Transactions log file base name.spring.jta.atomikos.properties.max-actives=50 # Maximum number of active transactions.spring.jta.atomikos.properties.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.spring.jta.atomikos.properties.output-dir= # Directory in which to store the debug log files.spring.jta.atomikos.properties.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.spring.jta.atomikos.properties.service= # Transaction manager implementation that should be started.spring.jta.atomikos.properties.threaded-two-phase-commit=true # Use different (and concurrent) threads for two-phase commit on the participating resources.spring.jta.atomikos.properties.transaction-manager-unique-name= # Transaction manager's unique name.# BITRONIXspring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.spring.jta.bitronix.connectionfactory.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.spring.jta.bitronix.datasource.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.properties.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.spring.jta.bitronix.properties.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.spring.jta.bitronix.properties.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.spring.jta.bitronix.properties.current-node-only-recovery=true # Recover only the current node.spring.jta.bitronix.properties.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.spring.jta.bitronix.properties.default-transaction-timeout=60 # Default transaction timeout in seconds.spring.jta.bitronix.properties.disable-jmx=false # Enable JMX support.spring.jta.bitronix.properties.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.spring.jta.bitronix.properties.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.spring.jta.bitronix.properties.force-batching-enabled=true # Set if disk forces are batched.spring.jta.bitronix.properties.forced-write-enabled=true # Set if logs are forced to disk.spring.jta.bitronix.properties.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.spring.jta.bitronix.properties.jndi-user-transaction-name= # JNDI name of the UserTransaction.spring.jta.bitronix.properties.journal=disk # Name of the journal. Can be 'disk', 'null' or a class name.spring.jta.bitronix.properties.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.spring.jta.bitronix.properties.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.spring.jta.bitronix.properties.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.spring.jta.bitronix.properties.resource-configuration-filename= # ResourceLoader configuration file name.spring.jta.bitronix.properties.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine's IP address.spring.jta.bitronix.properties.skip-corrupted-logs=false # Skip corrupted transactions log entries.spring.jta.bitronix.properties.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.# NARAYANA (NarayanaProperties)spring.jta.narayana.default-timeout=60 # Transaction timeout in seconds.spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.spring.jta.narayana.log-dir= # Transaction object store directory.spring.jta.narayana.one-phase-commit=true # Enable one phase commit optimisation.spring.jta.narayana.periodic-recovery-period=120 # Interval in which periodic recovery scans are performed in seconds.spring.jta.narayana.recovery-backoff-period=10 # Back off period between first and second phases of the recovery scan in seconds.spring.jta.narayana.recovery-db-pass= # Database password to be used by recovery manager.spring.jta.narayana.recovery-db-user= # Database username to be used by recovery manager.spring.jta.narayana.recovery-jms-pass= # JMS password to be used by recovery manager.spring.jta.narayana.recovery-jms-user= # JMS username to be used by recovery manager.spring.jta.narayana.recovery-modules= # Comma-separated list of recovery modules.spring.jta.narayana.transaction-manager-id=1 # Unique transaction manager id.spring.jta.narayana.xa-resource-orphan-filters= # Comma-separated list of orphan filters.# EMBEDDED MONGODB (EmbeddedMongoProperties)spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.spring.mongodb.embedded.storage.database-dir= # Directory used for data storage.spring.mongodb.embedded.storage.oplog-size= # Maximum size of the oplog in megabytes.spring.mongodb.embedded.storage.repl-set-name= # Name of the replica set.spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.# REDIS (RedisProperties)spring.redis.cluster.max-redirects= # Maximum number of redirects to follow when executing commands across the cluster.spring.redis.cluster.nodes= # Comma-separated list of "host:port" pairs to bootstrap from.spring.redis.database=0 # Database index used by the connection factory.spring.redis.url= # Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.ssl=false # Enable SSL support.spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.spring.redis.pool.max-idle=8 # Max number of "idle" connections in the pool. Use a negative value to indicate an unlimited number of idle connections.spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.spring.redis.port=6379 # Redis server port.spring.redis.sentinel.master= # Name of Redis server.spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.spring.redis.timeout=0 # Connection timeout in milliseconds.# TRANSACTION (TransactionProperties)spring.transaction.default-timeout= # Default transaction timeout in seconds.spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.# ----------------------------------------# INTEGRATION PROPERTIES# ----------------------------------------# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default. For instance `tcp://localhost:61616`spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.spring.activemq.password= # Login password of the broker.spring.activemq.user= # Login user of the broker.spring.activemq.packages.trust-all=false # Trust all packages.spring.activemq.packages.trusted= # Comma-separated list of specific packages to trust (when not trusting all packages).spring.activemq.pool.configuration.*= # See PooledConnectionFactory.spring.activemq.pool.enabled=false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.spring.activemq.pool.expiry-timeout=0 # Connection expiration timeout in milliseconds.spring.activemq.pool.idle-timeout=30000 # Connection idle timeout in milliseconds.spring.activemq.pool.max-connections=1 # Maximum number of pooled connections.# ARTEMIS (ArtemisProperties)spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.spring.artemis.embedded.persistent=false # Enable persistent store.spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.spring.artemis.host=localhost # Artemis broker host.spring.artemis.mode= # Artemis deployment mode, auto-detected by default.spring.artemis.password= # Login password of the broker.spring.artemis.port=61616 # Artemis broker port.spring.artemis.user= # Login user of the broker.# SPRING BATCH (BatchProperties)spring.batch.initializer.enabled= # Create the required batch tables on startup if necessary. Enabled automatically if no custom table prefix is set or if a custom schema is configured.spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.# JMS (JmsProperties)spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.spring.jms.listener.auto-startup=true # Start the container automatically on startup.spring.jms.listener.concurrency= # Minimum number of concurrent consumers.spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.spring.jms.template.default-destination= # Default destination to use on send/receive operations that do not have a destination parameter.spring.jms.template.delivery-delay= # Delivery delay to use for send calls in milliseconds.spring.jms.template.delivery-mode= # Delivery mode. Enable QoS when set.spring.jms.template.priority= # Priority of a message when sending. Enable QoS when set.spring.jms.template.qos-enabled= # Enable explicit QoS when sending a message.spring.jms.template.receive-timeout= # Timeout to use for receive calls in milliseconds.spring.jms.template.time-to-live= # Time-to-live of a message when sending in milliseconds. Enable QoS when set.# APACHE KAFKA (KafkaProperties)spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.consumer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.enable-auto-commit= # If true the consumer's offset will be periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch.min.bytes".spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request in bytes.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group this consumer belongs to.spring.kafka.consumer.heartbeat-interval= # Expected time in milliseconds between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".spring.kafka.listener.ack-mode= # Listener AckMode; see the spring-kafka documentation.spring.kafka.listener.ack-time= # Time in milliseconds between offset commits when ackMode is "TIME" or "COUNT_TIME".spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.poll-timeout= # Timeout in milliseconds to use when polling the consumer.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Number of records to batch before sending.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.producer.buffer-memory= # Total bytes of memory the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.keystore-location= # Location of the key store file.spring.kafka.ssl.keystore-password= # Store password for the key store file.spring.kafka.ssl.truststore-location= # Location of the trust store file.spring.kafka.ssl.truststore-password= # Store password for the trust store file.spring.kafka.template.default-topic= # Default topic to which messages will be sent.# RABBIT (RabbitProperties)spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect.spring.rabbitmq.cache.channel.checkout-timeout= # Number of milliseconds to wait to obtain a channel if the cache size has been reached.spring.rabbitmq.cache.channel.size= # Number of channels to retain in the cache.spring.rabbitmq.cache.connection.mode=channel # Connection factory cache mode.spring.rabbitmq.cache.connection.size= # Number of connections to cache.spring.rabbitmq.connection-timeout= # Connection timeout, in milliseconds; zero for infinite.spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.spring.rabbitmq.host=localhost # RabbitMQ host.spring.rabbitmq.listener.acknowledge-mode= # Acknowledge mode of container.spring.rabbitmq.listener.auto-startup=true # Start the container automatically on startup.spring.rabbitmq.listener.concurrency= # Minimum number of consumers.spring.rabbitmq.listener.default-requeue-rejected= # Whether or not to requeue delivery failures; default `true`.spring.rabbitmq.listener.idle-event-interval= # How often idle container events should be published in milliseconds.spring.rabbitmq.listener.max-concurrency= # Maximum number of consumers.spring.rabbitmq.listener.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).spring.rabbitmq.listener.retry.enabled=false # Whether or not publishing retries are enabled.spring.rabbitmq.listener.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message.spring.rabbitmq.listener.retry.max-attempts=3 # Maximum number of attempts to deliver a message.spring.rabbitmq.listener.retry.max-interval=10000 # Maximum interval between attempts.spring.rabbitmq.listener.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval.spring.rabbitmq.listener.retry.stateless=true # Whether or not retry is stateless or stateful.spring.rabbitmq.listener.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.spring.rabbitmq.password= # Login to authenticate against the broker.spring.rabbitmq.port=5672 # RabbitMQ port.spring.rabbitmq.publisher-confirms=false # Enable publisher confirms.spring.rabbitmq.publisher-returns=false # Enable publisher returns.spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.spring.rabbitmq.ssl.enabled=false # Enable SSL support.spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.spring.rabbitmq.template.mandatory=false # Enable mandatory messages.spring.rabbitmq.template.receive-timeout=0 # Timeout for `receive()` methods.spring.rabbitmq.template.reply-timeout=5000 # Timeout for `sendAndReceive()` methods.spring.rabbitmq.template.retry.enabled=false # Set to true to enable retries in the `RabbitTemplate`.spring.rabbitmq.template.retry.initial-interval=1000 # Interval between the first and second attempt to publish a message.spring.rabbitmq.template.retry.max-attempts=3 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.max-interval=10000 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.multiplier=1.0 # A multiplier to apply to the previous publishing retry interval.spring.rabbitmq.username= # Login user to authenticate to the broker.spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# ENDPOINTS (AbstractEndpoint subclasses)endpoints.enabled=true # Enable endpoints.endpoints.sensitive= # Default endpoint sensitive setting.endpoints.actuator.enabled=true # Enable the endpoint.endpoints.actuator.path= # Endpoint URL path.endpoints.actuator.sensitive=false # Enable security on the endpoint.endpoints.auditevents.enabled= # Enable the endpoint.endpoints.auditevents.path= # Endpoint path.endpoints.auditevents.sensitive=false # Enable security on the endpoint.endpoints.autoconfig.enabled= # Enable the endpoint.endpoints.autoconfig.id= # Endpoint identifier.endpoints.autoconfig.path= # Endpoint path.endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.beans.enabled= # Enable the endpoint.endpoints.beans.id= # Endpoint identifier.endpoints.beans.path= # Endpoint path.endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.configprops.enabled= # Enable the endpoint.endpoints.configprops.id= # Endpoint identifier.endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.configprops.path= # Endpoint path.endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.docs.curies.enabled=false # Enable the curie generation.endpoints.docs.enabled=true # Enable actuator docs endpoint.endpoints.docs.path=/docs #endpoints.docs.sensitive=false #endpoints.dump.enabled= # Enable the endpoint.endpoints.dump.id= # Endpoint identifier.endpoints.dump.path= # Endpoint path.endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.env.enabled= # Enable the endpoint.endpoints.env.id= # Endpoint identifier.endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.env.path= # Endpoint path.endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.flyway.enabled= # Enable the endpoint.endpoints.flyway.id= # Endpoint identifier.endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.enabled= # Enable the endpoint.endpoints.health.id= # Endpoint identifier.endpoints.health.mapping.*= # Mapping of health statuses to HttpStatus codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).endpoints.health.path= # Endpoint path.endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.endpoints.heapdump.enabled= # Enable the endpoint.endpoints.heapdump.path= # Endpoint path.endpoints.heapdump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.hypermedia.enabled=false # Enable hypermedia support for endpoints.endpoints.info.enabled= # Enable the endpoint.endpoints.info.id= # Endpoint identifier.endpoints.info.path= # Endpoint path.endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.jolokia.enabled=true # Enable Jolokia endpoint.endpoints.jolokia.path=/jolokia # Endpoint URL path.endpoints.jolokia.sensitive=true # Enable security on the endpoint.endpoints.liquibase.enabled= # Enable the endpoint.endpoints.liquibase.id= # Endpoint identifier.endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.logfile.enabled=true # Enable the endpoint.endpoints.logfile.external-file= # External Logfile to be accessed.endpoints.logfile.path=/logfile # Endpoint URL path.endpoints.logfile.sensitive=true # Enable security on the endpoint.endpoints.loggers.enabled=true # Enable the endpoint.endpoints.loggers.id= # Endpoint identifier.endpoints.loggers.path=/logfile # Endpoint path.endpoints.loggers.sensitive=true # Mark if the endpoint exposes sensitive information.endpoints.mappings.enabled= # Enable the endpoint.endpoints.mappings.id= # Endpoint identifier.endpoints.mappings.path= # Endpoint path.endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.metrics.enabled= # Enable the endpoint.endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.endpoints.metrics.filter.gauge-submissions=merged # Http filter gauge submissions (merged, per-http-method)endpoints.metrics.filter.counter-submissions=merged # Http filter counter submissions (merged, per-http-method)endpoints.metrics.id= # Endpoint identifier.endpoints.metrics.path= # Endpoint path.endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.shutdown.enabled= # Enable the endpoint.endpoints.shutdown.id= # Endpoint identifier.endpoints.shutdown.path= # Endpoint path.endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.trace.enabled= # Enable the endpoint.endpoints.trace.id= # Endpoint identifier.endpoints.trace.path= # Endpoint path.endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.# ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. '*' allows all headers.endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. '*' allows all methods.endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. '*' allows all origins. When not set, CORS support is disabled.endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.domain= # JMX domain name. Initialized with the value of 'spring.jmx.default-domain' if set.endpoints.jmx.enabled=true # Enable JMX export of all endpoints.endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.add-application-context-header=true # Add the "X-Application-Context" HTTP header in each response.management.address= # Network address that the management endpoints should bind to.management.context-path= # Management endpoint context-path. For instance `/actuator`management.cloudfoundry.enabled= # Enable extended Cloud Foundry actuator endpointsmanagement.cloudfoundry.skip-ssl-validation= # Skip SSL verification for Cloud Foundry actuator endpoint security callsmanagement.port= # Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.management.security.enabled=true # Enable security.management.security.roles=ACTUATOR # Comma-separated list of roles that can access the management endpoint.management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).management.ssl.ciphers= # Supported SSL ciphers. Requires a custom management.port.management.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store. Requires a custom management.port.management.ssl.enabled= # Enable SSL support. Requires a custom management.port.management.ssl.enabled-protocols= # Enabled SSL protocols. Requires a custom management.port.management.ssl.key-alias= # Alias that identifies the key in the key store. Requires a custom management.port.management.ssl.key-password= # Password used to access the key in the key store. Requires a custom management.port.management.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.management.ssl.key-store-password= # Password used to access the key store. Requires a custom management.port.management.ssl.key-store-provider= # Provider for the key store. Requires a custom management.port.management.ssl.key-store-type= # Type of the key store. Requires a custom management.port.management.ssl.protocol=TLS # SSL protocol to use. Requires a custom management.port.management.ssl.trust-store= # Trust store that holds SSL certificates. Requires a custom management.port.management.ssl.trust-store-password= # Password used to access the trust store. Requires a custom management.port.management.ssl.trust-store-provider= # Provider for the trust store. Requires a custom management.port.management.ssl.trust-store-type= # Type of the trust store. Requires a custom management.port.# HEALTH INDICATORSmanagement.health.db.enabled=true # Enable database health check.management.health.cassandra.enabled=true # Enable cassandra health check.management.health.couchbase.enabled=true # Enable couchbase health check.management.health.defaults.enabled=true # Enable default health indicators.management.health.diskspace.enabled=true # Enable disk space health check.management.health.diskspace.path= # Path used to compute the available disk space.management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.management.health.elasticsearch.enabled=true # Enable elasticsearch health check.management.health.elasticsearch.indices= # Comma-separated index names.management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.management.health.jms.enabled=true # Enable JMS health check.management.health.ldap.enabled=true # Enable LDAP health check.management.health.mail.enabled=true # Enable Mail health check.management.health.mongo.enabled=true # Enable MongoDB health check.management.health.rabbit.enabled=true # Enable RabbitMQ health check.management.health.redis.enabled=true # Enable Redis health check.management.health.solr.enabled=true # Enable Solr health check.management.health.status.order=DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.# INFO CONTRIBUTORS (InfoContributorProperties)management.info.build.enabled=true # Enable build info.management.info.defaults.enabled=true # Enable default info contributors.management.info.env.enabled=true # Enable environment info.management.info.git.enabled=true # Enable git info.management.info.git.mode=simple # Mode to use to expose git information.# REMOTE SHELL (ShellProperties)management.shell.auth.type=simple # Authentication type. Auto-detected according to the environment.management.shell.auth.jaas.domain=my-domain # JAAS domain.management.shell.auth.key.path= # Path to the authentication key. This should point to a valid ".pem" file.management.shell.auth.simple.user.name=user # Login user.management.shell.auth.simple.user.password= # Login password.management.shell.auth.spring.roles=ACTUATOR # Comma-separated list of required roles to login to the CRaSH console.management.shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.management.shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).management.shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.management.shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.management.shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.management.shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.management.shell.ssh.enabled=true # Enable CRaSH SSH support.management.shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.management.shell.ssh.key-path= # Path to the SSH server key.management.shell.ssh.port=2000 # SSH port.management.shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is available.management.shell.telnet.port=5000 # Telnet port.# TRACING (TraceProperties)management.trace.include=request-headers,response-headers,cookies,errors # Items to be included in the trace.# METRICS EXPORT (MetricExportProperties)spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.spring.metrics.export.includes= # List of patterns for metric names to include.spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.# ----------------------------------------# DEVTOOLS PROPERTIES# ----------------------------------------# DEVTOOLS (DevToolsProperties)spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.spring.devtools.livereload.port=35729 # Server port.spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-paths= # Additional paths to watch for changes.spring.devtools.restart.enabled=true # Enable automatic restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.# REMOTE DEVTOOLS (RemoteDevToolsProperties)spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.spring.devtools.remote.debug.enabled=true # Enable remote debug support.spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.spring.devtools.remote.restart.enabled=true # Enable remote restart.spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.# ----------------------------------------# TESTING PROPERTIES# ----------------------------------------spring.test.database.replace=any # Type of existing DataSource to replace.spring.test.mockmvc.print=default # MVC Print option.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot工程结构推荐]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.myproject.git Spring Boot框架本身并没有对工程结构有特别的要求，但是按照最佳实践的工程结构可以帮助我们减少可能会遇见的坑，尤其是Spring包扫描机制的存在，如果您使用最佳实践的工程结构，可以免去不少特殊的配置工作。 典型示例 root package结构：com.example.myproject 应用主类Application.java置于root package下，通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web | +- CustomerController.java | 创建： 项目结构： 工程构建在上述基础，构建项目：1234567891011121314151617181920212223242526272829Customer.javapackage com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Customer &#123; @Value("$&#123;com.example.myproject.customer.id&#125;") private String id; @Value("$&#123;com.example.myproject.customer.name&#125;") private String name; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920CustomerService.javapackage com.example.myproject.service;import com.example.myproject.domain.Customer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class CustomerService &#123; @Autowired private Customer customer; public void printCustomer() &#123; System.out.println(customer.getName()); &#125; public Customer getCustomer()&#123; return customer; &#125;&#125; 1234567891011121314151617181920212223242526CustomerController.javapackage com.example.myproject.web;import com.example.myproject.domain.Customer;import com.example.myproject.service.CustomerService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;/** * @author 34924 */@Controllerpublic class CustomerController &#123; @Autowired CustomerService customerService; @RequestMapping("/customer") public String customer(ModelMap map) &#123; Customer customer = customerService.getCustomer(); map.addAttribute("customer", customer); return "index"; &#125;&#125; 123456789101112index.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;customer.id&#125;"&gt;Hello World&lt;/h1&gt;&lt;h2 th:text="$&#123;customer.name&#125;"&gt;name&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234application.propertiescom.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 运行项目，访问localhost:8080/customer 也可以test：1234567891011121314151617181920212223242526272829MyprojectApplicationTests.javapackage com.example.myproject;import com.example.myproject.service.CustomerService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class MyprojectApplicationTests &#123; @Autowired private CustomerService customerService; @Test public void contextLoads() &#123; &#125; @Test public void testCustomer() &#123; customerService.printCustomer(); System.out.println(customerService.getCustomer()); &#125;&#125; 输出：12jlCustomer&#123;id='001', name='jl'&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>工程</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot开发web应用]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_thymeleaf_demo 静态资源访问js,css,图片等文件，放在main/resources/static里。 页面放在main/resources/templates里。 配置文件内容可以添加在main/resources、application.properties里。 举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/D.jpg。如能显示图片，配置成功。 springboot提供默认配置的一些模版： Thymeleaf FreeMarker Velocity Groovy Mustache 使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。 Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。 示例：1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text="#&#123;msgs.headers.name&#125;"&gt;Name&lt;/td&gt; &lt;th th:text="#&#123;msgs.headers.price&#125;"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="prod : $&#123;allProducts&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Oranges&lt;/td&gt; &lt;td th:text="$&#123;#numbers.formatDecimal(prod.price,1,2)&#125;"&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。12345678910111213141516171819202122232425262728package com.example.demo.web;import com.example.demo.properties.BlobProperties;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;@Controllerpublic class HelloController &#123; @Resource(name = "blobProperties") private BlobProperties blobProperties; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125; @RequestMapping("/") public String index(ModelMap map) &#123; // 加入一个属性，用来在模板中读取 map.addAttribute("host", "http://www.baidu.com"); // return模板文件的名称，对应src/main/resources/templates/index.html return "index"; &#125;&#125; index.html页面：12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;host&#125;"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://blog.baidu.com，做到了不破坏HTML自身内容的数据逻辑分离。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 12345678910111213141516171819# Enable template caching.spring.thymeleaf.cache=true# Check that the templates location exists.spring.thymeleaf.check-template-location=true# Content-Type value.spring.thymeleaf.servlet.content-type=text/html# Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true# Template encoding.spring.thymeleaf.encoding=utf-8# Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names=# Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5# Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/# Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html#spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot热启动]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E7%83%AD%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在pom.xml中的dependencies中添加：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 改build： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 之后reimport，成功之后进行如下设置： 打开idea ，File-&gt;Settings-&gt; Build-Execution-Deployment -&gt; Compiler勾选 Build Project Automatically. 之后按 Shift+Ctrl+A 将看到弹窗 Enter Action or option name，输入”registry”，双击第一项”Registry…” ，会弹出另一个窗口，寻找compiler.automake.allow.when.app.running并且勾选： 之后重启项目，在修改resources文件和java文件时会自动加载或者重启。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：hello world]]></title>
    <url>%2F2018%2F11%2F19%2Fspringboot%EF%BC%9Ahello-world%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_helloworld.git Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 快速入门主要目标是完成Spring Boot基础项目的构建，并且实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 使用Maven构建项目 通过SPRING INITIALIZR工具产生基础项目 访问：http://start.spring.io/ 选择构建工具Maven Project、Spring Boot版本1.3.2以及一些工程基本信息，可参考下图所示点击Generate Project下载项目压缩包 解压项目包，并用IDE以Maven项目导入 菜单中选择File–&gt;New–&gt;Project from Existing Sources 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 选择Java SDK的时候请选择Java 7以上的版本 项目结构 通过上面步骤完成了基础项目的创建，如上图所示，Spring Boot的基础结构共三个文件（具体路径根据用户生成项目时填写的Group所有差异）： src/main/java下的程序入口：Chapter1Application src/main/resources下的配置文件：application.properties src/test/下的测试入口：Chapter1ApplicationTests 生成的Chapter1Application和Chapter1ApplicationTests类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。 其中，@SpringBootApplication的这个注解是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 引入Web模块引入Web模块，需在pom.xml中添加spring-boot-starter-web模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写HelloWorld服务 创建package命名为com.example.demo.web（根据实际情况修改） 创建HelloController类，内容如下 123456789101112package com.exmaple.demo.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 启动主程序（可以在命令行中使用mvn spring-boot:run，或者通过idea启动），打开浏览器访问http://localhost:8080/hello，可以看到页面输出Hello World 编写单元测试用例打开的src/test/下的测试入口Chapter1ApplicationTests类。下面编写一个简单的单元测试来模拟http请求，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.exmaple.demo;import com.exmaple.demo.web.HelloController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.hamcrest.Matchers.equalTo;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)@WebAppConfigurationpublic class Chapter1ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 使用MockServletContext来构建一个空的WebApplicationContext，这样我们创建的HelloController就可以在@Before函数中创建并传递到MockMvcBuilders.standaloneSetup（）函数中。 其中的SpringBootTest注解，原来为SpringApplicationConfiguration，现在已弃用。如果在判断equalTo时判断不一致，会报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243java.lang.AssertionError: Response contentExpected: "Hello World1" but: was "Hello World"Expected :Hello World1Actual :Hello World &lt;Click to see difference&gt; at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) at org.springframework.test.web.servlet.result.ContentResultMatchers.lambda$string$3(ContentResultMatchers.java:130) at org.springframework.test.web.servlet.MockMvc$1.andExpect(MockMvc.java:195) at com.exmaple.demo.Chapter1ApplicationTests.getHello(Chapter1ApplicationTests.java:36) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 打包在 POM 文件添加插件： 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 当运行“mvn package”进行打包时，会打包成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行。 开箱即用模块Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。下面列举一些常用的模块。 spring-boot-starter-logging ：使用 Spring Boot 默认的日志框架 Logback。 spring-boot-starter-log4j ：添加 Log4j 的支持。 spring-boot-starter-web ：支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 spring-boot-starter-tomcat ：使用 Spring Boot 默认的 Tomcat 作为应用服务器。 spring-boot-starter-jetty ：使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-test ：包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-aop ：包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 spring-boot-starter-security ：包含 spring-security。 spring-boot-starter-jdbc ：支持使用 JDBC 访问数据库。 spring-boot-starter-redis ：支持使用 Redis。 spring-boot-starter-data-mongodb ：包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-jpa ：包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-amqp ：通过 spring-rabbit 支持 AMQP。 spring-boot-starter-actuator ： 添加适用于生产环境的功能，如性能指标和监测等功能。 Java Config 自动配置Spring Boot 推荐采用基于 Java Config 的配置方式，而不是传统的 XML。例如，@Configuration、@Bean、@EnableAutoConfiguration、@CompomentScan、@PropertySource、@Repository、@Service、@RestController等。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库处理tips]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86tips%2F</url>
    <content type="text"><![CDATA[1.mysql 开放，关闭 远程授权默认安装mysql是关闭远程连接的 这样也有助于系统的安全 但是有时候需要开启下远程连接方便操作 开启连接 mysql -uroot -p 进入mysql 输入密码1GRANT ALL PRIVILEGES ON * . * TO ‘root’@&apos;%’ IDENTIFIED BY ‘你的mysql密码’ 1WITH GRANT OPTION MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 1MAX_UPDATES_PER_HOUR 0 ; 1flush privileges; 输入这两个命令即可开启mysql远程连接 关闭授权1234REVOKE ALL PRIVILEGES ON *.* FROM root@”%”;USE mysql;DELETE FROM user WHERE User=”root” and Host=”%”;FLUSH PRIVILEGES; 1234567891011121314151617mysql&gt; DELETE FROM `user` WHERE Host='10.155.123.55' AND User='kaka';Query OK, 1 row affected (0.00 sec) mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT Host,User,Password FROM `user`;+----------------+------+-------------------------------------------+| Host | User | Password |+----------------+------+-------------------------------------------+| localhost | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || tony\_ts\_tian | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || 127.0.0.1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || ::1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || % | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 |+----------------+------+-------------------------------------------+5 rows in set (0.00 sec) 2.删除重复数据，只留下唯一不重复1.先多建立一列 temp，用来合并meetingId和speakerId,用“-”连接，之后就判断这一列是否相同。1234567891011121314151617ALTER TABLE cekasp_meeting_speaker ADD temp VARCHAR(20) NULL;update cekasp_meeting_speaker set temp = concat(meetingId, '-', speakerId);delete from cekasp_meeting_speaker where temp in (SELECT * from (SELECT b.temp from cekasp_meeting_speaker b GROUP BY b.temp HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg);ALTER TABLE cekasp_meeting_speaker DROP temp;``` 2.或者直接以meetingId和speakerId作为查询```sqldelete from cekasp_meeting_speaker where (meetingId,speakerId) in (SELECT * from (SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg); 问题：delete/update里，有in的查询语句时，要使用临时表才能进行删除： 原本的1SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1 应该要使用1select * from ... as NAME 包起来，作为一个临时表。 3.两张表表结构一样，将一张表中数据插入另一张表1insert into table1 (SELECT * from table2 WHERE id not in (SELECT id from table1)) 4.查询某张表的信息1select * from information_schema.COLUMNS where TABLE_SCHEMA = (select database()) and TABLE_NAME="paper";]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis简单测试]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[0.准备工具因为配置文件都是读取相同的，所以可以进行工厂类封装。 12345678910111213141516171819202122232425262728package org.fkit.factory;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;public class FKSqlSessionFactory &#123; private static SqlSessionFactory sqlSessionFactory = null; static &#123; try &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125; public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125;&#125; 1.简单的select，insert，update，delete测试在UserMapper.xml中配置：1234567891011121314&lt;insert id="saveUser" parameterType="user" useGeneratedKeys="true"&gt; INSERT INTO tb_user(name, sex, age) VALUES (#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;select id="selectUser" parameterType="int" resultType="user"&gt; SELECT * from tb_user where id = #&#123;id&#125;&lt;/select&gt;&lt;update id="modifyUser" parameterType="user" &gt; UPDATE tb_user set name = #&#123;name&#125;, sex = #&#123;sex&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;&lt;/update&gt;&lt;delete id="removeUser" parameterType="int"&gt; DELETE from tb_user where id=#&#123;id&#125;&lt;/delete&gt; 注：均包含在中。 可以看到，在saveUser和modifyUser中，都是传入的User对象，而在selectUser和removeUser传入的是int值，所以在测试时，需要进行对应。resultType是返回类型，返回User类型，需要使用User user = …获取到该对象，默认返回的是int类型（好像是。。忘记了）。 分别对其进行测试及结果：123456789101112131415//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("jack", "男", 22); sqlSession.insert("org.fkit.mapper.UserMapper.saveUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: INSERT INTO tb_user(name, sex, age) VALUES (?,?,?) DEBUG [main] - ==&gt; Parameters: jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213141516//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); System.out.println(user.getName()); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=1, name='hello?', sex='g', age=11&#125; 12345678910111213141516171819//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); user.setName("hello?"); sqlSession.update("org.fkit.mapper.UserMapper.modifyUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: UPDATE tb_user set name = ?, sex = ?, age = ? WHERE id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), g(String), 11(Integer), 1(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); sqlSession.selectOne("org.fkit.mapper.UserMapper.removeUser", 3); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: DELETE from tb_user where id=? DEBUG [main] - ==&gt; Parameters: 3(Integer) 2.测试ResultMapsresultMap是mybatis中最重要最强大的元素，它的作用是告诉mybatis将从结果集中取出的数据转化成开发者所需要的对象。123456&lt;select id="selectUsersToMap" resultType="map"&gt; SELECT * from tb_user&lt;/select&gt;&lt;select id="selectUsers" resultType="org.fkit.domain.User"&gt; SELECT * from tb_user&lt;/select&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//SelectMapTest.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.User;import org.fkit.factory.FKSqlSessionFactory;import java.util.List;import java.util.Map;public class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取map对象集，每个user映射为一个map List&lt;Map&lt;String, Object&gt;&gt; list = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsersToMap"); for (Map&lt;String, Object&gt; row : list) &#123; System.out.println(row); &#125;// 获取user对象集 List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers"); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12&#123;sex=g, name=hello?, id=1, age=11&#125;&#123;sex=男, name=gg, id=4, age=26&#125;&#123;sex=男, name=gg, id=5, age=26&#125;&#123;sex=男, name=gg, id=6, age=26&#125;&#123;sex=男, name=gg, id=7, age=26&#125;&#123;sex=男, name=gg, id=8, age=26&#125;&#123;sex=男, name=gg, id=9, age=26&#125;&#123;sex=男, name=gg, id=10, age=26&#125;&#123;sex=男, name=gg, id=11, age=26&#125;&#123;sex=男, name=gg, id=12, age=26&#125;&#123;sex=男, name=jack, id=13, age=22&#125;&#123;sex=男, name=jack, id=14, age=22&#125;DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='gg', sex='男', age=26&#125;User&#123;id=13, name='jack', sex='男', age=22&#125;User&#123;id=14, name='jack', sex='男', age=22&#125; 查询语句返回的每一条数据都被封装成了一个Map集合，列名作为Map集合的key，而列的值作为Map的value。 虽然数据被封装成Map集合返回，但是Map集合并不能很好描述一个领域的模型，如果像后一个测试一样，使用POJO类来作为领域模型描述数据，会更加准确。 比较特殊的情况：查询到的数据的列和需要返回的对象（User）的属性不一致，则mybatis不会自动赋值，可以使用resultMap进行处理。 在数据库中创建一个tb_user2表，并且插入一定数据：12345678CREATE TABLE tb_user2( user_id INT AUTO_INCREMENT PRIMARY KEY, user_name VARCHAR(18) NULL, user_sex CHAR(2) NULL, user_age INT NULL) User映射表使用原来的User.java。在UserMapper.xml中添加：12345678910&lt;resultMap id="userResultMap" type="org.fkit.domain.User"&gt; &lt;id property="id" column="user_id"/&gt; &lt;!--column对应数据库中的属性--&gt; &lt;result property="name" column="user_name"/&gt; &lt;result property="sex" column="user_sex"/&gt; &lt;result property="age" column="user_age"/&gt;&lt;/resultMap&gt;&lt;select id="selectUsers2" resultMap="userResultMap"&gt; SELECT * from tb_user2&lt;/select&gt; 测试：1234567891011121314151617//ResultMapTest.javapublic class ResultMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers2"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user2 DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 2User&#123;id=1, name='qq1', sex='q', age=12&#125;User&#123;id=2, name='qq2', sex='b', age=13&#125; （待补充 3.多表查询两个表：123456789101112131415161718192021CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id)) 插入2个班级，4个学生，其中每2个学生对应一个班级。建立pojo类：1234567891011121314public class Clazz &#123; private Integer id; private String code; //setter,getter&#125;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz; //getter,setter UserMapper.xml映射：123456789101112&lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" column="clazz_id" javaType="org.fkit.domain.Clazz" select="selectClazzWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectClazzWithId" resultType="org.fkit.domain.Clazz"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125;&lt;/select&gt; 测试：123456789101112131415161718192021222324252627//SelectStudentTest.javapublic class SelectStudentTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Student&gt; students = sqlSession.selectList("org.fkit.mapper.UserMapper.selectStudent"); for (Student student : students) &#123; System.out.println(student); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_student DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - &lt;== Total: 4Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125; 查询每个班级的学生： 修改clazz.java1234567891011121314public class Clazz &#123; private Integer id; private String code; private List&lt;Student&gt; students; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125;...&#125; UserMapper.xml添加：12345678910111213&lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="selectStudentWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectStudentWithId" resultType="org.fkit.domain.Student"&gt; SELECT * FROM tb_student where clazz_id = #&#123;id&#125;&lt;/select&gt;&lt;select id="selectClazz" resultMap="clazzResultMap"&gt; SELECT * from tb_clazz&lt;/select&gt; 测试：123456789101112131415161718192021222324252627282930313233//SelectClazzTest.javapublic class SelectClazzTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Clazz&gt; clazzes = sqlSession.selectList("org.fkit.mapper.UserMapper.selectClazz"); for (Clazz clazz : clazzes) &#123; System.out.println(clazz); List&lt;Student&gt; students = clazz.getStudents(); for (Student student : students) &#123; System.out.println(student); &#125; &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_clazz DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - &lt;== Total: 2Clazz&#123;id=1, code='j1601'&#125;Student&#123;id=1, name='jack', sex='男', age=22, clazz=null&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=null&#125;Clazz&#123;id=2, code='j1602'&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=null&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=null&#125; 看到student没有clazz属性，应该是不能递归查询。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748CREATE TABLE tb_article( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, price DOUBLE NULL, remark VARCHAR(18) NULL, CONSTRAINT tb_article_id_uindex UNIQUE (id))CREATE TABLE tb_consumer( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(18) NULL, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, phone VARCHAR(18) NULL, address VARCHAR(18) NULL, CONSTRAINT tb_consumer_id_uindex UNIQUE (id))CREATE TABLE tb_order( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(32) NULL, total DOUBLE NULL, user_id INT NULL, CONSTRAINT tb_order_id_uindex UNIQUE (id), CONSTRAINT tb_order_tb_consumer_id_fk FOREIGN KEY (user_id) REFERENCES tb_consumer (id)) ENGINE = InnoDB;CREATE INDEX tb_order_tb_consumer_id_fk ON tb_order (user_id);CREATE TABLE tb_item( order_id INT NOT NULL, amount INT NULL, code VARCHAR(18) NULL, article_id INT NOT NULL, PRIMARY KEY (order_id, article_id)) ENGINE = InnoDB; 其中，consumer和order是一对多关系，一个顾客有多个订单；order和article是多对多的关系，中间表是item，一个订单可以有多个商品，一个商品也可以在多个订单上，所以是多对多关系。POJO类：123456789101112131415161718192021222324252627282930313233//TbConsumer.javapublic class TbConsumer &#123; private long id; private String username; private String loginname; private String password; private String phone; private String address; private List&lt;TbOrder&gt; tbOrders;//setter,getter//TbOrder.javapublic class TbOrder &#123; private long id; private String code; private double total; private long userId; private TbConsumer tbConsumer; private List&lt;TbArticle&gt; articleList;//setter,getter//TbArticle.javapublic class TbArticle &#123; private long id; private String name; private double price; private String remark; private List&lt;TbOrder&gt; tbOrders;//getter,setter 1.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//ConsumerMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ConsumerMapper"&gt; &lt;resultMap id="consumerResultMap" type="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="loginname" column="loginname"/&gt; &lt;result property="password" column="password"/&gt; &lt;result property="phone" column="phone"/&gt; &lt;result property="address" column="address"/&gt; &lt;collection property="tbOrders" javaType="arrayList" column="id" ofType="org.fkit.domain.TbOrder" fetchType="lazy" select="org.fkit.mapper.OrderMapper.selectOrderByConsumerId"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="total" column="total"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectConsumerById" parameterType="int" resultMap="consumerResultMap"&gt; SELECT * from tb_consumer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;//OrderMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.OrderMapper"&gt; &lt;resultMap id="orderResultMap" type="org.fkit.domain.TbOrder"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="total" property="total"/&gt; &lt;result column="code" property="code"/&gt; &lt;association property="tbConsumer" javaType="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="loginname" property="loginname"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;/association&gt; &lt;collection property="articleList" javaType="ArrayList" column="oid" ofType="org.fkit.domain.TbArticle" select="org.fkit.mapper.ArticleMapper.selectArticleByOrderId" fetchType="lazy"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="price" property="price"/&gt; &lt;result property="remark" column="remark"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectOrderById" resultMap="orderResultMap" parameterType="int"&gt; SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectOrderByConsumerId" parameterType="int" resultType="org.fkit.domain.TbOrder"&gt; select * from tb_order where user_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt;//ArticleMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ArticleMapper"&gt; &lt;select id="selectArticleByOrderId" parameterType="int" resultType="org.fkit.domain.TbArticle"&gt; SELECT * from tb_article where id in (select article_id from tb_item where order_id = #&#123;id&#125;) &lt;/select&gt;&lt;/mapper&gt; 因为多表查询返回结果中tb_consumer中有id列，tb_order中也有id列，所以需要区分，例如使o.id as oid，resultMap中的column=”oid”就是指tb_order表中的id值。 相应Java类：12345678910111213public interface ConsumerMapper &#123; TbConsumer selectConsumerById(Integer id);&#125;public interface OrderMapper &#123; TbOrder selectOrderById(Integer id); TbOrder selectOrderByUserId(Integer id);&#125;public interface ArticleMapper &#123; TbArticle selectArticleByOrderId(Integer id);&#125; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ManyToManyTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); ManyToManyTest manyToManyTest = new ManyToManyTest(); manyToManyTest.testSelectUserById(sqlSession); manyToManyTest.testSelectOrderById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectUserById(SqlSession sqlSession) &#123; ConsumerMapper consumerMapper = sqlSession.getMapper(ConsumerMapper.class); TbConsumer tbConsumer = consumerMapper.selectConsumerById(1); System.out.println(tbConsumer); List&lt;TbOrder&gt; tbOrders = tbConsumer.getTbOrders(); for (TbOrder tbOrder : tbOrders) &#123; System.out.println(tbOrder); &#125; &#125; public void testSelectOrderById(SqlSession sqlSession) &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); TbOrder tbOrder = orderMapper.selectOrderById(2); System.out.println(tbOrder); TbConsumer tbConsumer = tbOrder.getTbConsumer(); System.out.println(tbConsumer); List&lt;TbArticle&gt; tbArticles = tbOrder.getArticleList(); for (TbArticle tbArticle : tbArticles) &#123; System.out.println("tbArticle:"); System.out.println(tbArticle); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_consumer where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select * from tb_order where user_id = ?; DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=[TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;, TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;]&#125;TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;DEBUG [main] - ==&gt; Preparing: SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: SELECT * from tb_article where id in (select article_id from tb_item where order_id = ?) DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 2TbOrder&#123;id=1, code='23624', total=1.0, userId=0, tbConsumer=TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;&#125;TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;tbArticle:TbArticle&#123;id=1, name='洗发水', price=23.3, remark='bilibili', tbOrders=null&#125;tbArticle:TbArticle&#123;id=2, name='java书', price=111.0, remark='blingbling', tbOrders=null&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, name VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id))CREATE INDEX TB_STUDENT_tb_clazz_id_fk ON tb_student (clazz_id); 一个clazz对应多个student。 log4j.properties需要进行配置：1234567log4j.rootLogger=ERROR, stdout#log4j.logger.org.fkit.mapper.UserMapper=DEBUGlog4j.logger.org.fkit.mapper=DEBUGlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 在mybatis-config.xml中配置一下mapper和懒加载：12&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt; 配置pojo类：12345678910111213141516171819202122//Student.javapackage org.fkit.domain;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz;//getter,setter//Clazz.javapackage org.fkit.domain;import java.util.List;public class Clazz &#123; private Integer id; private String code; private String name; private List&lt;Student&gt; students;//getter,setter 1.配置StudentMapper和ClazzMapper1234567891011121314151617181920212223242526//StudentMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.StudentMapper"&gt; &lt;select id="selectStudentById" parameterType="int" resultMap="studentResultMap"&gt; SELECT * from tb_clazz c,tb_student s where c.id = s.clazz_id and s.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectStudentByClazzId" parameterType="int" resultMap="studentResultMap"&gt; select * from tb_student where clazz_id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" javaType="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678910//StudentMapper.javapackage org.fkit.mapper;import org.fkit.domain.Student;public interface StudentMapper &#123; Student selectStudentById(Integer id); Student selectStudentByClazzId(Integer id);&#125; 1234567891011121314151617181920212223//ClazzMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ClazzMapper"&gt; &lt;select id="selectClazzById" parameterType="int" resultMap="clazzResultMap"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="org.fkit.mapper.StudentMapper.selectStudentByClazzId" fetchType="lazy"&gt; &lt;id property="studentId" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678//ClazzMapper.javapackage org.fkit.mapper;import org.fkit.domain.Clazz;public interface ClazzMapper &#123; Clazz selectClazzById(Integer id);&#125; 测试代码：1234567891011121314151617181920212223242526272829303132333435363738//OneToMany.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.Clazz;import org.fkit.factory.FKSqlSessionFactory;import org.fkit.mapper.ClazzMapper;public class OneToMany &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); OneToMany oneToMany = new OneToMany(); oneToMany.testSelectClazzById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectClazzById(SqlSession sqlSession) &#123; ClazzMapper clazzMapper = sqlSession.getMapper(ClazzMapper.class); Clazz clazz = clazzMapper.selectClazzById(1); System.out.println(clazz.getId() + " " + clazz.getCode()); System.out.println(clazz.getStudents()); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 11 j1601DEBUG [main] - ==&gt; Preparing: select * from tb_student where clazz_id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2[Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='null', name='jack', students=null&#125;&#125;, Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=2, code='null', name='rose', students=null&#125;&#125;] 可以看出，懒加载会只加载需要使用的(PS:如果做接口，json传数据，则冷加载相当于失效，但是可以在pojo类上加上@JsonIgnoreProperties(“fieldname”)）。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对一]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_card( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(18) NULL, CONSTRAINT tb_card_id_uindex UNIQUE (id))CREATE TABLE tb_person( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, sex VARCHAR(18) NULL, age INT NULL, card_id INT NULL, CONSTRAINT tb_person_id_uindex UNIQUE (id), CONSTRAINT tb_person_card_id_uindex UNIQUE (card_id), CONSTRAINT tb_person_tb_card_id_fk FOREIGN KEY (card_id) REFERENCES tb_card (id)) ENGINE = Inno 身份证和人是一对一的关系，在tb_person表中，card_id为外键，对应tb_card主键，且card_id唯一，就满足了一对一的关系。 2.POJO类 两个pojo类： 12345public class Card implements Serializable&#123; private Integer id; private String code; //getter，setter 12345678public class Person implements Serializable&#123; private Integer id; private String name; private String sex; private Integer age; private Card card; //getter,setter 3.mapper和mybatis-config.xml配置mapper配置：12345678//CardMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.CardMapper"&gt; &lt;select id="selectCardById" parameterType="int" resultType="org.fkit.domain.Card"&gt; SELECT * FROM tb_card WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617//PersonMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.PersonMapper"&gt; &lt;select id="selectPersonById" parameterType="int" resultMap="personMapper"&gt; select * from tb_person where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="personMapper" type="org.fkit.domain.Person"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="card" column="card_id" select="org.fkit.mapper.CardMapper.selectCardById" javaType="org.fkit.domain.Card"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在此可以给PersonMapper设置一个接口：123456789101112//PersonMapper.javapackage org.fkit.mapper;import org.fkit.domain.Person;public interface PersonMapper &#123; /** * @param id * @return Person */ Person selectPersonById(Integer id);&#125; 在mybatis-config.xml中配置这2个mapper：12&lt;mapper resource="org/fkit/mapper/PersonMapper.xml"/&gt;&lt;mapper resource="org/fkit/mapper/CardMapper.xml"/&gt; 4.测试测试代码：12345678910//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); Person person = sqlSession.selectOne("org.fkit.mapper.PersonMapper.selectPersonById", 1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125; 因为设置了接口，也可以如此测试：123456789101112131415//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); PersonMapper personMapper = session.getMapper(PersonMapper.class); Person person = personMapper.selectPersonById(1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册登录测试]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.domain2.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping("/user")public class UserController &#123; private static List&lt;User&gt; userList; public UserController() &#123; super(); userList = new ArrayList&lt;User&gt;(); &#125; private static Log logger = LogFactory.getLog(UserController.class); @RequestMapping(value = "/register", method = RequestMethod.GET) public String requireForm() &#123; logger.info("register GET被调用"); System.out.println("register GET被调用"); return "registerForm"; &#125; @RequestMapping(value = "/register", method = RequestMethod.POST) public String register( @RequestParam("loginname") String loginname, @RequestParam("password") String password, @RequestParam("username") String username) &#123; logger.info("register POST被调用"); System.out.println("register POST被调用"); User user = new User(); user.setLoginname(loginname); user.setUsername(username); user.setPassword(password); userList.add(user); System.out.println(userList); return "loginForm"; &#125; @RequestMapping("/login") public String login( @RequestParam("loginname") String loginname, @RequestParam("password") String password, Model model)&#123; logger.info("登录名" + loginname + " 密码" + password); for (User user : userList) &#123; if (user.getLoginname().equals(loginname) &amp;&amp; user.getPassword().equals(password)) &#123; model.addAttribute("user", user); return "welcome"; &#125; &#125; return "loginForm"; &#125;&#125; springmvc-config2.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean name="/hello" class="org.fkit.controller.HelloController"/&gt;--&gt; &lt;context:component-scan base-package="org.fkit.controller"/&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;value&gt;/WEB-INF/content/&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-config2.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathVariable，RequestHeader，CookieValue注解测试]]></title>
    <url>%2F2018%2F11%2F14%2FPathVariable%EF%BC%8CRequestHeader%EF%BC%8CCookieValue%E6%B3%A8%E8%A7%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DataBindingController &#123; private static final Log logger = LogFactory.getLog(DataBindingController.class); @RequestMapping(value = "/pathVariableTest/&#123;userId&#125;") public void pathVariableTest(@PathVariable Integer userId) &#123; logger.info("通过@PathVariable获得的数据：" + userId); &#125; @RequestMapping(value = "/requestHeaderTest") public void requestHeaderTest( @RequestHeader("User-Agent") String userAgent, @RequestHeader(value = "Accept") String[] accepts) &#123; logger.info("通过@requestHeaderTest获得的数据:" + userAgent); for (String accept : accepts) &#123; logger.info(accept); &#125; &#125; @RequestMapping(value = "/cookieValueTest") public void cookieValueTest( @CookieValue(value = "JSESSIONID", defaultValue = "") String sessionId) &#123; logger.info("通过@CookieValue获得的数据：" + sessionId); &#125; @RequestMapping(value = "/testWebsite") public String testWebsite()&#123; return "index"; &#125;&#125; jsp:1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: 34924 Date: 2018/8/1 Time: 22:40 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/pathVariableTest/1"&gt;测试注解1&lt;/a&gt;&lt;br&gt;&lt;a href="/requestHeaderTest"&gt;注解2&lt;/a&gt;&lt;br&gt;&lt;a href="/cookieValueTest"&gt;注解3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4.properties配置]]></title>
    <url>%2F2018%2F11%2F14%2Flog4-properties%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[放在WEB-INF的目录下：123456789101112131415161718192021222324# Logging levelsolr.log=$&#123;solr.solr.home&#125;/../logslog4j.rootLogger=INFO, filelog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%-4r [%t] %-5p %c %x \u2013 %m%n#- size rotation with log cleanup.log4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.MaxFileSize=4MBlog4j.appender.file.MaxBackupIndex=9#- File to log to and log formatlog4j.appender.file.File=$&#123;solr.log&#125;/solr.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%-5p - %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;; %C; %m\nlog4j.logger.org.apache.zookeeper=WARNlog4j.logger.org.apache.hadoop=WARN# set to INFO to enable infostream log messageslog4j.logger.org.apache.solr.update.LoggingInfoStream=OFF 在web.xml中配置：12345678910&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <categories>
        <category>日志配置</category>
      </categories>
      <tags>
        <tag>日志配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的router路由跳转获取url参数方法]]></title>
    <url>%2F2018%2F11%2F14%2Freact%E7%9A%84route%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[例如一个页面分为三块，导航栏，左栏右栏，左栏为页面跳转，右栏为显示list页面或者detail页面，如下所示： 如果使用如下代码进行路由，url改变了，但是接收不到：12345678910&lt;div className='content-right'&gt; &lt;Layout.Content &gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path='/development/list' component=&#123;Com_dev_list&#125; /&gt; &lt;Route path="/development/list:type" component=&#123;Com_dev_list&#125; /&gt; &lt;Route path='/development/detail:id' component=&#123;Com_dev_detail&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Layout.Content&gt; 使用component接收：12345678910componentWillReceiveProps(nextProps)&#123; axios.get(host + 'development/list/' + nextProps.match.params.type.replace(":type=","") +'/' +1).then( response =&gt; &#123; let items = response.data; items = items.list; this.setState(&#123;list:items&#125;); window.scrollTo(0, 0) &#125; );&#125; 实际上nextProps.match.params.type.replace(“:type=”,””)并未接收到url每次的改变，需要使用window.location.href，这样每次都可以接收到。但是是否真的这么暴力美学，还需要进行之后的学习。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解写法]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E6%B3%A8%E8%A7%A3%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.普通增删改查使用表：User在mybatis-config.xml里配置1&lt;mapper class="org.fkit.mapper.UserMapper"/&gt; 注释掉原来的xml配置路径。注解java类：123456789101112131415161718192021222324252627282930313233//UserMapper.javapackage org.fkit.mapper;import org.apache.ibatis.annotations.*;import org.fkit.domain.Clazz;import org.fkit.domain.User;import java.util.List;public interface UserMapper &#123; @Insert("insert into tb_user(name,sex,age) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)") @Options(useGeneratedKeys = true, keyProperty = "id") int saveUser(User user); @Delete("delete from tb_user where id = #&#123;id&#125; or name = #&#123;cctv&#125;") int removeUser(@Param("id") Integer id, @Param("cctv") String n); @Update("update tb_user set name = #&#123;name&#125;,sex = #&#123;sex&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;") void modifyUser(User user); @Select("select * from tb_user where id = #&#123;id&#125;") @Results(&#123; @Result(id = true, column = "id", property = "id"), @Result(column = "name", property = "name"), @Result(column = "sex", property = "sex"), @Result(column = "age", property = "age") &#125;) User selectUserById(Integer id); @Select("select * from tb_user") List&lt;User&gt; selectAllUser();&#125; 测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("1111jack", "男", 22); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.saveUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: insert into tb_user(name,sex,age) values(?,?,?) DEBUG [main] - ==&gt; Parameters: 1111jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.removeUser(16,"jack"); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: delete from tb_user where id = ? or name = ? DEBUG [main] - ==&gt; Parameters: 16(Integer), jack(String)DEBUG [main] - &lt;== Updates: 1//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); user.setName("hello?"); userMapper.modifyUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: update tb_user set name = ?,sex = ?, age = ? where id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), 男(String), 26(Integer), 12(Integer)DEBUG [main] - &lt;== Updates: 1//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); System.out.println(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=12, name='hello?', sex='男', age=26&#125;//SelectMapTest.javapublic class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取user对象集 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAllUser(); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 10User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='hello?', sex='男', age=26&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mabatis逆向工程]]></title>
    <url>%2F2018%2F11%2F13%2Fmabatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文使用idea编译器，安装Mybatisplus插件后可以使用逆向工程。 配置：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" &gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="C:/Users/34924/Desktop/mysql-connector-java-5.1.46.jar"/&gt; &lt;context id="context" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;property name="suppressDate" value="false"/&gt; &lt;/commentGenerator&gt; &lt;!--&lt;jdbcConnection userId="root" password="123456" driverClass="com.mysql.jdbc.Driver"--&gt; &lt;!--connectionURL="jdbc:mysql://localhost:3306/sss"/&gt;--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="org.model" targetProject="."&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="org.mapper" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="org.mapper" type="MIXEDMAPPER" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;table schema="sn349245467" tableName="polls_question" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;table schema="sn349245467" tableName="polls_choice" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注意：jdbc版本最好用5.x左右的，targetRuntime使用Mybatis3，使用简略版的会少东西。javaClientGenerator的type选用MIXEDMAPPER。 使用了逆向工程后，在一对多等关系的时候，需要把默认的查找方式由select param1,param2,…改为select *，以及改resultMap的BaseResultMap。]]></content>
      <categories>
        <category>java</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>java</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea创建maven项目时显示“Loading archetype list ”]]></title>
    <url>%2F2018%2F11%2F13%2Fidea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%98%BE%E7%A4%BA%E2%80%9CLoading%20archetype%20list%20%E2%80%9D%2F</url>
    <content type="text"><![CDATA[本文参考https://blog.csdn.net/u011403655/article/details/46843331 1.idea创建maven项目时一直显示“Loading archetype list ”删除{User_Home}/.IntelliJIdea{Version}/system/Maven/Indices下面的文件，然后重启idea。 2.IntelliJ IDEA 创建maven-archetype-webapp超时问题 File -&gt; Other Settings -&gt; Default Settings… Build, Execution, Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner, 在VM Options中填写如下 -DarchetypeCatalog=internal Apply -&gt; OK即可 3.创建完项目后命令行卡在 [INFO] Generating project in Batch modeMaven命令执行到Generating Project in Batch mode 卡住，原因是网络带宽不足，需要下载一个约4.1M的archetype-catalog.xml文件。 在maven的五分钟入门里面，有这样一个命令： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false这句话的命令是创建一个默认的项目，但我在执行这个命令时，命令行会停在 [INFO] Generating project in Batch mode这句话会停很久。【当然，也有人的一下就过去。】 增加一个-X参数，可以查看详细信息1mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -X 可以看到，程序停在了下面这一行。1[DEBUG] Searching for remote catalog: http://repo1.maven.org/maven2/archetype-catalog.xml 去查询这个文件的时候网络比较差或者其他原因，导致挂在那里。 解决方法很简单。 把上述地址复制到浏览器中，下载这个文件到本地。 把文件archetype-catalog.xml复制到目录.m2\repository\org\apache\maven\archetype\archetype-catalog\2.2下面。 在上述命令后增加参数-DarchetypeCatalog=local，变成读取本地文件即可。4.庆祝一下123456789101112131415161718192021[INFO] ----------------------------------------------------------------------------[INFO] Using following parameters for creating project from Archetype: maven-archetype-webapp:RELEASE[INFO] ----------------------------------------------------------------------------[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: packageInPathFormat, Value: com/ssm/study[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Project created from Archetype in dir: C:\Users\34924\AppData\Local\Temp\archetypetmp\ssmframe[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 16:09 min[INFO] Finished at: 2018-07-20T21:16:52+08:00[INFO] Final Memory: 12M/87M[INFO] ------------------------------------------------------------------------[INFO] Maven execution finished]]></content>
      <categories>
        <category>Maven</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态sql]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E7%9A%84%E5%8A%A8%E6%80%81sql%2F</url>
    <content type="text"><![CDATA[本文是关于mybatis的早期使用方法。 0.前期准备123456789101112131415CREATE TABLE tb_employee( id INT AUTO_INCREMENT PRIMARY KEY, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, name VARCHAR(18) NULL, sex CHAR(2) NULL, age INT NULL, phone VARCHAR(21) NULL, sal DOUBLE NULL, state VARCHAR(18) NULL, CONSTRAINT tb_employee_id_uindex UNIQUE (id)) POJO类：123456789101112public class TbEmployee &#123; private long id; private String loginname; private String password; private String name; private String sex; private long age; private String phone; private double sal; private String state;//getter,setter 1.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.EmployeeMapper"&gt; &lt;select id="selectEmployeeByIdLike" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee &lt;where&gt; &lt;if test="id != null"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeChoose" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee &lt;where&gt; &lt;choose&gt; &lt;when test="id != null"&gt; and id = #&#123;id&#125; &lt;/when&gt; &lt;when test="loginname != null and password != null"&gt; and loginname = #&#123;loginname&#125; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and sex = '1' &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeWithId" parameterType="int" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;update id="updateEmployeeIfNecessary" parameterType="org.fkit.domain.TbEmployee"&gt; UPDATE tb_employee &lt;set&gt; &lt;if test="loginname != null"&gt;loginname = #&#123;loginname&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="sex != null"&gt;sex = #&#123;sex&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;if test="phone != null"&gt;phone = #&#123;phone&#125;,&lt;/if&gt; &lt;if test="sal != null"&gt;sal = #&#123;sal&#125;,&lt;/if&gt; &lt;if test="state != null"&gt;state = #&#123;state&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id="selectEmployeeIn" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee where id in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;select id="selectEmployeeLikeName" resultType="org.fkit.domain.TbEmployee"&gt; &lt;bind name="pattern" value="'%' + _parameter.getName() + '%'"/&gt; &lt;bind name="pattern2" value="'%' + _parameter.getLoginname() +'%' "/&gt; SELECT * FROM tb_employee where name like #&#123;pattern&#125; and loginname like #&#123;pattern2&#125; &lt;/select&gt;&lt;/mapper&gt; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class DynamicSQLTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); DynamicSQLTest dynamicSQLTest = new DynamicSQLTest(); dynamicSQLTest.testSelectEmployeeByIdLike(sqlSession); dynamicSQLTest.testSelectEmployeeChoose(sqlSession); dynamicSQLTest.testUpdateEmployeeIfNecessary(sqlSession); dynamicSQLTest.testSelectEmployeeIn(sqlSession); dynamicSQLTest.testSelectEmployeeLikeName(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectEmployeeByIdLike(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("id", 1); params.put("sex", 1); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeByIdLike(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeChoose(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginname", "jack"); params.put("password", "123"); params.put("id", 2); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeChoose(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testUpdateEmployeeIfNecessary(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = employeeMapper.selectEmployeeWithId(1); System.out.println(tbEmployee); tbEmployee.setLoginname("newJack"); employeeMapper.updateEmployeeIfNecessary(tbEmployee); &#125; public void testSelectEmployeeIn(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); integers.add(1); integers.add(3); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeIn(integers); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeLikeName(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = new TbEmployee(); tbEmployee.setName("a"); tbEmployee.setLoginname("J"); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeLikeName(tbEmployee); tbEmployees.forEach(tbEmployee1 -&gt; System.out.println(tbEmployee1)); &#125;&#125; 12345678910111213141516171819202122232425//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee WHERE id = ? and sex = ? DEBUG [main] - ==&gt; Parameters: 1(Integer), 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: select * from tb_employee WHERE id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=2, loginname='rose', password='456', name='rooose', sex='2', age=21, phone='654321', sal=1121.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: UPDATE tb_employee SET loginname = ?, password = ?, name = ?, sex = ?, age = ?, phone = ?, sal = ?, state = ? where id = ? DEBUG [main] - ==&gt; Parameters: newJack(String), 123(String), jaccck(String), 1(String), 26(Long), 123456(String), 3211.0(Double), active(String), 1(Long)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - ==&gt; Preparing: select * from tb_employee where id in ( ? , ? ) DEBUG [main] - ==&gt; Parameters: 1(Integer), 3(Integer)DEBUG [main] - &lt;== Total: 2TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;TbEmployee&#123;id=3, loginname='tom', password='tom', name='tooom', sex='1', age=12, phone='132', sal=32.2, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where name like ? and loginname like ? DEBUG [main] - ==&gt; Parameters: %a%(String), %J%(String)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125; 使用like的另一种写法：123456789101112&lt;select id="getUsersByConditionIf" resultType="com.model.User" parameterType="com.model.User"&gt; select * from user where &lt;if test="id!=null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username !=''"&gt; or username like "%"#&#123;username&#125;"%" &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 使用”%”#{parameter}”%”，运行结果如下：1234567891011DEBUG [main] - ==&gt; Preparing: select id, username,birthday, sex, address,dept_id from user where id = ? DEBUG [main] - ==&gt; Parameters: 27(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select id, name from department where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;DEBUG [main] - ==&gt; Preparing: select * from user where id = ? or username like "%"?"%" and sex = ? DEBUG [main] - ==&gt; Parameters: 27(Integer), 1(String), 1(String)DEBUG [main] - &lt;== Total: 2[User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;, User&#123;id=32, username='11231', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;] 要使每个都写为and xxx= #{xx}的形式，而不是第一个需要去掉and，可以在sql前面的语句中写为1select * from xxx where 1=1 这样保证每个都可以写为and xxx = #{xx}的形式。 也可以使用where标签将所有拼接的动态条件放入。 但是where只能去掉第一个and。 一次更新多条数据：1void addUsers(@Param("userList") List&lt;User&gt; userList); 123456&lt;insert id="addUsers" &gt; insert into user(username,address) VALUES &lt;foreach collection="userList" item="user" separator=","&gt; (#&#123;user.username&#125;,#&#123;user.address&#125;) &lt;/foreach&gt;&lt;/insert&gt; 需要插入别的字段需要自己加入。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范数]]></title>
    <url>%2F2018%2F11%2F13%2F%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[p-范数: $||x||_p = (|x_1|^p + |x_2|^p + |x_3|^3 + … + |x_n|^p)^{1/p} =\sqrt[p]{ \sum_{i=1}^n|x_i|^p}$ 2-范数(欧式范数): $||x||_2 = (|x_1|^2 + |x_2|^2 + |x_3|^2 + … + |x_n|^2)^{1/2} = \sqrt{ \sum_{i=1}^n x_i^2}$ ∞-范数: $||x||_∞ = max(x_1,x_2,x_3,…,x_n) = max_i|x_i|$ 1-范数即向量元素绝对值之和； 2-范数为Euclid范数（欧几里得范数，常用计算向量长度），即向量元素绝对值的平方和再开方； ∞-范数即所有向量元素绝对值中的最大值； -∞-范数即所有向量元素绝对值中的最小值； p-范数即向量元素绝对值的p次方和的1/p次幂。 可以参考：https://blog.csdn.net/susanzhang1231/article/details/52127011 https://www.jianshu.com/p/bf860ad177dd https://blog.csdn.net/bitcarmanlee/article/details/51945271]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>范数</tag>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
</search>
