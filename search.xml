<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu：使用nohup和&进行后台运行，进程查看和终止]]></title>
    <url>%2F2018%2F12%2F12%2FUbuntu%EF%BC%9A%E4%BD%BF%E7%94%A8nohup%E5%92%8C-%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%BB%88%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[nohup用途：不挂断地运行命令。 语法：nohup Command [ Arg … ][ &amp; ] 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。 如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。 如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。 退出状态：该命令返回下列出口值： 126 可以查找但不能调用 Command 参数指定的命令。 127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。 &amp;用途：在后台运行 一般两个一起用 1nohup command &amp; 例如 1nohup command &gt; myout.file 2&gt;&amp;1 在上面的例子中，输出被重定向到myout.file文件中。 nohup与&amp;的区别：nohup只是让命令忽略SIGHUP命令而已；&amp;则让命令在后台运行，至于该命令是否能在脱离终端后继续执行则要看进程是否是守护进程，如果不是，则需要nohup来帮忙。 查看某个端口的进程1lsof -i:80 结果： 123COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 27295 root 19u IPv4 527052 0t0 TCP *:http (LISTEN)node 27295 root 24u IPv4 528732 0t0 TCP ubuntu:http-&gt;xxx.xxx.xxx.xxx:50367 (ESTABLISHED) 终止后台运行的进程1kill -9 PID pid为进程号。 nohup不产生日志1nohup java -jar item-2.0.1-SNAPSHOT.jar 2 &gt;error.log &amp; 0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出。 在一般使用时，默认的是标准输出，既1.当我们需要特殊用途时，可以使用其他标号。例如，将program.sh的错误信息输出到log文件中： 1./program.sh 2&gt;log 这样标准输出还是在屏幕上，但是错误信息会输出到log文件中。另外，也可以实现0，1，2之间的重定向。 2&gt;&amp;1：将错误信息重定向到标准输出。 Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： 1ls 1&gt;/dev/null 2&gt;/dev/null 这样不会有任何输出。 1lsss 1&gt;/dev/null 因为lsss不是一条合法命令，但是使用的是1（标准输入），所以还是会报错； 1lsss 2&gt;/dev/null 使用2（标准错误信息输出），输出的错误会被吞掉，所以不会有任何输出； 1ls 1&gt;/dev/null ls是标准命令，但是使用1吞掉了标准输出，所以不会有任何输出。 还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如： 1ls &gt;/dev/null 2&gt;&amp;1 注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-) 由于使用nohup时，会自动将输出写入nohup.out文件中，如果文件很大的话，nohup.out就会不停的增大，这是我们不希望看到的，因此，可以利用/dev/null来解决这个问题。 1nohup ./program.sh &gt;/dev/null 2&gt;log &amp; 这样在跑程序的时候，只将错误信息输出到log文件中。 如果什么信息都不要，使用 1nohup ./program.sh &gt;/dev/null 2&gt;&amp;1 &amp; (好像没用？)]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>nohup</tag>
        <tag>安全守护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu：安装npm和node]]></title>
    <url>%2F2018%2F12%2F12%2FUbuntu%EF%BC%9A%E5%AE%89%E8%A3%85npm%E5%92%8Cnode%2F</url>
    <content type="text"><![CDATA[安装安装nodejs： 1sudo apt-get install nodejs-legacy 安装npm： 1sudo apt-get install npm nodejs和npm更新npm更新： 1npm update -g 更新Nodejs自身： 12npm install -g n n latest 使用npm -v和node -v查看版本号。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu：修改root密码]]></title>
    <url>%2F2018%2F12%2F12%2FUbuntu%EF%BC%9A%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[安装完系统后可以设置root密码，输入 1sudo root 可以创建root的密码。 修改root密码： 1sudo passwd root]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu：安装java]]></title>
    <url>%2F2018%2F12%2F12%2FUbuntu%EF%BC%9A%E5%AE%89%E8%A3%85java%2F</url>
    <content type="text"><![CDATA[通过apt-get 的方式安装jdk1sudo apt-get update //sudo表示超级用户，如果是在root用户下可以不写 1sudo apt-get install openjdk-8-jdk 安装完后的目录在：/usr/lib/jvm/java-8-openjdk-amd64echo $JAVA_HOME，没有结果；javac -version可以显示版本。 然后配置JAVA_HOME,JRE_HOME,PATH，配置文件的位置：/etc/profile在内容中加入下面的： 1234export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 执行完之后，source /etc/profile ，使变动生效，不需用重启 用echo $JAVA_HOME检查是否配置成功javac不成功显示 123456789The program &apos;javac&apos; can be found in the following packages: * default-jdk * ecj * gcj-5-jdk * openjdk-8-jdk-headless * gcj-4.8-jdk * gcj-4.9-jdk * openjdk-9-jdk-headlessTry: apt install &lt;selected package&gt; 使用命令apt install default-jdk即可。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：项目启动时初始化资源]]></title>
    <url>%2F2018%2F12%2F12%2Fspringboot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.CommandLineRunner.git 在我们实际工作中，总会遇到这样需求，在项目启动的时候需要做一些初始化的操作，比如初始化线程池，提前加载好加密证书等。今天就给大家介绍一个 Spring Boot 神器，专门帮助大家解决项目启动初始化资源操作。 这个神器就是 CommandLineRunner，CommandLineRunner 接口的 Component 会在所有 Spring Beans 都初始化之后，SpringApplication.run() 之前执行，非常适合在应用程序启动之初进行一些数据初始化的工作。 接下来我们就运用案例测试它如何使用，在测试之前在启动类加两行打印提示，方便我们识别 CommandLineRunner 的执行时机。 12345678@SpringBootApplicationpublic class CommandLineRunnerApplication &#123; public static void main(String[] args) &#123; System.out.println("The service to start."); SpringApplication.run(CommandLineRunnerApplication.class, args); System.out.println("The service has started."); &#125;&#125; 接下来我们直接创建一个类继承 CommandLineRunner ，并实现它的 run() 方法。 1234567@Componentpublic class Runner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("The Runner start to initialize ..."); &#125;&#125; 我们在 run() 方法中打印了一些参数来看出它的执行时机。完成之后启动项目进行测试： 123456789101112131415...The service to start. . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.0.RELEASE)...2018-04-21 22:21:34.706 INFO 27016 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &apos;&apos;2018-04-21 22:21:34.710 INFO 27016 --- [ main] com.neo.CommandLineRunnerApplication : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)The Runner start to initialize ...The service has started. 根据控制台的打印信息我们可以看出 CommandLineRunner 中的方法会在 Spring Boot 容器加载之后执行，执行完成后项目启动完成。 如果我们在启动容器的时候需要初始化很多资源，并且初始化资源相互之间有序，那如何保证不同的 CommandLineRunner 的执行顺序呢？Spring Boot 也给出了解决方案。那就是使用 @Order 注解。 我们创建两个 CommandLineRunner 的实现类来进行测试： 第一个实现类： 12345678@Component@Order(1)public class OrderRunner1 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("The OrderRunner1 start to initialize ..."); &#125;&#125; 第二个实现类： 12345678@Component@Order(2)public class OrderRunner2 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("The OrderRunner2 start to initialize ..."); &#125;&#125; 添加完成之后重新启动，观察执行顺序： 1234567891011121314151617...The service to start. . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.0.RELEASE)...2018-04-21 22:21:34.706 INFO 27016 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &apos;&apos;2018-04-21 22:21:34.710 INFO 27016 --- [ main] com.neo.CommandLineRunnerApplication : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)The OrderRunner1 start to initialize ...The OrderRunner2 start to initialize ...The Runner start to initialize ...The service has started. 通过控制台的输出我们发现，添加 @Order 注解的实现类最先执行，并且@Order()里面的值越小启动越早。 在实践中，使用ApplicationRunner也可以达到相同的目的，两着差别不大。看来使用 Spring Boot 解决初始化资源的问题非常简单。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：单元测试]]></title>
    <url>%2F2018%2F12%2F12%2Fspringboot%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.exception.git 这次来介绍下Spring Boot中对单元测试的整合使用，本篇会通过以下4点来介绍，基本满足日常需求 Service层单元测试 Controller层单元测试 新断言assertThat使用 单元测试的回滚 Spring Boot中引入单元测试很简单，依赖如下：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 本篇实例Spring Boot版本为1.5.9.RELEASE，引入spring-boot-starter-test后，有如下几个库： JUnit — The de-facto standard for unit testing Java applications. Spring Test &amp; Spring Boot Test — Utilities and integration test support for Spring Boot applications. AssertJ — A fluent assertion library. Hamcrest — A library of matcher objects (also known as constraints or predicates). Mockito — A Java mocking framework. JSONassert — An assertion library for JSON. JsonPath — XPath for JSON. Service单元测试Spring Boot中单元测试类写在在src/test/java目录下，你可以手动创建具体测试类，如果是IDEA，则可以通过IDEA自动创建测试类，如下图，也可以通过快捷键⇧⌘T(MAC)或者Ctrl+Shift+T(Window)来创建，如下： 自动生成测试类如下： 然后再编写创建好的测试类，具体代码如下： 1234567891011121314151617181920212223package com.dudu.service;import com.dudu.domain.LearnResource;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import static org.hamcrest.CoreMatchers.*;@RunWith(SpringRunner.class)@SpringBootTestpublic class LearnServiceTest &#123; @Autowired private LearnService learnService; @Test public void getLearn()&#123; LearnResource learnResource=learnService.selectByKey(1001L); Assert.assertThat(learnResource.getAuthor(),is("嘟嘟MD独立博客")); &#125;&#125; 上面就是最简单的单元测试写法，顶部只要@RunWith(SpringRunner.class)和SpringBootTest即可，想要执行的时候，鼠标放在对应的方法，右键选择run该方法即可。 测试用例中我使用了assertThat断言，下文中会介绍，也推荐大家使用该断言。 Controller单元测试上面只是针对Service层做测试，但是有时候需要对Controller层（API）做测试，这时候就得用到MockMvc了，你可以不必启动工程就能测试这些接口。 MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 Controller类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.dudu.controller;/** 教程页面 * Created by tengj on 2017/3/13. */@Controller@RequestMapping("/learn")public class LearnController extends AbstractController&#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn(Model model)&#123; model.addAttribute("ctx", getContextPath()+"/"); return "learn-resource"; &#125; /** * 查询教程列表 * @param page * @return */ @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST) @ResponseBody public AjaxObject queryLearnList(Page&lt;LeanQueryLeanListReq&gt; page)&#123; List&lt;LearnResource&gt; learnList=learnService.queryLearnResouceList(page); PageInfo&lt;LearnResource&gt; pageInfo =new PageInfo&lt;LearnResource&gt;(learnList); return AjaxObject.ok().put("page", pageInfo); &#125; /** * 新添教程 * @param learn */ @RequestMapping(value = "/add",method = RequestMethod.POST) @ResponseBody public AjaxObject addLearn(@RequestBody LearnResource learn)&#123; learnService.save(learn); return AjaxObject.ok(); &#125; /** * 修改教程 * @param learn */ @RequestMapping(value = "/update",method = RequestMethod.POST) @ResponseBody public AjaxObject updateLearn(@RequestBody LearnResource learn)&#123; learnService.updateNotNull(learn); return AjaxObject.ok(); &#125; /** * 删除教程 * @param ids */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public AjaxObject deleteLearn(@RequestBody Long[] ids)&#123; learnService.deleteBatch(ids); return AjaxObject.ok(); &#125; /** * 获取教程 * @param id */ @RequestMapping(value="/resource/&#123;id&#125;",method = RequestMethod.GET) @ResponseBody public LearnResource qryLearn(@PathVariable(value = "id") Long id)&#123; LearnResource lean= learnService.selectByKey(id); return lean; &#125;&#125; 这里我们也自动创建一个Controller的测试类，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.dudu.controller;import com.dudu.domain.User;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockHttpSession;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringRunner.class)@SpringBootTestpublic class LearnControllerTest &#123; @Autowired private WebApplicationContext wac; private MockMvc mvc; private MockHttpSession session; @Before public void setupMockMvc()&#123; mvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 session = new MockHttpSession(); User user =new User("root","root"); session.setAttribute("user",user); //拦截器那边会判断用户是否登录，所以这里注入一个用户 &#125; /** * 新增教程测试用例 * @throws Exception */ @Test public void addLearn() throws Exception&#123; String json="&#123;\"author\":\"HAHAHAA\",\"title\":\"Spring\",\"url\":\"http://tengj.top/\"&#125;"; mvc.perform(MockMvcRequestBuilders.post("/learn/add") .accept(MediaType.APPLICATION_JSON_UTF8) .content(json.getBytes()) //传json参数 .session(session) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()); &#125; /** * 获取教程测试用例 * @throws Exception */ @Test public void qryLearn() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/learn/resource/1001") .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaType.APPLICATION_JSON_UTF8) .session(session) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath("$.author").value("嘟嘟MD独立博客")) .andExpect(MockMvcResultMatchers.jsonPath("$.title").value("Spring Boot干货系列")) .andDo(MockMvcResultHandlers.print()); &#125; /** * 修改教程测试用例 * @throws Exception */ @Test public void updateLearn() throws Exception&#123; String json="&#123;\"author\":\"测试修改\",\"id\":1031,\"title\":\"Spring Boot干货系列\",\"url\":\"http://tengj.top/\"&#125;"; mvc.perform(MockMvcRequestBuilders.post("/learn/update") .accept(MediaType.APPLICATION_JSON_UTF8) .content(json.getBytes())//传json参数 .session(session) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()); &#125; /** * 删除教程测试用例 * @throws Exception */ @Test public void deleteLearn() throws Exception&#123; String json="[1031]"; mvc.perform(MockMvcRequestBuilders.post("/learn/delete") .accept(MediaType.APPLICATION_JSON_UTF8) .content(json.getBytes())//传json参数 .session(session) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()); &#125;&#125; 上面实现了基本的增删改查的测试用例，使用MockMvc的时候需要先用MockMvcBuilders使用构建MockMvc对象，如下 1234567@Beforepublic void setupMockMvc()&#123; mvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 session = new MockHttpSession(); User user =new User("root","root"); session.setAttribute("user",user); //拦截器那边会判断用户是否登录，所以这里注入一个用户&#125; 因为拦截器那边会判断是否登录，所以这里我注入了一个用户，你也可以直接修改拦截器取消验证用户登录，先测试完再开启。 这里拿一个例子来介绍一下MockMvc简单的方法12345678910111213141516/** * 获取教程测试用例 * @throws Exception */@Testpublic void qryLearn() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/learn/resource/1001") .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaType.APPLICATION_JSON_UTF8) .session(session) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath("$.author").value("嘟嘟MD独立博客")) .andExpect(MockMvcResultMatchers.jsonPath("$.title").value("Spring Boot干货系列")) .andDo(MockMvcResultHandlers.print());&#125; mockMvc.perform执行一个请求 MockMvcRequestBuilders.get(“/user/1”)构造一个请求，Post请求就用.post方法 contentType(MediaType.APPLICATION_JSON_UTF8)代表发送端发送的数据格式是application/json;charset=UTF-8 accept(MediaType.APPLICATION_JSON_UTF8)代表客户端希望接受的数据类型为application/json;charset=UTF-8 session(session)注入一个session，这样拦截器才可以通过 ResultActions.andExpect添加执行完成后的断言 ResultActions.andExpect(MockMvcResultMatchers.status().isOk())方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过 andExpect(MockMvcResultMatchers.jsonPath(“$.author”).value(“嘟嘟MD独立博客”))这里jsonPath用来获取author字段比对是否为嘟嘟MD独立博客,不是就测试不通过 ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息 本例子测试如下： mockMvc 更多例子可以本篇下方参考查看 新断言assertThat使用JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想，我们引入的版本是Junit4.12所以支持assertThat。 assertThat 的基本语法如下：清单 1 assertThat 基本语法1assertThat( [value], [matcher statement] ); value 是接下来想要测试的变量值； matcher statement 是使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。 assertThat 的优点 优点 1：以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。 优点 2：assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。如清单 2 所示： 清单 2 使用匹配符 Matcher 和不使用之间的比较123456// 想判断某个字符串 s 是否含有子字符串 "developer" 或 "Works" 中间的一个// JUnit 4.4 以前的版本：assertTrue(s.indexOf("developer")&gt;-1||s.indexOf("Works")&gt;-1 );// JUnit 4.4：assertThat(s, anyOf(containsString("developer"), containsString("Works"))); // 匹配符 anyOf 表示任何一个条件满足则成立，类似于逻辑或 "||"， 匹配符 containsString 表示是否含有参数子 // 字符串，文章接下来会对匹配符进行具体介绍 优点 3：assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。 优点 4：可以将这些 Matcher 匹配符联合起来灵活使用，达到更多目的。如清单 3 所示： 清单 3 Matcher 匹配符联合使用123456// 联合匹配符not和equalTo表示“不等于”assertThat( something, not( equalTo( "developer" ) ) ); // 联合匹配符not和containsString表示“不包含子字符串”assertThat( something, not( containsString( "Works" ) ) ); // 联合匹配符anyOf和containsString表示“包含任何一个子字符串”assertThat(something, anyOf(containsString("developer"), containsString("Works"))); 优点 5：错误信息更加易懂、可读且具有描述性（descriptive）JUnit 4.4 以前的版本默认出错后不会抛出额外提示信息，如：1assertTrue( s.indexOf("developer") &gt; -1 || s.indexOf("Works") &gt; -1 ); 如果该断言出错，只会抛出无用的错误信息，如：junit.framework.AssertionFailedError：null。如果想在出错时想打印出一些有用的提示信息，必须得程序员另外手动写，如：12assertTrue( "Expected a string containing 'developer' or 'Works'", s.indexOf("developer") &gt; -1 || s.indexOf("Works") &gt; -1 ); 非常的不方便，而且需要额外代码。 JUnit 4.4 会默认自动提供一些可读的描述信息，如清单 4 所示： 清单 4 JUnit 4.4 默认提供一些可读的描述性错误信息 123456String s = "hello world!"; assertThat( s, anyOf( containsString("developer"), containsString("Works") ) ); // 如果出错后，系统会自动抛出以下提示信息：java.lang.AssertionError: Expected: (a string containing "developer" or a string containing "Works") got: "hello world!" 如何使用 assertThatJUnit 4.4 自带了一些 Hamcrest 的匹配符 Matcher，但是只有有限的几个，在类 org.hamcrest.CoreMatchers 中定义，要想使用他们，必须导入包 org.hamcrest.CoreMatchers.*。 清单 5 列举了大部分 assertThat 的使用例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859字符相关匹配符/**equalTo匹配符断言被测的testedValue等于expectedValue，* equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法*/assertThat(testedValue, equalTo(expectedValue));/**equalToIgnoringCase匹配符断言被测的字符串testedString*在忽略大小写的情况下等于expectedString*/assertThat(testedString, equalToIgnoringCase(expectedString));/**equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString*在忽略头尾的任意个空格的情况下等于expectedString，*注意：字符串中的空格不能被忽略*/assertThat(testedString, equalToIgnoringWhiteSpace(expectedString);/**containsString匹配符断言被测的字符串testedString包含子字符串subString**/assertThat(testedString, containsString(subString) );/**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/assertThat(testedString, endsWith(suffix));/**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/assertThat(testedString, startsWith(prefix));一般匹配符/**nullValue()匹配符断言被测object的值为null*/assertThat(object,nullValue());/**notNullValue()匹配符断言被测object的值不为null*/assertThat(object,notNullValue());/**is匹配符断言被测的object等于后面给出匹配表达式*/assertThat(testedString, is(equalTo(expectedValue)));/**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/assertThat(testedValue, is(expectedValue));/**is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写，*断言testedObject为Cheddar的实例*/assertThat(testedObject, is(Cheddar.class));/**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/assertThat(testedString, not(expectedString));/**allOf匹配符断言符合所有条件，相当于“与”（&amp;&amp;）*/assertThat(testedNumber, allOf( greaterThan(8), lessThan(16) ) );/**anyOf匹配符断言符合条件之一，相当于“或”（||）*/assertThat(testedNumber, anyOf( greaterThan(16), lessThan(8) ) );数值相关匹配符/**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/assertThat(testedDouble, closeTo( 20.0, 0.5 ));/**greaterThan匹配符断言被测的数值testedNumber大于16.0*/assertThat(testedNumber, greaterThan(16.0));/** lessThan匹配符断言被测的数值testedNumber小于16.0*/assertThat(testedNumber, lessThan (16.0));/** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/assertThat(testedNumber, greaterThanOrEqualTo (16.0));/** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/assertThat(testedNumber, lessThanOrEqualTo (16.0));集合相关匹配符/**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为"key"对应元素值为"value"的Entry项*/assertThat(mapObject, hasEntry("key", "value" ) );/**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/assertThat(iterableObject, hasItem (element));/** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/assertThat(mapObject, hasKey ("key"));/** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/assertThat(mapObject, hasValue(value)); 单元测试回滚单元个测试的时候如果不想造成垃圾数据，可以开启事物功能，记在方法或者类头部添加@Transactional注解即可,如下： 123456789@Test@Transactionalpublic void add()&#123; LearnResource bean = new LearnResource(); bean.setAuthor("测试回滚"); bean.setTitle("回滚用例"); bean.setUrl("http://tengj.top"); learnService.save(bean);&#125; 这样测试完数据就会回滚了，不会造成垃圾数据。如果你想关闭回滚，只要加上@Rollback(false)注解即可。@Rollback表示事务执行完回滚，支持传入一个参数value，默认true即回滚，false不回滚。 如果你使用的数据库是Mysql，有时候会发现加了注解@Transactional 也不会回滚，那么你就要查看一下你的默认引擎是不是InnoDB，如果不是就要改成InnoDB。 MyISAM与InnoDB是mysql目前比较常用的两个数据库存储引擎，MyISAM与InnoDB的主要的不同点在于性能和事务控制上。这里简单的介绍一下两者间的区别和转换方法： MyISAM：MyISAM是MySQL5.5之前版本默认的数据库存储引擎。MYISAM提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用。但不支持事务、也不支持外键。MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。 InnoDB：InnoDB是MySQL5.5版本的默认数据库存储引擎，不过InnoDB已被Oracle收购，MySQL自行开发的新存储引擎Falcon将在MySQL6.0版本引进。InnoDB具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。尽管如此，但是InnoDB包括了对事务处理和外来键的支持，这两点都是MyISAM引擎所没有的。 MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。 InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且表锁定的机会比较大的情况。(4)性能较好的服务器，比如单独的数据库服务器，像阿里云的关系型数据库RDS就推荐使用InnoDB引擎。 修改默认引擎的步骤查看MySQL当前默认的存储引擎: 1mysql&gt; show variables like &apos;%storage_engine%&apos;; 你要看user表用了什么引擎(在显示结果里参数engine后面的就表示该表当前用的存储引擎):1mysql&gt; show create table user; 将user表修为InnoDB存储引擎(也可以此命令将InnoDB换为MyISAM)：1mysql&gt; ALTER TABLE user ENGINE=INNODB; 如果要更改整个数据库表的存储引擎，一般要一个表一个表的修改，比较繁琐，可以采用先把数据库导出，得到SQL，把MyISAM全部替换为INNODB，再导入数据库的方式。转换完毕后重启mysql1service mysqld restart]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：修改项目默认端口的方式]]></title>
    <url>%2F2018%2F12%2F12%2Freact%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Linux 下修改方法修改 package.json 文件下 scripts 节点下的 start 的值，如下所示 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;PORT=9000 react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125; Windows 下修改方法修改 package.json 文件下 scripts 节点下的 start 的值，如下所示 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;set PORT=9000 &amp;&amp; react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：部署上线]]></title>
    <url>%2F2018%2F12%2F12%2Freact%EF%BC%9A%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[react创建项目react安装： 1npm install -g create-react-app 创建： 1create-react-app my-app 进入，打开： 12cd my-appnpm start react打包发布安装服务： 1npm install -g serve 打包（在my-app文件夹中）： 1npm run build 打包后会出现一个build文件夹，不需要进入，直接在my-app文件夹中运行： 1serve -s build 即会运行在5000默认端口。 改变默认端口运行时加入port： 1export PORT=8080 &amp;&amp; serve -s build]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu：mysql安装和操作]]></title>
    <url>%2F2018%2F12%2F12%2FUbuntu%EF%BC%9Amysql%E5%AE%89%E8%A3%85%E5%92%8C%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[流程：更新软件包索引，安装mysql-server软件包，然后运行附带的安全脚本 123sudo apt-get updatesudo apt-get install mysql-server sudo mysql_secure_installation sudo apt-get update：更新apt软件包索引； sudo apt-get install mysql-server：系统会提醒安装过程中创建root密码； sudo mysql_secure_installation：运行安全检查，这将提示输入在步骤1中创建的 root 密码。可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问是否要更改 root 密码。只需在步骤 1 中进行设置即可，因此无需现在更改； systemctl status mysql.service：测试mysql状态，可以看到如下输出： 1234567root@ubuntu:~# systemctl status mysql.service● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en Active: active (running) since Tue 2018-12-11 20:53:41 CST; 2min 44s ago Main PID: 7326 (mysqld) CGroup: /system.slice/mysql.service └─7326 /usr/sbin/mysqld mysql登录1mysql -u root -p 输入密码即可登录。 可以使用以下命令查看mysql数据库的user表： 12use mysqlselect * from user; 使用navicat连接数据库报错10038问题是远程3306端口未对外开放。 配置mysql远程服务端口打开mysql配置文件sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf，找到bind-address = 127.0.0.1，改为0.0.0.0 之后执行service mysql restart重启mysql即可。 现在使用命令netstat -an|grep 3306可以看到： 1tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 原来是127.0.0.1:3306，即只可以本地访问，这样的话可以远程访问。 配置用户权限授权root用户可以进行远程连接，注意替换以下代码中的“password”为 root 用户真正的密码： 123grant all privileges on *.* to root@&quot;%&quot; identified by &quot;password&quot; with grant option;flush privileges; 第二行是使命令生效，可以马上连接。 运行sql文件使用mysql -u root -p并输入密码登录后，创建数据库 1create database blog; 使用创建的数据库 1use blog; 如果文件在home/sql中，名字为blog.sql，导入文件 1source /home/sql/blog.sql; 数据传输或导入是报错：Invalid default value for ‘date’错误分析第一个TIMESTAMP列（如果未声明为NULL或显示DEFAULT或ON UPDATE子句）将自动分配DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP属性， 第一个之后的TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这不满足sql_mode中的NO_ZERO_DATE而报错。 注：sql_mode有两种，一种是空值，一种是严格模式，会给出很多默认设置。在MySQL5.7之后默认使用严格模式。 NO_ZERO_DATE：若设置该值，MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 解决方法先执行select @@sql_mode,查出来类似如下： 1ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 复制查询出来的值并将其中的NO_ZERO_DATE删除，然后执行set sql_mode = ‘修改后的值’。 此方法只在当前会话中生效。 然后可以进行数据插入。 删表，删数据库删表 1drop table blog; 删数据库 1drop database blogDatabase;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：使用spring-boot-admin对spring-boot服务进行监控]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A%E4%BD%BF%E7%94%A8spring-boot-admin%E5%AF%B9spring-boot%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[项目地址： 简单版本：https://github.com/snjl/springboot.admin-simple.git 复杂版本：https://github.com/snjl/springboot.admin.git Spring Boot Actuator提供了对单个Spring Boot的监控，信息包含：应用状态、内存、线程、堆栈等等，比较全面的监控了Spring Boot应用的整个生命周期。 但是这样监控也有一些问题：第一，所有的监控都需要调用固定的接口来查看，如果全面查看应用状态需要调用很多接口，并且接口返回的Json信息不方便运营人员理解；第二，如果Spring Boot应用集群非常大，每个应用都需要调用不同的接口来查看监控信息，操作非常繁琐低效。在这样的背景下，就诞生了另外一个开源软件：Spring Boot Admin。 Spring Boot Admin 是一个管理和监控Spring Boot 应用程序的开源软件。每个应用都认为是一个客户端，通过HTTP或者使用 Eureka注册到admin server中进行展示，Spring Boot Admin UI部分使用AngularJs将数据展示在前端。 Spring Boot Admin 是一个针对spring-boot的actuator接口进行UI美化封装的监控工具。他可以：在列表中浏览所有被监控spring-boot项目的基本信息，详细的Health信息、内存信息、JVM信息、垃圾回收信息、各种配置信息（比如数据源、缓存列表和命中率）等，还可以直接修改logger的level。 这篇文章给大家介绍如何使用Spring Boot Admin对Spring Boot应用进行监控。 监控单体应用这节给大家展示如何使用Spring Boot Admin监控单个Spring Boot应用。 Admin Server端项目依赖123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件1server.port=8000 启动类123456789@Configuration@EnableAutoConfiguration@EnableAdminServerpublic class AdminServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminServerApplication.class, args); &#125;&#125; 完成上面三步之后，启动服务端，浏览器访问http://localhost:8000可以看到以下界面： Admin Client端项目依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件1234server.port=8001spring.boot.admin.url=http://localhost:8000 management.security.enabled=false spring.boot.admin.url 配置Admin Server的地址 management.security.enabled=false 关闭安全验证 启动类123456@SpringBootApplicationpublic class AdminClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminClientApplication.class, args); &#125;&#125; 配置完成之后，启动Client端服务，再次访问服务：http://localhost:8000可以看到客户端的相关信息。 首页会展示被监控的各个服务，点击详情可以查看某个服务的具体监控信息 通过上图可以看出，Spring Boot Admin以图形化的形式展示了应用的各项信息，这些信息大多都来自于Spring Boot Actuator提供的接口。 监控微服务如果我们使用的是单个Spring Boot应用，就需要在每一个被监控的应用中配置Admin Server的地址信息；如果应用都注册在Eureka中就不需要再对每个应用进行配置，Spring Boot Admin会自动从注册中心抓取应用的相关信息。 这里使用四个示例项目来演示： spring-boot-admin-server Admin Server端 spring-cloud-eureka 注册中心 spring-cloud-producer 应用一，Admin Client端 spring-cloud-producer-2 应用二，Admin Client端 首先启动注册中心spring-cloud-eureka。 Server端示例项目：spring-boot-admin-server 项目依赖12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 增加了对eureka的支持 配置文件1234567891011121314server: port: 8000spring: application: name: admin-servereureka: instance: leaseRenewalIntervalInSeconds: 10 client: registryFetchIntervalSeconds: 5 serviceUrl: defaultZone: $&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/management.security.enabled: false 配置文件中添加了eureka的相关配置 启动类12345678910@Configuration@EnableAutoConfiguration@EnableDiscoveryClient@EnableAdminServerpublic class AdminServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminServerApplication.class, args); &#125;&#125; 上述步骤完成之后，启动Server端。 Client端示例项目：spring-cloud-producer和spring-cloud-producer-2 项目依赖1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件123456789101112server: port: 9000spring: application: name: producereureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/management: security: enabled: false 我们发现配置文件中并没有添加Admin Server的相关配置 启动类12345678@SpringBootApplication@EnableDiscoveryClientpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; Web层12345@RequestMapping("/hello") public String index(@RequestParam String name) &#123; logger.info("request one/two name is "+name); return "hello "+name+"，this is first messge"; &#125; web层添加了/hello的请求方法，方法中使用one/two区别是哪个应用。spring-cloud-producer-2和spring-cloud-producer代码类似，具体大家可以查看示例代码。 完成上面配置之后，分别启动项目：spring-cloud-producer和spring-cloud-producer-2，浏览器访问http://localhost:8000 可以看到以下界面： 从上图可以看出Admin Server监控了四个实例，包括Server自己，注册中心、两个PRODUCER。说明Admin Server自动从服务中心抓取了所有的实例信息并进行了监控。点击Detail可以具体查看某一个示例的监控信息。 邮件告警Spring Boot Admin将微服务中所有应用信息在后台进行了展示，非常方便我们对微服务整体的监控和治理。但是我们的运营人员也不可能一天24小时盯着监控后台，因此如果服务有异常的时候，有对应的邮件告警就太好了，其实Spring Boot Admin也给出了支持。 我们对上面的示例项目spring-boot-admin-server进行改造。 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 增加了邮件发送的starter包 配置文件12345678910111213141516171819spring: mail: host: smtp.qq.com username: xxxxx@qq.com password: xxxx properties: mail: smtp: auth: true starttls: enable: true required: true boot: admin: notify: mail: from: xxxx@qq.com to: xxxx@qq.com# http://codecentric.github.io/spring-boot-admin/1.5.6/#mail-notifications 在配置文件中添加邮件发送相关信息：邮件的发送者、接受者、协议、移动授权码等。 配置完成后，重新启动项目spring-boot-admin-server，这样Admin Server就具备了邮件告警的功能，默认情况下Admin Server对Eureka中的服务上下线都进行了监控，当服务上下线的时候我们就会收到如下邮件： 当然这只是最基本的邮件监控，在实际的使用过程中，需要根据我们的情况对邮件告警内容进行自定义，比如监控堆内存的使用情况，当到达一定比例的时候进行告警等。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>资源监控</tag>
        <tag>spring admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：使用Spring Boot上传文件]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A%E4%BD%BF%E7%94%A8Spring-Boot%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.upload.git 使用Spring Boot最新版本1.5.9、jdk使用1.8、tomcat8.0。 pom包配置12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 引入了spring-boot-starter-thymeleaf做页面模板引擎，写一些简单的上传示例。 启动类设置123456789101112131415161718192021@SpringBootApplicationpublic class FileUploadWebApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(FileUploadWebApplication.class, args); &#125; //Tomcat large file upload connection reset @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbedded() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory(); tomcat.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; &#123; if ((connector.getProtocolHandler() instanceof AbstractHttp11Protocol&lt;?&gt;)) &#123; //-1 means unlimited ((AbstractHttp11Protocol&lt;?&gt;) connector.getProtocolHandler()).setMaxSwallowSize(-1); &#125; &#125;); return tomcat; &#125;&#125; tomcatEmbedded这段代码是为了解决，上传文件大于10M出现连接重置的问题。此异常内容GlobalException也捕获不到。 编写前端页面上传页面12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt;&lt;h1&gt;Spring Boot file upload example&lt;/h1&gt;&lt;form method="POST" action="/upload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 非常简单的一个Post请求，一个选择框选择文件，一个提交按钮。 上传结果展示页面：123456789&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt;&lt;h1&gt;Spring Boot - Upload Status&lt;/h1&gt;&lt;div th:if="$&#123;message&#125;"&gt; &lt;h2 th:text="$&#123;message&#125;"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写上传控制类12345678910111213141516171819202122232425262728@GetMapping("/")public String index() &#123; return "upload";&#125;//上传业务处理@PostMapping("/upload") public String singleFileUpload(@RequestParam("file") MultipartFile file, RedirectAttributes redirectAttributes) &#123; if (file.isEmpty()) &#123; redirectAttributes.addFlashAttribute("message", "Please select a file to upload"); return "redirect:uploadStatus"; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute("message", "You successfully uploaded '" + file.getOriginalFilename() + "'"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "redirect:/uploadStatus";&#125; 上面代码的意思就是，通过MultipartFile读取文件信息，如果文件为空跳转到结果页并给出提示；如果不为空读取文件流并写入到指定目录，最后将结果展示到页面。 MultipartFile是Spring上传文件的封装类，包含了文件的二进制流和文件属性等信息，在配置文件中也可对相关属性进行配置，基本的配置信息如下： spring.http.multipart.enabled=true #默认支持文件上传. spring.http.multipart.file-size-threshold=0 #支持文件写入磁盘. spring.http.multipart.location= # 上传文件的临时目录 spring.http.multipart.max-file-size=1Mb # 最大支持文件大小 spring.http.multipart.max-request-size=10Mb # 最大支持请求大小 最常用的是最后两个配置内容，限制文件上传大小，上传时超过大小会抛出异常。 异常处理123456789@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(MultipartException.class) public String handleError1(MultipartException e, RedirectAttributes redirectAttributes) &#123; redirectAttributes.addFlashAttribute("message", e.getCause().getMessage()); return "redirect:/uploadStatus"; &#125;&#125; 设置一个@ControllerAdvice用来监控Multipart上传的文件大小是否受限，当出现此异常时在前端页面给出提示。利用@ControllerAdvice可以做很多东西，比如全局的统一异常处理等，感兴趣的同学可以下来了解。 使用ajax上传文件加入函数12345678910111213141516171819@ResponseBody@PostMapping("/ajax/upload") // //new annotation since 4.3public String uploadByAjax(@RequestParam("file") MultipartFile file) &#123; if (file.isEmpty()) &#123; return "error,the file is empty!"; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); return "You successfully uploaded '" + file.getOriginalFilename() + "'"; &#125; catch (IOException e) &#123; return "upload error!"; &#125;&#125; 可以使用postman测试，使用form-data，key为file和enctype，其中enctype为multipart/form-data（也可以不设置）。 多文件上传先将文件上传抽离出一个类，Upload：123456789101112131415161718192021222324252627282930313233343536package com.neo.tools;import org.springframework.stereotype.Component;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;/** * @author 34924 */@Componentpublic class Upload &#123; private static String UPLOADED_FOLDER = "D:\\test\\"; public static String uploadFile( MultipartFile file) &#123; if (file.isEmpty()) &#123; return "error,the file is empty!"; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); return "You successfully uploaded '" + file.getOriginalFilename() + "'"; &#125; catch (IOException e) &#123; return "upload error!"; &#125; &#125; ...&#125; 加上多文件上传：12345678910111213public static String uploadFiles( MultipartFile [] files) &#123; String message = "success uploaded "; for (MultipartFile file : files) &#123; try &#123; uploadFile(file); &#125; catch (Exception e) &#123; return "upload error!"; &#125; message = message + file.getOriginalFilename() + " "; &#125; return message;&#125; 或12345678910111213public static String uploadFiles( List&lt;MultipartFile&gt; files) &#123; String message = "success uploaded "; for (MultipartFile file : files) &#123; try &#123; uploadFile(file); &#125; catch (Exception e) &#123; return "upload error!"; &#125; message = message + file.getOriginalFilename() + " "; &#125; return message;&#125; controller中改为：1234567@ResponseBody@PostMapping("/ajax/uploads") // //new annotation since 4.3public String uploadsByAjax(@RequestParam("file") MultipartFile []files) &#123; System.out.println("uploads"); return Upload.uploadFiles(files);&#125; 或12345678@ResponseBody@PostMapping("/ajax/uploads") // //new annotation since 4.3public String uploadsByAjax(HttpServletRequest request) &#123; List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest)request).getFiles("file"); System.out.println("uploads"); return Upload.uploadFiles(files);&#125; 均可实现多文件上传。 如下图所示： springboot：文件上传路径的几种设置方式在配置文件中配置如下：1xcloud.uploadPath=D:\\test\\ 编写上传路径配置类：12345678910111213141516@Component@ConfigurationProperties(prefix="xcloud")public class UploadConfig &#123; //上传路径 @Value("$&#123;xcloud.uploadPath&#125;") private String uploadPath; public String getUploadPath() &#123; return uploadPath; &#125; public void setUploadPath(String uploadPath) &#123; this.uploadPath = uploadPath; &#125;&#125; 上传文件方法注入：1234@AutowiredUploadConfig uploadConfig;@Value("$&#123;media.save.urlprefix&#125;")private String urlprefix; controller：123456789101112131415161718192021@ResponseBody@PostMapping("/&#123;savePath&#125;/upload") // //new annotation since 4.3public String uploadByAjax(@RequestParam("file") MultipartFile file, @PathVariable String savePath) &#123; if (file.isEmpty()) &#123; return "error,the file is empty!"; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(uploadConfig.getUploadPath() + savePath +"//" + file.getOriginalFilename()); System.out.println(path); Files.write(path, bytes); return "You successfully uploaded '" + file.getOriginalFilename() + "'"; &#125; catch (IOException e) &#123; return "upload error!"; &#125;&#125; 综上可以看出，可以使用固定的static String path来设置path，也可以在配置文件中配置，使用UploadConfig这样的配置类来取出配置路径，也可以综合上一种方式或者独立使用@PathVariable来获取需要的文件夹名，来进行路径生成。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：邮件服务]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mail.git 发送邮件应该是网站的必备功能之一，什么注册验证，忘记密码或者是给用户发送营销信息。最早期的时候我们会使用JavaMail相关api来写发送邮件的相关代码，后来spring推出了JavaMailSender更加简化了邮件发送的过程，在之后springboot对此进行了封装就有了现在的spring-boot-starter-mail,本章文章的介绍主要来自于此包。 pom包配置pom包里面添加spring-boot-starter-mail包引用123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在application.properties中添加邮箱配置123456spring.mail.host=smtp.qiye.163.com //邮箱服务器地址spring.mail.username=xxx@oo.com //用户名spring.mail.password=xxyyooo //密码spring.mail.default-encoding=UTF-8mail.fromMail.addr=xxx@oo.com //以谁来发送邮件 #编写mailService,这里只提出实现类12345678910111213141516171819202122232425262728@Componentpublic class MailServiceImpl implements MailService&#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Value("$&#123;mail.fromMail.addr&#125;") private String from; @Override public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; logger.error("发送简单邮件时发生异常！", e); &#125; &#125;&#125; 编写test类进行测试123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class MailServiceTest &#123; @Autowired private MailService MailService; @Test public void testSimpleMail() throws Exception &#123; MailService.sendSimpleMail("ityouknow@126.com","test simple mail"," hello this is simple mail"); &#125;&#125; 至此一个简单的文本发送就完成了。 但是在正常使用的过程中，我们通常在邮件中加入图片或者附件来丰富邮件的内容，下面讲介绍如何使用springboot来发送丰富的邮件。 发送html格式邮件其它都不变在MailService添加sendHtmlMail方法. 1234567891011121314151617public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; logger.error("发送html邮件时发生异常！", e); &#125;&#125; 在测试类中构建html内容，测试发送123456789@Testpublic void testHtmlMail() throws Exception &#123; String content="&lt;html&gt;\n" + "&lt;body&gt;\n" + " &lt;h3&gt;hello world ! 这是一封Html邮件!&lt;/h3&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"; MailService.sendHtmlMail("ityouknow@126.com","test simple mail",content);&#125; 发送带附件的邮件在MailService添加sendAttachmentsMail方法.1234567891011121314151617181920public void sendAttachmentsMail(String to, String subject, String content, String filePath)&#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); mailSender.send(message); logger.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送带附件的邮件时发生异常！", e); &#125;&#125; 添加多个附件可以使用多条 helper.addAttachment(fileName, file) 在测试类中添加测试方法12345@Testpublic void sendAttachmentsMail() &#123; String filePath="e:\\tmp\\application.log"; mailService.sendAttachmentsMail("ityouknow@126.com", "主题：带附件的邮件", "有附件，请查收！", filePath);&#125; 发送带静态资源的邮件邮件中的静态资源一般就是指图片，在MailService添加sendAttachmentsMail方法.12345678910111213141516171819public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId)&#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送嵌入静态资源的邮件时发生异常！", e); &#125;&#125; 在测试类中添加测试方法12345678@Testpublic void sendInlineResourceMail() &#123; String rscId = "neo006"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "C:\\Users\\summer\\Pictures\\favicon.png"; mailService.sendInlineResourceMail("ityouknow@126.com", "主题：这是有图片的邮件", content, imgPath, rscId);&#125; 添加多个图片可以使用多条 和 helper.addInline(rscId, res) 来实现 邮件系统我们会经常收到这样的邮件： 1234尊敬的neo用户： 恭喜您注册成为xxx网的用户,，同时感谢您对xxx的关注与支持并欢迎您使用xx的产品与服务。 ... 其中只有neo这个用户名在变化，其它邮件内容均不变，如果每次发送邮件都需要手动拼接的话会不够优雅，并且每次模板的修改都需要改动代码的话也很不方便，因此对于这类邮件需求，都建议做成邮件模板来处理。模板的本质很简单，就是在模板中替换变化的参数，转换为html字符串即可，这里以thymeleaf为例来演示。 pom中导入thymeleaf的包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在resorces/templates下创建emailTemplate.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您好,这是验证邮件,请点击下面的链接完成验证,&lt;br/&gt; &lt;a href="#" th:href="@&#123; http://www.ityouknow.com/neo/&#123;id&#125;(id=$&#123;id&#125;) &#125;"&gt;激活账号&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 解析模板并发送@Testpublic void sendTemplateMail() {​ //创建邮件正文​ Context context = new Context();​ context.setVariable(“id”, “006”);​ String emailContent = templateEngine.process(“emailTemplate”, context); mailService.sendHtmlMail(&quot;ityouknow@126.com&quot;,&quot;主题：这是模板邮件&quot;,emailContent); } 发送失败因为各种原因，总会有邮件发送失败的情况，比如：邮件发送过于频繁、网络异常等。在出现这种情况的时候，我们一般会考虑重新重试发送邮件，会分为以下几个步骤来实现： 接收到发送邮件请求，首先记录请求并且入库。 调用邮件发送接口发送邮件，并且将发送结果记录入库。 启动定时系统扫描时间段内，未发送成功并且重试次数小于3次的邮件，进行再次发送 异步发送很多时候邮件发送并不是我们主业务必须关注的结果，比如通知类、提醒类的业务可以允许延时或者失败。这个时候可以采用异步的方式来发送邮件，加快主交易执行速度，在实际项目中可以采用MQ发送邮件相关参数，监听到消息队列之后启动发送邮件。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：@RestController和@ResponseBody]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A-RestController%E5%92%8C-ResponseBody%2F</url>
    <content type="text"><![CDATA[@Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：整合Mybatis通用Mapper插件]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A%E6%95%B4%E5%90%88Mybatis%E9%80%9A%E7%94%A8Mapper%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.auto-mybatis.git 项目配置 Spring Boot： 1.5.9.RELEASE Maven： 3.5 Java： 1.8 Thymeleaf： 3.0.7.RELEASE Vue.js： v2.5.11 数据源依赖12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt;&lt;/dependency&gt; application.properties配置：1234567891011121314151617181920212223242526272829## 数据库访问配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = root# 下面为连接池的补充设置，应用到上面所有数据源中# 初始化大小，最小，最大spring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20# 配置获取连接等待超时的时间spring.datasource.maxWait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.timeBetweenEvictionRunsMillis=60000# 配置一个连接在池中最小生存的时间，单位是毫秒spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.filters=stat,wall,log4j# 合并多个DruidDataSource的监控数据#spring.datasource.useGlobalDataSourceStat=true 对应的bean配置：123456789101112131415161718192021222324252627282930313233343536373839 @Bean public ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); //控制台管理用户，加入下面2行 进入druid后台就需要登录 //servletRegistrationBean.addInitParameter("loginUsername", "admin"); //servletRegistrationBean.addInitParameter("loginPassword", "admin"); return servletRegistrationBean; &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new WebStatFilter()); filterRegistrationBean.addUrlPatterns("/*"); filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); filterRegistrationBean.addInitParameter("profileEnable", "true"); return filterRegistrationBean; &#125; @Bean public StatFilter statFilter()&#123; StatFilter statFilter = new StatFilter(); statFilter.setLogSlowSql(true); //slowSqlMillis用来配置SQL慢的标准，执行时间超过slowSqlMillis的就是慢。 statFilter.setMergeSql(true); //SQL合并配置 statFilter.setSlowSqlMillis(1000);//slowSqlMillis的缺省值为3000，也就是3秒。 return statFilter; &#125; @Bean public WallFilter wallFilter()&#123; WallFilter wallFilter = new WallFilter(); //允许执行多条SQL WallConfig config = new WallConfig(); config.setMultiStatementAllow(true); wallFilter.setConfig(config); return wallFilter; &#125;&#125; mybatis相关依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--通用mapper--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--pagehelper 分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;!--配置这个依赖主要是为了等下在配置mybatis-generator.xml的时候可以不用配置classPathEntry这样的一个属性，避免代码的耦合度太高--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!-- 自动生成的配置 --&gt; &lt;configurationFile&gt;src/main/resources/mybatis-generator.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 上面引入了mybatis相关的一些依赖以及generator的配置，这里generator配置文件指向src/main/resources/mybatis-generator.xml文件，具体一会贴出。 对应的application.properties配置： 12345678910111213141516#指定bean所在包mybatis.type-aliases-package=com.dudu.domain#指定映射文件mybatis.mapperLocations=classpath:mapper/*.xml#mapper#mappers 多个接口时逗号隔开mapper.mappers=com.dudu.util.MyMappermapper.not-empty=falsemapper.identity=MYSQL#pagehelperpagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql 通用Mapper配置通用Mapper都可以极大的方便开发人员,对单表封装了许多通用方法，省掉自己写增删改查的sql。 通用Mapper插件网址：https://github.com/abel533/Mapper 1234567891011121314package com.dudu.util;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 继承自己的MyMapper * * @author * @since 2017-06-26 21:53 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; //FIXME 特别注意，该接口不能被扫描到，否则会出错&#125; 这里实现一个自己的接口,继承通用的mapper，关键点就是这个接口不能被扫描到，不能跟dao这个存放mapper文件放在一起。 最后在启动类中通过MapperScan注解指定扫描的mapper路径： 12345678910package com.dudu;@SpringBootApplication//启注解事务管理@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;@MapperScan(basePackages = "com.dudu.dao", markerInterface = MyMapper.class)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; MyBatis Generator配置这里配置一下上面提到的mybatis-generator.xml文件,该配置文件用来自动生成表对应的Model,Mapper以及xml,该文件位于src/main/resources下面 Mybatis Geneator 详解: http://blog.csdn.net/isea533/article/details/42102297 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--加载配置文件，为下面读取数据库信息准备--&gt; &lt;properties resource="application.properties"/&gt; &lt;context id="Mysql" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="com.dudu.util.MyMapper" /&gt; &lt;!--caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true--&gt; &lt;property name="caseSensitive" v alue="true"/&gt; &lt;/plugin&gt; &lt;!-- 阻止生成自动注释 --&gt; &lt;commentGenerator&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass="$&#123;spring.datasource.driver-class-name&#125;" connectionURL="$&#123;spring.datasource.url&#125;" userId="$&#123;spring.datasource.username&#125;" password="$&#123;spring.datasource.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成Model类存放位置--&gt; &lt;javaModelGenerator targetPackage="com.dudu.domain" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成Dao类存放位置--&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.dudu.dao" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名 去掉Mybatis Generator生成的一堆 example --&gt; &lt;table tableName="LEARN_RESOURCE" domainObjectName="LearnResource" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;generatedKey column="id" sqlStatement="Mysql" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 其中，我们通过引入了配置文件，这样下面指定数据源的时候不用写死。 其中tk.mybatis.mapper.generator.MapperPlugin很重要，用来指定通用Mapper对应的文件，这样我们生成的mapper都会继承这个通用Mapper12345&lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="com.dudu.util.MyMapper" /&gt; &lt;!--caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true--&gt; &lt;property name="caseSensitive" value="true"/&gt;&lt;/plugin&gt; 这样就可以通过mybatis-generator插件生成对应的文件啦 自动生成的文件如下图所示 如果不是IDEA开发环境也可以直接通过命令：mvn mybatis-generator:generate 自动生成的文件如下图所示 脚本初始化12345678910111213141516CREATE DATABASE /*!32312 IF NOT EXISTS*/`spring` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `spring`;DROP TABLE IF EXISTS `learn_resource`;CREATE TABLE `learn_resource` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID', `author` varchar(20) DEFAULT NULL COMMENT '作者', `title` varchar(100) DEFAULT NULL COMMENT '描述', `url` varchar(100) DEFAULT NULL COMMENT '地址链接', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1029 DEFAULT CHARSET=utf8;insert into `learn_resource`(`id`,`author`,`title`,`url`) values (999,'官方SpriongBoot例子','官方SpriongBoot例子','https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1000,'龙果学院','Spring Boot 教程系列学习','http://www.roncoo.com/article/detail/124661');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1001,'嘟嘟MD独立博客','Spring Boot干货系列','http://tengj.top/');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1002,'后端编程嘟','Spring Boot视频教程','http://www.toutiao.com/m1559096720023553/'); Controller层到此为止，基本的配置结束了，我们开始实现业务的逻辑，Controller层代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 教程页面 * Created by tengj on 2017/12/19 */@Controller@RequestMapping("/learn")public class LearnController extends AbstractController&#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn(Model model)&#123; model.addAttribute("ctx", getContextPath()+"/"); return "learn-resource"; &#125; /** * 查询教程列表 * @param page * @return */ @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST) @ResponseBody public AjaxObject queryLearnList(Page&lt;LeanQueryLeanListReq&gt; page)&#123; List&lt;LearnResource&gt; learnList=learnService.queryLearnResouceList(page); PageInfo&lt;LearnResource&gt; pageInfo =new PageInfo&lt;LearnResource&gt;(learnList); return AjaxObject.ok().put("page", pageInfo); &#125; /** * 新添教程 * @param learn */ @RequestMapping(value = "/add",method = RequestMethod.POST) @ResponseBody public AjaxObject addLearn(@RequestBody LearnResource learn)&#123; learnService.save(learn); return AjaxObject.ok(); &#125; /** * 修改教程 * @param learn */ @RequestMapping(value = "/update",method = RequestMethod.POST) @ResponseBody public AjaxObject updateLearn(@RequestBody LearnResource learn)&#123; learnService.updateNotNull(learn); return AjaxObject.ok(); &#125; /** * 删除教程 * @param ids */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public AjaxObject deleteLearn(@RequestBody Long[] ids)&#123; learnService.deleteBatch(ids); return AjaxObject.ok(); &#125;&#125; 通用Service正常情况下具体业务是每个模块的service里面定义许多方法，然后mapper中实现。 但是博主查看插件文档后发现一个通用Mapper在Spring4中的最佳用法。那就是通用的Service。具体可以查看这里了解:https://gitee.com/free/Mapper2/blob/master/wiki/mapper/4.Spring4.md 定义通用service接口 1234567891011121314151617181920/** * 通用接口 */@Servicepublic interface IService&lt;T&gt; &#123; T selectByKey(Object key); int save(T entity); int delete(Object key); int updateAll(T entity); int updateNotNull(T entity); List&lt;T&gt; selectByExample(Object example); //TODO 其他...&#125; 具体实现通用接口类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 通用Service * @param &lt;T&gt; */public abstract class BaseService&lt;T&gt; implements IService&lt;T&gt; &#123; @Autowired protected Mapper&lt;T&gt; mapper; public Mapper&lt;T&gt; getMapper() &#123; return mapper; &#125; @Override public T selectByKey(Object key) &#123; //说明：根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 return mapper.selectByPrimaryKey(key); &#125; @Override public int save(T entity) &#123; //说明：保存一个实体，null的属性也会保存，不会使用数据库默认值 return mapper.insert(entity); &#125; @Override public int delete(Object key) &#123; //说明：根据主键字段进行删除，方法参数必须包含完整的主键属性 return mapper.deleteByPrimaryKey(key); &#125; @Override public int updateAll(T entity) &#123; //说明：根据主键更新实体全部字段，null值会被更新 return mapper.updateByPrimaryKey(entity); &#125; @Override public int updateNotNull(T entity) &#123; //根据主键更新属性不为null的值 return mapper.updateByPrimaryKeySelective(entity); &#125; @Override public List&lt;T&gt; selectByExample(Object example) &#123; //说明：根据Example条件进行查询 //重点：这个查询支持通过Example类指定查询列，通过selectProperties方法指定查询列 return mapper.selectByExample(example); &#125;&#125; 到此基本的增删改查通用service就写好了，具体业务的service就直接继承这个接口即可,也可以添加额外的方法，例如：1234public interface LearnService extends IService&lt;LearnResource&gt;&#123; public List&lt;LearnResource&gt; queryLearnResouceList(Page&lt;LeanQueryLeanListReq&gt; page); public void deleteBatch(Long[] ids);&#125; 具体实现service 1234567891011121314151617181920/** * Created by tengj on 2017/4/7. */@Servicepublic class LearnServiceImpl extends BaseService&lt;LearnResource&gt; implements LearnService &#123; @Autowired private LearnResourceMapper learnResourceMapper; @Override public void deleteBatch(Long[] ids) &#123; Arrays.stream(ids).forEach(id-&gt;learnResourceMapper.deleteByPrimaryKey(id)); &#125; @Override public List&lt;LearnResource&gt; queryLearnResouceList(Page&lt;LeanQueryLeanListReq&gt; page) &#123; PageHelper.startPage(page.getPage(), page.getRows()); return learnResourceMapper.queryLearnResouceList(page.getCondition()); &#125;&#125; 可以看到，具体LearnServiceImpl这边就实现了2个方法，其他的都使用了通用service的，在开发上剩下了许多功夫。 Mapper相关在自动生成的mapper文件中实现sevice自定义的方法： 123public interface LearnResourceMapper extends MyMapper&lt;LearnResource&gt; &#123; List&lt;LearnResource&gt; queryLearnResouceList(Map&lt;String,Object&gt; map);&#125; LearnResourceMapper.xml： 1234567891011121314151617181920212223 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dudu.dao.LearnResourceMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.dudu.domain.LearnResource"&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column="id" jdbcType="BIGINT" property="id" /&gt; &lt;result column="author" jdbcType="VARCHAR" property="author" /&gt; &lt;result column="title" jdbcType="VARCHAR" property="title" /&gt; &lt;result column="url" jdbcType="VARCHAR" property="url" /&gt; &lt;/resultMap&gt; &lt;select id="queryLearnResouceList" resultType="com.dudu.domain.LearnResource"&gt; SELECT * from learn_resource where 1=1 &lt;if test="author != null and author!= ''"&gt; and author like CONCAT('%',#&#123;author&#125;,'%') &lt;/if&gt; &lt;if test="title != null and title!= ''"&gt; and title like CONCAT('%',#&#123;title&#125;,'%') &lt;/if&gt; order by id desc &lt;/select&gt;&lt;/mapper&gt; IDEA可以安装这个插件，这样就可以直接从Mapper文件跳转到xml了 登录页面为http://localhost:8080/spring/toLogin。 上面提到druid有对应的监控界面，启动项目后输入http://localhost:8080/spring/druid 即可登录，界面效果如下 总结到此，一套适合企业级开发的Spring Boot应用模板就好了，Mybatis+通用Mapper、Mybatis Geneator确实可以省下很多开发成本，提高效率。前端整合了vue.js,具体看源码。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：全局异常处理整理]]></title>
    <url>%2F2018%2F12%2F09%2Fspringboot%EF%BC%9A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.auto-mybatis.git 介绍Spring Boot默认的异常处理机制默认情况下，Spring Boot为两种情况提供了不同的响应方式。 一种是浏览器客户端请求一个不存在的页面或服务端处理发生异常时，一般情况下浏览器默认发送的请求头中Accept: text/html，所以Spring Boot默认会响应一个html文档内容，称作“Whitelabel Error Page”。 另一种是使用Postman等调试工具发送请求一个不存在的url或服务端处理发生异常时，Spring Boot会返回类似如下的Json格式字符串信息 1234567&#123; "timestamp": "2018-05-12T06:11:45.209+0000", "status": 404, "error": "Not Found", "message": "No message available", "path": "/index.html"&#125; 原理也很简单，Spring Boot 默认提供了程序出错的结果映射路径/error。这个/error请求会在BasicErrorController中处理，其内部是通过判断请求头中的Accept的内容是否为text/html来区分请求是来自客户端浏览器（浏览器通常默认自动发送请求头内容Accept:text/html）还是客户端接口的调用，以此来决定返回页面视图还是 JSON 消息内容。 相关BasicErrorController中代码如下： 如何自定义错误页面好了，了解完Spring Boot默认的错误机制后，我们来点有意思的，浏览器端访问的话，任何错误Spring Boot返回的都是一个Whitelabel Error Page的错误页面，这个很不友好，所以我们可以自定义下错误页面。 先从最简单的开始，直接在/resources/templates下面创建error.html就可以覆盖默认的Whitelabel Error Page的错误页面，我项目用的是thymeleaf模板，对应的error.html代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;动态error错误页面&lt;p th:text="$&#123;error&#125;"&gt;&lt;/p&gt;&lt;p th:text="$&#123;status&#125;"&gt;&lt;/p&gt;&lt;p th:text="$&#123;message&#125;"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这样运行的时候，请求一个不存在的页面或服务端处理发生异常时，展示的自定义错误界面如下： 此外，如果你想更精细一点，根据不同的状态码返回不同的视图页面，也就是对应的404，500等页面，这里分两种，错误页面可以是静态HTML（即，添加到任何静态资源文件夹下），也可以使用模板构建，文件的名称应该是确切的状态码。 如果只是静态HTML页面，不带错误信息的，在resources/public/下面创建error目录，在error目录下面创建对应的状态码html即可 ，例如，要将404映射到静态HTML文件，您的文件夹结构如下所示： 静态404.html简单页面如下12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 静态404错误页面&lt;/body&gt;&lt;/html&gt; 这样访问一个错误路径的时候，就会显示静态404错误页面错误页面 注：这时候如果存在上面第一种介绍的error.html页面，则状态码错误页面将覆盖error.html，具体状态码错误页面优先级比较高。 如果是动态模板页面，可以带上错误信息，在resources/templates/下面创建error目录，在error目录下面命名即可: 这里我们模拟下500错误，控制层代码,模拟一个除0的错误： 1234567891011@Controller public class BaseErrorController extends AbstractController&#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(value="/ex") @ResponseBody public String error()&#123; int i=5/0; return "ex"; &#125; &#125; 500.html代码: 12345678910111213&lt;!DOCTYPE html&gt; &lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 动态500错误页面 &lt;p th:text="$&#123;error&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;status&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;message&#125;"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 这时访问 http://localhost:8080/spring/ex 即可看到如下错误，说明确实映射到了500.html 注:如果同时存在静态页面500.html和动态模板的500.html，则后者覆盖前者。即templates/error/这个的优先级比resources/public/error高。 整体概括上面几种情况，如下： error.html会覆盖默认的 whitelabel Error Page 错误提示 静态错误页面优先级别比error.html高 动态模板错误页面优先级比静态错误页面高 上面介绍的只是最简单的覆盖错误页面的方式来自定义，如果对于某些错误你可能想特殊对待，则可以这样 123456789101112@Configuration public class ContainerConfig &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer()&#123; return new EmbeddedServletContainerCustomizer()&#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error/500")); &#125; &#125;; &#125; &#125; 上面这段代码中HttpStatus.INTERNAL_SERVER_ERROR就是对应500错误码，也就是说程序如果发生500错误，就会将请求转发到/error/500这个映射来，那我们只要实现一个方法是对应这个/error/500映射即可捕获这个异常做出处理 12345@RequestMapping("/error/500") @ResponseBody public String showServerError() &#123; return "server error"; &#125; 这样，我们再请求前面提到的异常请求 http://localhost:8080/spring/ex 的时候，就会被我们这个方法捕获了。 这里我们就只对500做了特殊处理，并且返还的是字符串，如果想要返回视图，去掉 @ResponseBody注解，并返回对应的视图页面。如果想要对其他状态码自定义映射，在customize方法中添加即可。 上面这种方法虽然我们重写了/500映射，但是有一个问题就是无法获取错误信息，想获取错误信息的话，我们可以继承BasicErrorController或者干脆自己实现ErrorController接口，除了用来响应/error这个错误页面请求，可以提供更多类型的错误格式等（BasicErrorController在上面介绍SpringBoot默认异常机制的时候有提到） 这里博主选择直接继承BasicErrorController，然后把上面 /error/500映射方法添加进来即可 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class MyBasicErrorController extends BasicErrorController &#123; public MyBasicErrorController() &#123; super(new DefaultErrorAttributes(), new ErrorProperties()); &#125; /** * 定义500的ModelAndView * @param request * @param response * @return */ @RequestMapping(produces = "text/html",value = "/500") public ModelAndView errorHtml500(HttpServletRequest request,HttpServletResponse response) &#123; response.setStatus(getStatus(request).value()); Map&lt;String, Object&gt; model = getErrorAttributes(request,isIncludeStackTrace(request, MediaType.TEXT_HTML)); model.put("msg","自定义错误信息"); return new ModelAndView("error/500", model); &#125; /** * 定义500的错误JSON信息 * @param request * @return */ @RequestMapping(value = "/500") @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error500(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request,isIncludeStackTrace(request, MediaType.TEXT_HTML)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125;&#125; 代码也很简单，只是实现了自定义的500错误的映射解析，分别对浏览器请求以及json请求做了回应。 BasicErrorController默认对应的@RequestMapping是/error，固我们方法里面对应的@RequestMapping(produces = “text/html”,value = “/500”)实际上完整的映射请求是/error/500，这就跟上面 customize 方法自定义的映射路径对上了。 errorHtml500 方法中，我返回的是模板页面，对应/templates/error/500.html，这里顺便自定义了一个msg信息，在500.html也输出这个信息，如果输出结果有这个信息，则表示我们配置正确了。 再次访问请求http://localhost:8080/spring/ex ，结果如下 通过@ControllerAdvice注解来处理异常Spring Boot提供的ErrorController是一种全局性的容错机制。此外，你还可以用@ControllerAdvice注解和@ExceptionHandler注解实现对指定异常的特殊处理。 这里介绍两种情况： 局部异常处理 @Controller + @ExceptionHandler 全局异常处理 @ControllerAdvice + @ExceptionHandler 局部异常处理 @Controller + @ExceptionHandler局部异常主要用到的是@ExceptionHandler注解，此注解注解到类的方法上，当此注解里定义的异常抛出时，此方法会被执行。如果@ExceptionHandler所在的类是@Controller，则此方法只作用在此类。如果@ExceptionHandler所在的类带有@ControllerAdvice注解，则此方法会作用在全局。 该注解用于标注处理方法处理那些特定的异常。被该注解标注的方法可以有以下任意顺序的参数类型： 1234567ServletRequest、HttpServletRequest、ServletResponse、HttpServletResponse；HttpSession 等会话对象；org.springframework.web.context.request.WebRequest；java.util.Locale；java.io.InputStream、java.io.Reader；java.io.OutputStream、java.io.Writer；org.springframework.ui.Model； 并且被该注解标注的方法可以有以下的返回值类型可选： 1234567ModelAndView；org.springframework.ui.Model；java.util.Map；org.springframework.web.servlet.View；@ResponseBody 注解标注的任意对象；HttpEntity&lt;?&gt; or ResponseEntity&lt;?&gt;；void； 以上罗列的不完全，更加详细的信息可参考：Spring ExceptionHandler Throwable、Exception 等异常对象； 举个简单例子，这里我们对除0异常用@ExceptionHandler来捕捉。 1234567891011121314151617181920212223@Controllerpublic class BaseErrorController extends AbstractController&#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(value="/ex") @ResponseBody public String error()&#123; int i=5/0; return "ex"; &#125; //局部异常处理 @ExceptionHandler(Exception.class) @ResponseBody public String exHandler(Exception e)&#123; // 判断发生异常的类型是除0异常则做出响应 if(e instanceof ArithmeticException)&#123; return "发生了除0异常"; &#125; // 未知的异常做出响应 return "发生了未知异常"; &#125;&#125; 全局异常处理 @ControllerAdvice + @ExceptionHandler在spring 3.2中，新增了@ControllerAdvice 注解，可以用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping中。 简单的说，进入Controller层的错误才会由@ControllerAdvice处理，拦截器抛出的错误以及访问错误地址的情况@ControllerAdvice处理不了，由SpringBoot默认的异常处理机制处理。 我们实际开发中，如果是要实现RESTful API，那么默认的JSON错误信息就不是我们想要的，这时候就需要统一一下JSON格式，所以需要封装一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*** 返回数据*/public class AjaxObject extends HashMap&lt;String, Object&gt; &#123; private static final long serialVersionUID = 1L; public AjaxObject() &#123; put("code", 0); &#125; public static AjaxObject error() &#123; return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, "未知异常，请联系管理员"); &#125; public static AjaxObject error(String msg) &#123; return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg); &#125; public static AjaxObject error(int code, String msg) &#123; AjaxObject r = new AjaxObject(); r.put("code", code); r.put("msg", msg); return r; &#125; public static AjaxObject ok(String msg) &#123; AjaxObject r = new AjaxObject(); r.put("msg", msg); return r; &#125; public static AjaxObject ok(Map&lt;String, Object&gt; map) &#123; AjaxObject r = new AjaxObject(); r.putAll(map); return r; &#125; public static AjaxObject ok() &#123; return new AjaxObject(); &#125; public AjaxObject put(String key, Object value) &#123; super.put(key, value); return this; &#125; public AjaxObject data(Object value) &#123; super.put("data", value); return this; &#125; public static AjaxObject apiError(String msg) &#123; return error(1, msg); &#125;&#125; 上面这个AjaxObject就是我平时用的，如果是正确情况返回的就是： 1234567&#123; code：0， msg：“获取列表成功”， data：&#123; queryList :[] &#125;&#125; 然后创建一个自定义的异常类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BusinessException extends RuntimeException implements Serializable &#123; private static final long serialVersionUID = 1L; private String msg; private int code = 500; public BusinessException(String msg) &#123; super(msg); this.msg = msg; &#125; public BusinessException(String msg, Throwable e) &#123; super(msg, e); this.msg = msg; &#125; public BusinessException(int code,String msg) &#123; super(msg); this.msg = msg; this.code = code; &#125; public BusinessException(String msg, int code, Throwable e) &#123; super(msg, e); this.msg = msg; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125;&#125; 注：spring 对于 RuntimeException 异常才会进行事务回滚 Controler中添加一个json映射，用来处理这个异常 12345678@Controllerpublic class BaseErrorController&#123; @RequestMapping("/json") public void json(ModelMap modelMap) &#123; System.out.println(modelMap.get("author")); int i=5/0; &#125;&#125; 最后创建这个全局异常处理类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 异常处理器 */@RestControllerAdvicepublic class BusinessExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); /** * 应用到所有@RequestMapping注解方法，在其执行之前初始化数据绑定器 * @param binder */ @InitBinder public void initBinder(WebDataBinder binder) &#123; System.out.println("请求有参数才进来"); &#125; /** * 把值绑定到Model中，使全局@RequestMapping可以获取到该值 * @param model */ @ModelAttribute public void addAttributes(Model model) &#123; model.addAttribute("author", "嘟嘟MD"); &#125; @ExceptionHandler(Exception.class) public Object handleException(Exception e,HttpServletRequest req)&#123; AjaxObject r = new AjaxObject(); //业务异常 if(e instanceof BusinessException)&#123; r.put("code", ((BusinessException) e).getCode()); r.put("msg", ((BusinessException) e).getMsg()); &#125;else&#123;//系统异常 r.put("code","500"); r.put("msg","未知异常，请联系管理员"); &#125; //使用HttpServletRequest中的header检测请求是否为ajax, 如果是ajax则返回json, 如果为非ajax则返回view(即ModelAndView) String contentTypeHeader = req.getHeader("Content-Type"); String acceptHeader = req.getHeader("Accept"); String xRequestedWith = req.getHeader("X-Requested-With"); if ((contentTypeHeader != null &amp;&amp; contentTypeHeader.contains("application/json")) || (acceptHeader != null &amp;&amp; acceptHeader.contains("application/json")) || "XMLHttpRequest".equalsIgnoreCase(xRequestedWith)) &#123; return r; &#125; else &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("msg", e.getMessage()); modelAndView.addObject("url", req.getRequestURL()); modelAndView.addObject("stackTrace", e.getStackTrace()); modelAndView.setViewName("error"); return modelAndView; &#125; &#125;&#125; @ExceptionHandler 拦截了异常，我们可以通过该注解实现自定义异常处理。其中，@ExceptionHandler 配置的 value 指定需要拦截的异常类型，上面我配置了拦截Exception，再根据不同异常类型返回不同的相应，最后添加判断，如果是Ajax请求，则返回json,如果是非ajax则返回view，这里是返回到error.html页面。 为了展示错误的时候更友好，我封装了下error.html,不仅展示了错误，还添加了跳转百度谷歌以及StackOverFlow的按钮，如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org" layout:decorator="layout"&gt;&lt;head&gt; &lt;title&gt;Spring Boot管理后台&lt;/title&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div layout:fragment="content" th:remove="tag"&gt; &lt;div id="navbar"&gt; &lt;h1&gt;系统异常统一处理&lt;/h1&gt; &lt;h3 th:text="'错误信息：'+$&#123;msg&#125;"&gt;&lt;/h3&gt; &lt;h3 th:text="'请求地址：'+$&#123;url&#125;"&gt;&lt;/h3&gt; &lt;h2&gt;Debug&lt;/h2&gt; &lt;a th:href="@&#123;'https://www.google.com/webhp?hl=zh-CN#safe=strict&amp;hl=zh-CN&amp;q='+$&#123;msg&#125;&#125;" class="btn btn-primary btn-lg" target="_blank" id="Google"&gt;Google&lt;/a&gt; &lt;a th:href="@&#123;'https://www.baidu.com/s?wd='+$&#123;msg&#125;&#125;" class="btn btn-info btn-lg" target="_blank" id="Baidu"&gt;Baidu&lt;/a&gt; &lt;a th:href="@&#123;'http://stackoverflow.com/search?q='+$&#123;msg&#125;&#125;" class="btn btn-default btn-lg" target="_blank" id="StackOverFlow"&gt;StackOverFlow&lt;/a&gt; &lt;h2&gt;异常堆栈跟踪日志StackTrace&lt;/h2&gt; &lt;div th:each="line:$&#123;stackTrace&#125;"&gt; &lt;div th:text="$&#123;line&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div layout:fragment="js" th:remove="tag"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 访问 http://localhost:8080/json 的时候,因为是浏览器发起的，返回的是error界面： 如果是ajax请求，返回的就是错误： 1&#123; "msg":"未知异常，请联系管理员", "code":500 &#125; 这里我给带@ModelAttribute注解的方法通过Model设置了author值，在json映射方法中通过 ModelMwap 获取到改值。 认真的你可能发现，全局异常类我用的是@RestControllerAdvice，而不是@ControllerAdvice，因为这里返回的主要是json格式，这样可以少写一个@ResponseBody。 总结到此，SpringBoot中对异常的使用也差不多全了，本项目中处理异常的顺序会是这样，当发送一个请求： 拦截器那边先判断是否登录，没有则返回登录页。 在进入Controller之前，譬如请求一个不存在的地址，返回404错误界面。 在执行@RequestMapping时，发现的各种错误（譬如数据库报错、请求参数格式错误/缺失/值非法等）统一由@ControllerAdvice处理，根据是否Ajax返回json或者view。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker：简介]]></title>
    <url>%2F2018%2F12%2F07%2Fdocker%EF%BC%9A%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[参考： https://mp.weixin.qq.com/s?src=11&amp;timestamp=1543970179&amp;ver=1283&amp;signature=dn5DgnKs2J2yUd7VvmKjsb-uL5RJgnl1VKGsyxX4COsRSx*igc9g42iAU5pEXQ2FLaVT1QnYRn5HsReBmIGIMdJuxOyv9y0h*cpyQXzy5rlto*QwRgGJ7vm6dmFDuhc-&amp;new=1 http://dockone.io/article/126 维基百科： Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines. Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。——摘自维基百科 现在服务器部署问题1. 合作开发的时候，在本机可以跑，别人的电脑跑不起来。这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、spring等等。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序直接打包成镜像，直接运行在容器中即可。 2. 服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了。这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。 3. 公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器。在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。 Docker与虚拟机的区别 比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。 1. 简化配置这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。 2. 代码流水线（Code Pipeline）管理前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。 3. 提高开发效率这就带来了一些额外的好处：Docker能提升开发者的开发效率。如果你想看一个详细一点的例子，可以参考Aater在DevOpsDays Austin 2014 大会或者是DockerCon上的演讲。不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。 4. 隔离应用有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。 5. 整合服务器正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。 6. 调试能力Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。 7. 多租户环境另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（译者注：物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。你可以在这里了解关于此场景的更多信息。 8. 快速部署在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib画3D图]]></title>
    <url>%2F2018%2F12%2F07%2Fmatplotlib%E7%94%BB3D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)X = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)# 具体函数方法可用 help(function) 查看，如：help(ax.plot_surface)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='rainbow')plt.show()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别作业]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[以下述两类模式为样本，用感知器算法求判别函数：ω1:{(0 0 0)t,(1 0 0)t,(1 0 1)t,(1 1 0)t}; ω2:{(0 0 1)t,(0 1 1)t,(0 1 0)t,(1 1 1)t}.且令W(1)=(-1 –2 –2 0)t， C=1. 画出上题所给的二类样本，及所求的判决界面。 用LMSE算法对题1所给的两样本求判别函数 (可取C=1或C=2) 。 用势函数算法对题1所给的两样本求判别函数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import numpy as npfrom matplotlib import pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dnp1 = np.array([[0, 0, 0], [1, 0, 0], [1, 0, 1], [1, 1, 0]])np2 = np.array([[0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1]])new_np1 = np.c_[np1, np.array([1, 1, 1, 1])]new_np2 = np.c_[np2, np.array([1, 1, 1, 1])]# print(new_np1)# print(new_np2)C = 1args = [[0, 0, 0, 1]]def question1(): w = dict() w[1] = np.array([-1, -2, -2, 0]) change_w = list() i = 1 error = 1 while error != 0: error = 0 for row in new_np1: # 在new_np1中的计算结果必须&gt;0，惩罚为+C*row # if (w[i] * row).sum() &gt; 0: if w[i].dot(row) &gt; 0: w[i + 1] = w[i] else: w[i + 1] = w[i] + C * row error += 1 print("the new w[%s] is :%s" % (i + 1, str(w[i + 1]))) change_w.append(w[i + 1]) i += 1 for row in new_np2: # 在new_np1中的计算结果必须&lt;0，惩罚为-C*row # if (w[i] * row).sum() &lt; 0: if w[i].dot(row) &lt; 0: w[i + 1] = w[i] else: w[i + 1] = w[i] - C * row error += 1 print("the new w[%s] is :%s" % (i + 1, str(w[i + 1]))) change_w.append(w[i + 1]) i += 1 print(w) return change_wdef question2(w): for np_w in w[-1:]: fig = plt.figure() ax = Axes3D(fig) ax.scatter(np.array([0, 1, 1, 1]), np.array([0, 0, 0, 1]), np.array([0, 0, 1, 0]), c='red', marker='o') ax.scatter(np.array([0, 0, 0, 1]), np.array([0, 1, 1, 1]), np.array([1, 1, 0, 1]), c='blue', marker='^') print(np_w) # 生成[0，2] 间隔0.5的数列，间隔越小，曲面越平滑 X = np.arange(0, 2, 0.5) Y = np.arange(0, 2, 0.5) # 原为F(x)= ax1+bx2+cx3+d,x3作为z放到左边,右边全为负且需要除以参数c X_arg = np_w[0] / np_w[2] Y_arg = np_w[1] / np_w[2] H = np_w[3] / np_w[2] # 格点矩阵 X, Y = np.meshgrid(X, Y) Z = - X * X_arg - Y * Y_arg - H ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='rainbow') ax.set_xlabel('X Label') ax.set_ylabel('Y Label') ax.set_zlabel('Z Label') plt.show()def question3(): C = 2 lmse_np = np.concatenate((new_np1, -new_np2), axis=0) lmse_pinv_np = np.linalg.pinv(lmse_np) b = dict() print(lmse_pinv_np) b[1] = np.array([1, 1, 1, 1, 1, 1, 1, 1]) w = dict() w[1] = lmse_pinv_np @ b[1] e = dict() e[1] = lmse_np @ w[1] - b[1] print(e[1]) error = 1 i = 1 # 向量的模 np.sum(vector**2)**0.5 while error != 0: if all(e[i] &lt;= 0.01): error = 0 else: b[i + 1] = b[i] + C * (e[i] + abs(e[i])) w[i + 1] = lmse_pinv_np @ b[i + 1] e[i + 1] = lmse_np @ w[i + 1] - b[i + 1] # print(e[i]) print("b[%s]:%s" % (i, b[i])) print("w[%s]:%s" % (i, w[i])) print("e[%s]:%s" % (i, e[i])) i += 1 # np.around()四舍五入取近似值 print("判别函数为：" + str(np.around(w[i])))def f(x, y, z, args=args): sum = 0 for l in args: sum += l[3] * np.exp(-((x - l[0]) ** 2 + (y - l[1]) ** 2 + (z - l[2]) ** 2)) return sumdef plot_implicit(fn, bbox=(-1, 1)): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ''' create a plot of an implicit function fn ...implicit function (plot where fn==0) bbox ..the x,y,and z limits of plotted interval''' xmin, xmax, ymin, ymax, zmin, zmax = bbox * 3 A = np.linspace(xmin, xmax, 100) # resolution of the contour B = np.linspace(xmin, xmax, 15) # number of slices A1, A2 = np.meshgrid(A, A) # grid on which the contour is plotted ax.scatter(np.array([0, 1, 1, 1]), np.array([0, 0, 0, 1]), np.array([0, 0, 1, 0]), c='red', marker='o') ax.scatter(np.array([0, 0, 0, 1]), np.array([0, 1, 1, 1]), np.array([1, 1, 0, 1]), c='blue', marker='^') for z in B: # plot contours in the XY plane X, Y = A1, A2 Z = fn(X, Y, z) cset = ax.contour(X, Y, Z + z, [z], zdir='z') # [z] defines the only level to plot for this contour for this value of z for y in B: # plot contours in the XZ plane X, Z = A1, A2 Y = fn(X, y, Z) cset = ax.contour(X, Y + y, Z, [y], zdir='y') for x in B: # plot contours in the YZ plane Y, Z = A1, A2 X = fn(x, Y, Z) cset = ax.contour(X + x, Y, Z, [x], zdir='x') # must set plot limits because the contour will likely extend # way beyond the displayed level. Otherwise matplotlib extends the plot limits # to encompass all values in the contour. ax.set_zlim3d(zmin, zmax) ax.set_xlim3d(xmin, xmax) ax.set_ylim3d(ymin, ymax) plt.show()def question4(): error = 1 while error != 0: error = 0 for f_arg in np1: if f(f_arg[0], f_arg[1], f_arg[2]) &gt; 0: continue else: args.append([f_arg[0], f_arg[1], f_arg[2], 1]) print("修正：" + str(args)) error = 1 for f_arg in np2: if f(f_arg[0], f_arg[1], f_arg[2]) &lt; 0: continue else: args.append([f_arg[0], f_arg[1], f_arg[2], -1]) print("修正：" + str(args)) error = 1 plot_implicit(f, bbox=(-1, 1))if __name__ == '__main__': list_for_q2 = question1() question2(list_for_q2) question3() question4()]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>感知器算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：设置global变量]]></title>
    <url>%2F2018%2F12%2F07%2Freact%EF%BC%9A%E8%AE%BE%E7%BD%AEglobal%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[创建一个config.js，在其他react的js文件中引入：123456789global.serverConfig = &#123; domainName:'http://localhost', port:'2222', project:'project',&#125;;global.server = &#123; host:global.serverConfig.domainName + ':' + global.serverConfig.port + '/' + global.serverConfig.project + '/',&#125;; 即1global.server.host = 'httpL//localhost:2222/project/' 其他react的js文件中引入并可以直接调用：123import '/config'alert(global.server.host)]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：搜索中设置回车搜索和点击搜索]]></title>
    <url>%2F2018%2F12%2F07%2Freact%EF%BC%9A%E6%90%9C%E7%B4%A2%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%BD%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E7%82%B9%E5%87%BB%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839class Com_search extends Component &#123; constructor () &#123; super(); this.state = &#123; code: '', &#125; &#125; handleUsernameChange (event) &#123; this.setState(&#123; code: event.target.value &#125;); &#125; triggerSearch()&#123; console.log(this.state.code.trim()); &#125; keyDownSearch()&#123; if(window.event.keyCode === 13) &#123; console.log(this.state.code.trim()); &#125; &#125; render() &#123; return ( &lt;div className="search-panel"&gt; &lt;div className="content"&gt; &lt;a href='/index'&gt;&lt;div className="logo"/&gt;&lt;/a&gt; &lt;div className="search-wrap"&gt; &lt;input placeholder="请输入关键词" onKeyDown=&#123;this.keyDownSearch.bind(this)&#125; defaultValue=&#123;this.state.code&#125; onChange=&#123;this.handleUsernameChange.bind(this)&#125; /&gt; &lt;div className="butn" onClick=&#123;this.triggerSearch.bind(this)&#125; &gt;搜索&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Com_search; 搜索框使用onKeyDown方法，在keyDownSearch中判断按键是否为回车，回车即调用； 点击div的搜索，即调用onClick方法，直接进行搜索。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：form的textarea]]></title>
    <url>%2F2018%2F12%2F04%2Freact%EF%BC%9Aform%E7%9A%84textarea%2F</url>
    <content type="text"><![CDATA[使用react框架的form表单，input标签填入this.state的值的时候，要用defaultValue，使用value属性会报错； 但是使用textarea，要使用value属性，使用defaultValue属性不能显示this.state的值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：测试，打包，部署]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9A%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%89%93%E5%8C%85%EF%BC%8C%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[开发阶段单元测试 在pom包中添加spring-boot-starter-test包引用 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 开发测试类 以最简单的helloworld为例，在测试类的类头部需要添加：@RunWith(SpringRunner.class)和@SpringBootTest注解，在测试方法的顶端添加@Test即可，最后在方法上点击右键run就可以运行。 12345678910@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Test public void hello() &#123; System.out.println("hello world"); &#125;&#125; 实际使用中，可以按照项目的正常使用去注入dao层代码或者是service层代码进行测试验证，spring-boot-starter-test提供很多基础用法，更难得的是增加了对Controller层测试的支持。123456//简单验证结果集是否正确Assert.assertEquals(3, userMapper.getAll().size());//验证结果集，提示Assert.assertTrue("错误，正确的返回值为200", status == 200); Assert.assertFalse("错误，正确的返回值为200", status != 200); 引入了MockMvc支持了对Controller层的测试，简单示例如下：12345678910111213141516171819202122232425262728public class HelloControlerTests &#123; private MockMvc mvc; //初始化执行 @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; //验证controller是否正常响应并打印返回结果 @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125; //验证controller是否正常响应并判断返回结果是否正确 @Test public void testHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 单元测试是验证你代码第一道屏障，要养成每写一部分代码就进行单元测试的习惯，不要等到全部集成后再进行测试，集成后因为更关注整体运行效果，很容易遗漏掉代码底层的bug。 打包一般分为两种；一种是打包成jar包直接执行，另一种是打包成war包放到tomcat服务器下。 jar包如果你使用的是maven来管理项目，执行以下命令既可以12345cd 项目跟目录（和pom.xml同级）mvn clean package## 或者执行下面的命令## 排除测试代码后进行打包mvn clean package -Dmaven.test.skip=true 打包完成后jar包会生成到target目录下，命名一般是 项目名+版本号.jar 弃用jar包命令：1java -jar target/spring-boot-scheduler-1.0.0.jar 这种方式，只要控制台关闭，服务就不能访问了。下面我们使用在后台运行的方式来启动:1nohup java -jar target/spring-boot-scheduler-1.0.0.jar &amp; 也可以在启动的时候选择读取不同的配置文件1java -jar app.jar --spring.profiles.active=dev 也可以在启动的时候设置jvm参数1java -Xms10m -Xmx80m -jar app.jar &amp; 打成war包打成war包一般可以分两种方式来实现，第一种可以通过eclipse这种开发工具来导出war包，另外一种是使用命令来完成，这里主要介绍后一种 maven项目，修改pom包 将1&lt;packaging&gt;jar&lt;/packaging&gt; 改为1&lt;packaging&gt;war&lt;/packaging&gt; 打包时排除tomcat.123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在这里将scope属性设置为provided，这样在最终形成的WAR中不会包含这个JAR包，因为Tomcat或Jetty等服务器在运行时将会提供相关的API类。 注册启动类 创建ServletInitializer.java，继承SpringBootServletInitializer ，覆盖configure()，把启动类Application注册进去。外部web应用服务器构建Web Application Context的时候，会把启动类添加进去。123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125;&#125; 最后执行1mvn clean package -Dmaven.test.skip=true 会在target目录下生成：项目名+版本号.war文件，拷贝到tomcat服务器中启动即可。 生产运维查看JVM参数可以根据java自带的jinfo命令：1jinfo -flags pid 来查看jar 启动后使用的是什么gc、新生代、老年代分批的内存都是多少，示例如下：1-XX:CICompilerCount=3 -XX:InitialHeapSize=234881024 -XX:MaxHeapSize=3743416320 -XX:MaxNewSize=1247805440 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=78118912 -XX:OldSize=156762112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC -XX:CICompilerCount ：最大的并行编译数 -XX:InitialHeapSize 和 -XX:MaxHeapSize ：指定JVM的初始和最大堆内存大小 -XX:MaxNewSize ： JVM堆区域新生代内存的最大可分配大小 … -XX:+UseParallelGC ：垃圾回收使用Parallel收集器 重启直接kill掉进程再次启动jar包12345ps -ef|grep java ##拿到对于Java程序的pidkill -9 pid## 再次重启Java -jar xxxx.jar 脚本执行如果使用的是maven,需要包含以下的配置1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt;&lt;/plugin&gt; 启动方式： 可以直接./yourapp.jar 来启动 注册为服务 也可以做一个软链接指向你的jar包并加入到init.d中，然后用命令来启动。 init.d 例子:12ln -s /var/yourapp/yourapp.jar /etc/init.d/yourappchmod +x /etc/init.d/yourapp 这样就可以使用stop或者是restart命令去管理你的应用。1/etc/init.d/yourapp start|stop|restart 或者1service yourapp start|stop|restart]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>部署</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：mybatis多数据源]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Amybatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mulidatasource.git 配置文件数据库配置：123456789101112mybatis.config-locations=classpath:mybatis/mybatis-config.xmlspring.datasource.test1.driverClassName = com.mysql.jdbc.Driverspring.datasource.test1.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.test1.username = rootspring.datasource.test1.password = 123456spring.datasource.test2.driverClassName = com.mysql.jdbc.Driverspring.datasource.test2.url = jdbc:mysql://localhost:3306/spring2?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.test2.username = rootspring.datasource.test2.password = 123456 一个test1库和一个test2库，其中test1位主库，在使用的过程中必须指定主库，不然会报错。 数据源配置123456789101112131415161718192021222324252627282930313233@Configuration@MapperScan(basePackages = "com.neo.mapper.test1", sqlSessionTemplateRef = "test1SqlSessionTemplate")public class DataSource1Config &#123; @Bean(name = "test1DataSource") @ConfigurationProperties(prefix = "spring.datasource.test1") @Primary public DataSource testDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = "test1SqlSessionFactory") @Primary public SqlSessionFactory testSqlSessionFactory(@Qualifier("test1DataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mybatis/mapper/test1/*.xml")); return bean.getObject(); &#125; @Bean(name = "test1TransactionManager") @Primary public DataSourceTransactionManager testTransactionManager(@Qualifier("test1DataSource") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = "test1SqlSessionTemplate") @Primary public SqlSessionTemplate testSqlSessionTemplate(@Qualifier("test1SqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 最关键的地方就是这块了，一层一层注入,首先创建DataSource，然后创建SqlSessionFactory再创建事务，最后包装到SqlSessionTemplate中。其中需要指定分库的mapper文件地址，以及分库dao层代码1@MapperScan(basePackages = "com.neo.mapper.test1", sqlSessionTemplateRef = "test1SqlSessionTemplate") 这块的注解就是指明了扫描dao层，并且给dao层注入指定的SqlSessionTemplate。所有@Bean都需要按照命名指定正确。 dao层和xml层dao层和xml需要按照库来分在不同的目录，比如：test1库dao层在com.neo.mapper.test1包下，test2库在com.neo.mapper.test112345678910111213public interface User1Mapper &#123; List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id);&#125; xml层：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.neo.mapper.test1.User1Mapper" &gt; &lt;resultMap id="BaseResultMap" type="com.neo.entity.UserEntity" &gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="userName" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="passWord" property="passWord" jdbcType="VARCHAR" /&gt; &lt;result column="user_sex" property="userSex" javaType="com.neo.enums.UserSexEnum"/&gt; &lt;result column="nick_name" property="nickName" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, passWord, user_sex, nick_name &lt;/sql&gt; &lt;select id="getAll" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users &lt;/select&gt; &lt;select id="getOne" parameterType="java.lang.Long" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insert" parameterType="com.neo.entity.UserEntity" &gt; INSERT INTO users (userName,passWord,user_sex) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;) &lt;/insert&gt; &lt;update id="update" parameterType="com.neo.entity.UserEntity" &gt; UPDATE users SET &lt;if test="userName != null"&gt;userName = #&#123;userName&#125;,&lt;/if&gt; &lt;if test="passWord != null"&gt;passWord = #&#123;passWord&#125;,&lt;/if&gt; nick_name = #&#123;nickName&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="delete" parameterType="java.lang.Long" &gt; DELETE FROM users WHERE id =#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; controller测试可以使用SpringBootTest,也可以放到Controller中，这里只贴Controller层的使用12345678910111213141516171819202122232425262728293031323334353637@RestControllerpublic class UserController &#123; @Autowired private User1Mapper user1Mapper; @Autowired private User2Mapper user2Mapper; @RequestMapping("/getUsers") public List&lt;UserEntity&gt; getUsers() &#123; List&lt;UserEntity&gt; users=user1Mapper.getAll(); return users; &#125; @RequestMapping("/getUser") public UserEntity getUser(Long id) &#123; UserEntity user=user2Mapper.getOne(id); return user; &#125; @RequestMapping("/add") public void save(UserEntity user) &#123; user2Mapper.insert(user); &#125; @RequestMapping(value="update") public void update(UserEntity user) &#123; user2Mapper.update(user); &#125; @RequestMapping(value="/delete/&#123;id&#125;") public void delete(@PathVariable("id") Long id) &#123; user1Mapper.delete(id); &#125; &#125; 测试 分别用的是数据源1，数据源2。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：随机端口]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[为Spring Cloud的应用实用随机端口非常简单，主要有两种方法： 设置server.port=0，当应用启动的时候会自动的分配一个随机端口，但是该方式在注册到Eureka的时候会一个问题：所有实例都使用了同样的实例名（如：Lenovo-test:hello-service:0），这导致只出现了一个实例。所以，我们还需要修改实例ID的定义，让每个实例的ID不同，比如使用随机数来配置实例ID：12server.port=0eureka.instance.instance-id=$&#123;spring.application.name&#125;:$&#123;random.int&#125; 除了上面的方法，实际上我们还可以直接使用random函数来配置server.port。这样就可以指定端口的取值范围，比如：1server.port=$&#123;random.int[10000,19999]&#125; 由于默认的实例ID会由server.port拼接，而此时server.port设置的随机值会重新取一次随机数，所以使用这种方法的时候不需要重新定义实例ID的规则就能产生不同的实例ID了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：thymeleaf设置不校验html标签]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Athymeleaf%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%A0%A1%E9%AA%8Chtml%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[默认配置下，thymeleaf对.html的内容要求很严格，比如，如果少封闭符号/，就会报错而转到错误页。也比如你在使用Vue.js这样的库，然后有这样的html代码，也会被thymeleaf认为不符合要求而抛出错误。 通过设置thymeleaf模板可以解决这个问题，下面是具体的配置:12spring.thymeleaf.cache=falsespring.thymeleaf.mode=LEGACYHTML5 LEGACYHTML5需要搭配一个额外的库NekoHTML才可用 项目中使用的构建工具是Maven添加如下的依赖即可完成: 12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：task定时任务（二）]]></title>
    <url>%2F2018%2F12%2F03%2Fspringboot%EF%BC%9Atask%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.springtask2.git pom包配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 启动类启用定时在启动类上面加上@EnableScheduling即可开启定时12345678@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建定时任务实现类定时任务1：1234567891011@Componentpublic class SchedulerTask &#123; private int count=0; @Scheduled(cron="*/6 * * * * ?") private void process()&#123; System.out.println("this is scheduler task runing "+(count++)); &#125;&#125; 定时任务2：1234567891011@Componentpublic class Scheduler2Task &#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + dateFormat.format(new Date())); &#125;&#125; 结果如下：12345678this is scheduler task runing 0现在时间：09:44:17this is scheduler task runing 1现在时间：09:44:23this is scheduler task runing 2现在时间：09:44:29this is scheduler task runing 3现在时间：09:44:35 参数说明@Scheduled 参数可以接受两种定时的设置，一种是我们常用的cron=”/6 * ?”,一种是 fixedRate = 6000，两种都表示每隔六秒打印一下内容。 fixeRate说明 @Scheduled(fixedRate = 6000) ：上一次开始执行时间点之后6秒再执行 @Scheduled(fixedDelay = 6000) ：上一次执行完毕时间点之后6秒再执行 @Scheduled(initialDelay=1000, fixedRate=6000) ：第一次延迟1秒后执行，之后按fixedRate的规则每6秒执行一次]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：解决分页插件ClassNotFoundException]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6ClassNotFoundException%2F</url>
    <content type="text"><![CDATA[报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration&apos;: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration] from ClassLoader [sun.misc.Launcher$AppClassLoader@2f4d3709]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:558) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:503) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:760) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE]at com.lee.www.DemoApplication.main(DemoApplication.java:14) [classes/:na]at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_161]at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_161]at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_161]at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_161]at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) [idea_rt.jar:na]Caused by: java.lang.IllegalStateException: Failed to introspect Class [com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration] from ClassLoader [sun.misc.Launcher$AppClassLoader@2f4d3709]at org.springframework.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:758) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.util.ReflectionUtils.doWithLocalFields(ReflectionUtils.java:690) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.buildResourceMetadata(CommonAnnotationBeanPostProcessor.java:355) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.findResourceMetadata(CommonAnnotationBeanPostProcessor.java:339) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(CommonAnnotationBeanPostProcessor.java:298) ~[spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(AbstractAutowireCapableBeanFactory.java:1022) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.0.7.RELEASE.jar:5.0.7.RELEASE]... 20 common frames omittedCaused by: java.lang.NoClassDefFoundError: Lorg/springframework/boot/bind/RelaxedPropertyResolver;at java.lang.Class.getDeclaredFields0(Native Method) ~[na:1.8.0_161]at java.lang.Class.privateGetDeclaredFields(Class.java:2583) ~[na:1.8.0_161]at java.lang.Class.getDeclaredFields(Class.java:1916) ~[na:1.8.0_161]at org.springframework.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:753) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]... 26 common frames omittedCaused by: java.lang.ClassNotFoundException: org.springframework.boot.bind.RelaxedPropertyResolverat java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_161]at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_161]at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) ~[na:1.8.0_161]at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_161]... 30 common frames omitted 重点是ClassNotFoundException: org.springframework.boot.bind.RelaxedPropertyResolver。 原版本为：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt; 升级为1.2.3即可：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：日期错误Zero date value prohibited 异常的解决方法]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E6%97%A5%E6%9C%9F%E9%94%99%E8%AF%AFZero-date-value-prohibited-%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实际的错误还应该有：java.sql.SQLException: Value ‘0000-00-00’ can not be represented as java.sql.Date 更改jdbc连接为：1jdbc:mysql://yourserver:3306/yourdatabase?zeroDateTimeBehavior=convertToNull 即设置zeroDateTimeBehavior=convertToNull 设置zeroDateTimeBehavior 属性，当遇到DATETIME值完全由0组成时，最终的有效值可以设置为，异常(exception)，一个近似值(round)，或将这个值转换为null(convertToNull)。 使用convertToNull，返回null来替代0000-00-00这样的日期。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：项目修改访问端口和访问路径]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3%E5%92%8C%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[创建SpringBoot项目，启动后，默认的访问路径即主机IP+默认端口号8080。 修改端口号使用properties文件方式：在src/main/resoutces目录下创建：application.properties，添加如下配置即可修改端口号：1server.port=8088 使用yml文件方式：在src/main/resoutces目录下创建：application.yml，添加如下配置即可修改端口号：12server: port:8088 修改项目访问路径使用properties文件方式：在application.properties，添加如下配置即可修改项目访问路径：1server.servlet.context-path=/test 使用yml文件方式：在src/main/resoutces目录下创建：application.yml，添加如下配置即可修改端口号：1234server: port:8088 servlet: context-path:/test]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：报错Invalid CORS request， CORS 跨域请求设置]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%EF%BC%9A%E6%8A%A5%E9%94%99Invalid-CORS-request%EF%BC%8C-CORS-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot提供的跨域配置有两种，一种是全局的，一种是具体到方法的。如果同时配置了那么具体方法的优先。 全局跨域配置提供一个自定义的WebMvcConfigurer bean，该bean的addCorsMappings方法中定义自己的跨域配置。可以看到我的跨域配置是允许来自http://localhost:6677访问/user/users/*的方法。等程序运行后我们可以发现如果我们的前端使用http://127.0.0.1:6677 或者我们的前端运行在http://localhost:8080都无法通过rest访问对应的API（备注，示例程序提供了/user/users和/user/users/{userId}方法）1234567891011121314151617181920212223242526package com.yq;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@SpringBootApplicationpublic class CorsDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CorsDemoApplication.class, args); &#125; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**").allowedOrigins("http://localhost:6677"); &#125; &#125;; &#125;&#125; 此处，设置addMapping是设置访问路径（pathPattern—），设置了可以被跨域访问的路径和可以被哪些主机跨域访问，而不是设置包的路径。即包名为app.api.controller，但是controller里面的地址设置为/user/paper/，/user/user/，则这里应该写为/user/**。 具体方法的跨域配置@CrossOrigin我们可以使用@CrossOrigin在具体的API上配置跨域设置。@CrossOrigin(origins = “http://localhost:9000”)表明该方法允许来自http://localhost:9000访问，也就是前端可以是localhost:9000。1234567@ApiOperation(value = "查询所有用户") @CrossOrigin(origins = "http://localhost:9000") @GetMapping(value = "/users", produces = "application/json;charset=UTF-8") public Iterable&lt;User&gt; findAllUsers() &#123; Collection&lt;User&gt; users = userMap.values(); return users; &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 与 MyBatis对比]]></title>
    <url>%2F2018%2F12%2F02%2FSpring-Data-JPA-%E4%B8%8E-MyBatis%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[Spring Data JPA是Spring Data的子模块。使用Spring Data，使得基于“repositories”概念的JPA实现更简单和容易。Spring Data JPA的目标是大大简化数据访问层代码的编码。作为使用者，我们只需要编写自己的repository接口，接口中包含一些个性化的查询方法，Spring Data JPA将自动实现查询方法。JPA默认使用hibernate作为ORM实现，所以，一般使用Spring Data JPA即会使用hibernate。我们再看看hibernate的官方概念，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 这样看，Spring Data JPA与MyBatis对比，起始也就是hibernate与MyBatis对比。所以，我们直接来比较后两者。 从基本概念和框架目标上看，两个框架差别还是很大的。hibernate是一个自动化更强、更高级的框架，毕竟在java代码层面上，省去了绝大部分sql编写，取而代之的是用面向对象的方式操作关系型数据库的数据。而MyBatis则是一个能够灵活编写sql语句，并将sql的入参和查询结果映射成POJOs的一个持久层框架。所以，从表面上看，hibernate能方便、自动化更强，而MyBatis 在Sql语句编写方面则更灵活自由。 但这只是从使用层面上看两者的区别，并未涉及的本质。但如果看问题，值看浅层次、表象问题的话，就不能理解技术本质，也不能发挥技术的最多效用。所以，如果更上一个抽象层次去看，对于数据的操作，hibernate是面向对象的，而MyBatis是面向关系的。当然，用hibernate也可以写出面向关系代码和系统，但却得不到面向关系的各种好处，最大的便是编写sql的灵活性，同时也失去面向对象意义和好处——一句话，不伦不类。那么，面向对象和关系型模型有什么不同，体现在哪里呢？实际上两者要面对的领域和要解决的问题是根本不同的：面向对象致力于解决计算机逻辑问题，而关系模型致力于解决数据的高效存取问题。我们不妨对比一下面向对象的概念原则和关系型数据库的不同之处： 面向对象考虑的是对象的整个生命周期包括在对象的创建、持久化、状态的改变和行为等，对象的持久化只是对象的一种状态，而面向关系型数据库的概念则更关注数据的高效存储和读取； 面向对象更强调对象状态的封装性，对象封装自己的状态（或数据）不允许外部对象随意修改，只暴露一些合法的行为方法供外部对象调用；而关系型数据库则是开放的，可以供用户随意读取和修改关系，并可以和其他表任意的关联（只要sql正确允许的情况下）； 面向对象试图为动态的世界建模，他要描述的是世界的过程和规律，进而适应发展和变化，面向对象总是在变化中处理各种各样的变化。而关系型模型为静态世界建模，它通过数据快照记录了世界在某一时候的状态，它是静态的。 从上面两者基本概念和思想的对比来看，可以得出结论hibernate和MyBatis两个框架的侧重点完全不同。所以我们就两个框架选择上，就需要根据不同的项目需求选择不同的框架。在框架的使用中，也要考虑考虑框架的优势和劣势，扬长避短，发挥出框架的最大效用，才能真正的提高项目研发效率、完成项目的目标。但相反，如果使用Spring Data JPA和hibernate等ORM的框架而没有以面向对象思想和方法去分析和设计系统，而是抱怨框架不能灵活操作sql查询数据，那就是想让狗去帮你拿耗子了。 那么，话题再说回来，使用两个框架时候的时候，也要注意最佳的步骤和流程。下面我们来分别讨论一下，hibernate的一般使用步骤如下： 分析、抽象和归纳出系统中的业务概念，并梳理出各个业务概念之间的关系——创建概念模型 根据概念模型，进一步细化设计系统中的对象类以及类的依赖关系——创建设计模型 将设计好的类映射到数据库的表和字段配置好 hibernate可以根据配置信息自动生成数据库表，这个时候也可以集中精力去梳理一下表关系，看看表结构是否合理，并适当调整一下类和表的映射关系，重新生成表结构 完成以上步骤，基本上完成了体统中主要的业务概念类和表结构的设计工作，只是完成表结构设计的出发点事如何持久化系统的对象，同时兼顾数据库表、字段、字段类型、表的关联关系的合理性和合规性，而不是单纯表设计。这两者思考和关注点还是有很大差别的。另外，需要说明一点，这只是使用hibernate的最通用步骤，实际操作过程中还是需要根据具体项目情况来安排。 而MyBatis对于面向对象的概念强调比较少，更适用于灵活的对数据进行增、删、改、查，所以在系统分析和设计过程中，要最大的发挥MyBatis的效用的话，一般使用步骤则与hibernate有所区别： 综合整个系统分析出系统需要存储的数据项目，并画出E-R关系图，设计表结构 根据上一步设计的表结构，创建数据库、表 编写MyBatis的SQL 映射文件、Pojos以及数据库操作对应的接口方法 这样看来MyBatis更适合于面向关系（或面向数据、或面向过程）的系统设计方法，这样的系统一般称为“事务脚步”系统（事务脚步（Transaction Script） 出自Martin Fowler 2004年所著的企业应用架构模式（Patterns of Enterprise Application Architecture））。而hibernate（也可以说Spring Data JPA)更适合于构建领域模型类的系统。当然，我们也不能说MyBatis无法构建领域模型驱动的系统，而hibernate无法构建事务脚步系统。只是用MyBatis构建领域模型要做更多、跟脏、更累的工作；而用hibernate构建一个事务脚本系统有些大材小用，数据的查询反而没那么灵活。 参考：https://www.jianshu.com/p/3927c2b6acc0]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>spring data jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web项目中的dao，service层的接口的必要性]]></title>
    <url>%2F2018%2F12%2F01%2Fjava-web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84dao%EF%BC%8Cservice%E5%B1%82%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[参考：https://www.jianshu.com/p/64abdd29bdf6 https://www.zhihu.com/question/36021012 DAO接口为每个DAO声明接口的好处在于： 可以在尚未实现具体DAO的时候编写上层代码,如Service里对DAO的调用可以为DAO进行多实现,例如有JDBCDAO实现,MyBatisDAO实现,而不需要更改上层代码,只需要简单的在Spring的IoC配置里修改一下注入的DAO实现 Service接口 可以在尚未实现具体Service情况下编写上层改代码,如Controller对Service的调用Spring无论是AOP还是事务管理的实现都是基于动态代理的,而动态代理的实现依赖于接口,所以必须有接口的定义才能使用这些功能可以对Service进行多实现总的来说,接口的优势就在于规范方法参数,返回值,另外可以实现多态,结合Spring来说接口对于使用Spring的各种功能也是不可或缺的 另外,使用接口对于测试代码也是有好处的,对于mock一个方法来说,我们不需要关注方法的具体实现,因为本来mock就会将方法内部实现置空,我们的关注点集中于方法参数以及返回值,所以使用接口对于快速实现流程上的测试是有好处的. 使用接口是为了调用与实现解耦，带来的好处是可以各干各的了，带来的坏处是从一个概念变成了两个概念，增加了系统的复杂度。衡量一下在具体场景中是弊大于利还是利大于弊，就可以做选择了。当然，在大部分场景下，还要考虑一个因素，就是你会不会写接口。没有良好接口设计能力的人，写出来的接口抽象不合理，等于没写，什么好处都得不到，只有坏处，这种情况下干脆别写。那怎么衡量你会不会写接口呢，我的经验是，至少见过一次写了接口后得到明确好处的例子。 什么情况下需要各干各的？ 最简单的场景，写接口的是你，写实现的是你小弟。当然大多数类似情况没必要真的建一个interface然后再让人家去implements，把函数的第一行写好，注释写好，代码提交上，里面的内容让小弟去填就行了。 另一种情况，调用代码先于实现代码编写。比如你开发的是struts这种东西，那你指定得搞个Action接口。 再一种情况，多种业务的模式类似。此时这个接口类实际上相当于某一层的抽象。定义出一个层后，有多种实现，然后通过向调用端注入不同的实现类，实现不同的逻辑。如果这种注入不能在编译期完成的话，也就需要用接口抽象一下。 上面这几种情况写得有点绕，没办法，太难表述了并且好多事我自己也没想明白…… 说到题目中的场景。 先说dao，这玩意儿是做数据库读写的。对应一下上面那几种情况：你作为项目架构师想写两行代码就让苦逼小弟加班干活然则自己去泡妹子的话，可能需要写个interface里面几个抽象的insert、delete之类的函数；项目在快速原型阶段如果客户满意就掏钱买oracle如果客户不满意就得免费MySQL的话，你可能需要定义个dao接口然后先用内存数据库写点能让原型跑起来的实现，等一切有定论了再说；每个类都有一个dao，每个dao都有crud基本方法的话你可能需要定义一个通用Dao接口然后搞点代码技巧不用一个个的去写体力代码从此登上人生巅峰。所以dao接口还是有用的。 再说service，这玩意儿更得具体问题具体分析。不去抠理论的话，什么是service，我的理解就是一段段实现了某个逻辑的代码的组合。所以service是个比dao更抽象的概念，严格来讲dao就是一种service。只不过在java web开发中，dao是个人人都得写的东西，所以都拿出来单说了。因此，后面说的service跟dao没有本质分别。 还是上面说的那几种情况： 先从工序上说，你在写上一层的时候，会用到下一层提供的逻辑，具体表现形式就是各种各样的service类和里面的方法。上一层开搞的时候，一定会知道的一个事是下一层会干什么事，比如“将传入编号对应的人员信息设置为离职”，但下一层的代码不一定已经一行一行写出来了。所以这会儿需要有个接口，让写上层代码的人先能把代码写下去。有各种理由可以支持这种工序的合理性，比如一般来说，上一层的一行代码会对应下一层的好多行代码，那先让写上层代码的人写一遍，解决高端层面的bug，会提高很多效率。 再从抽象角度说，不同业务模块之间的共用，不一定是共用某段代码，也可能是共用某段逻辑框架，这时候就需要抽象一个接口层出来，再通过不同的注入逻辑实现。比如模块1是登记学生信息，模块2是新闻发布，看上去风马牛不相及。但分析下来如果两个模块都有共同点，顺序都是1、验证是否有权限 2、验证输入参数是否合法 3、将输入参数转化为业务数据 4、数据库存取 5、写log，那就可以写一个service接口，里面有上述5个函数，再分别写两个service实现。具体执行的时候，通过各种注入方法，直接new也好，用spring注入也好，实现不同的效果。 当然上面说的这种情况很少有人这么干，因为已经普遍到这个程度，再精化精化就是struts了，java web的各种mvc框架都提供机制给你干这个事。但是每个项目或产品，都应该可以用类似的思路抽象出一些东西，如果抽象合理，会很大程度的提高项目架构的合理性。 这些要是能搞定，那什么写个接口然后实现个mock用于测试这种事，信手拈来。 JavaWeb 开发中，服务器端通常分为表示层、业务层、持久层，这就是所谓的三层架构。三层架构的每一层都有自己的开发模式，即架构模式。 其中，表示层一般是采用 MVC 架构模式，业务层有事务脚本模式、领域模型模式等，持久层有数据映射器模式（Hibernate即是典型的）、入口模式（iBatis、JDBC）。企业应用中最关键的显然是业务层。而对于初学者来说，事务脚本模式是最为简单，最容易掌握的。如果开发团队面向对象设计能力一般，而且业务逻辑相对简单，业务层一般都会采用事务脚本模式。为嘛？简单呀，是个人都能很快学会！（当然，如果业务逻辑复杂，用事务脚本模式就很不明智了。嗯，简单点讲，就是违背了单一职责设计原则，Service类成为万能的上帝，承担了太多职责。。。）那么什么是事务脚本模式呢？所谓事务，就是表示层的一个请求；所谓脚本就是一个方法或者一个函数；所谓事务脚本就是将一次请求封装为一个方法或者一个函数。 在事务脚本模式中，有三类对象。其中，Service类封装业务流程（或者说是界面上的业务流程），DAO类封装对持久层的访问，DTO类封装业务实体对象。各个对象之间的关系如上图所示，这就是所谓业务逻辑的组织方式。 为什么要用Service接口和DAO接口？我们还得回到最基本的面向对象设计原则上去。面向对象设计原则中有三条与此相关：开闭原则、依赖倒转原则、理氏替换原则。还记得依赖倒转原则吧？高层不依赖于低层，二者都依赖于抽象，也就是面向接口编程。为什么要用Service接口？是让表示层不依赖于业务层的具体实现。为什么要用DAO接口？是让业务层不依赖于持久层的具体实现。有了这两个接口，Spring IOC容器才能发挥作用。举个例子，用DAO接口，那么持久层用Hibernate，还是用iBatis，还是 JDBC，随时可以替换，不用修改业务层Service类的代码。使用接口的意义就在此。]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>理论</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：使用Swagger2构建强大的RESTful API文档]]></title>
    <url>%2F2018%2F12%2F01%2Fspringboot%EF%BC%9A%E4%BD%BF%E7%94%A8Swagger2%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84RESTful-API%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.swagger2.git 由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。 这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示： 添加Swagger2依赖在pom.xml中加入Swagger2的依赖：12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger2：12345678910111213141516171819202122232425262728293031323334353637package com.didispace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.didispace.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("更多Spring Boot相关文章请关注：https://snjl.github.io/") .termsOfServiceUrl("https://snjl.github.io/") .contact("snjl") .version("1.0") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.didispace.web;import com.didispace.domain.User;import java.util.*;import io.swagger.annotations.*;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125; 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。 API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！ 此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。 相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：数据存储篇-SQL关系型数据库之MyBatis的使用]]></title>
    <url>%2F2018%2F12%2F01%2Fspringboot%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87-SQL%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMyBatis%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mybatis.git 添加依赖这里需要添加mybatis-spring-boot-starter依赖跟mysql依赖：1234567891011 &lt;!--最新版本，匹配spring Boot1.5 or higher--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖。 MyBatis-Spring-Boot-Starter依赖将会提供如下： 自动检测现有的DataSource 将创建并注册SqlSessionFactory的实例，该实例使用SqlSessionFactoryBean将该DataSource作为输入进行传递 将创建并注册从SqlSessionFactory中获取的SqlSessionTemplate的实例。 自动扫描您的mappers，将它们链接到SqlSessionTemplate并将其注册到Spring上下文，以便将它们注入到您的bean中。 就是说，使用了该Starter之后，只需要定义一个DataSource即可（application.properties中可配置），它会自动创建使用该DataSource的SqlSessionFactoryBean以及SqlSessionTemplate。会自动扫描你的Mappers，连接到SqlSessionTemplate，并注册到Spring上下文中。 数据源配置在src/main/resources/application.properties中配置数据源信息：1234spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = rootspring.datasource.driver-class-name = com.mysql.jdbc.Driver 自定义数据源Spring Boot默认使用tomcat-jdbc数据源，如果你想使用其他的数据源，比如这里使用了阿里巴巴的数据池管理,除了在application.properties配置数据源之外，你应该额外添加以下依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt;&lt;/dependency&gt; 修改Application.java：1234567891011121314151617181920212223242526@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Autowired private Environment env; //destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty("spring.datasource.url")); dataSource.setUsername(env.getProperty("spring.datasource.username"));//用户名 dataSource.setPassword(env.getProperty("spring.datasource.password"));//密码 dataSource.setDriverClassName(env.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2);//初始化时建立物理连接的个数 dataSource.setMaxActive(20);//最大连接池数量 dataSource.setMinIdle(0);//最小连接池数量 dataSource.setMaxWait(60000);//获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery("SELECT 1");//用来检测连接是否有效的sql dataSource.setTestOnBorrow(false);//申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true);//建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false);//是否缓存preparedStatement，也就是PSCache return dataSource; &#125;&#125; Spring Boot会智能地选择我们自己配置的这个DataSource实例。 注解方式跟XML配置方式共同的模块编码不管是注解方式还是XML配置的方式，以下代码模块都是一样的：pojo类：1234567public class LearnResouce &#123; private Long id; private String author; private String title; private String url; // SET和GET方法&#125; Controller:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.dudu.controller;import com.alibaba.fastjson.JSONObject;import com.dudu.domain.LearnResouce;import com.dudu.service.LearnService;import com.dudu.tools.ServletUtil;import com.dudu.tools.StringUtil;import com.github.pagehelper.PageInfo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** 教程页面 * Created by tengj on 2017/3/13. */@Controller@RequestMapping("/learn")public class LearnController &#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn()&#123; return "learn-resource"; &#125; @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST,produces="application/json;charset=UTF-8") @ResponseBody public void queryLearnList(HttpServletRequest request ,HttpServletResponse response)&#123; String page = request.getParameter("page"); // 取得当前页数,注意这是jqgrid自身的参数 String rows = request.getParameter("rows"); // 取得每页显示行数，,注意这是jqgrid自身的参数 String author = request.getParameter("author"); String title = request.getParameter("title"); Map&lt;String,Object&gt; params = new HashMap&lt;String,Object&gt;(); params.put("page", page); params.put("rows", rows); params.put("author", author); params.put("title", title); List&lt;LearnResouce&gt; learnList=learnService.queryLearnResouceList(params); PageInfo&lt;LearnResouce&gt; pageInfo =new PageInfo&lt;LearnResouce&gt;(learnList); JSONObject jo=new JSONObject(); jo.put("rows", learnList); jo.put("total", pageInfo.getPages());//总页数 jo.put("records",pageInfo.getTotal());//查询出的总记录数 ServletUtil.createSuccessResponse(200, jo, response); &#125; /** * 新添教程 * @param request * @param response */ @RequestMapping(value = "/add",method = RequestMethod.POST) public void addLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; LearnResouce learnResouce = new LearnResouce(); learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.add(learnResouce); if(index&gt;0)&#123; result.put("message","教程信息添加成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息添加失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 修改教程 * @param request * @param response */ @RequestMapping(value = "/update",method = RequestMethod.POST) public void updateLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String id = request.getParameter("id"); LearnResouce learnResouce=learnService.queryLearnResouceById(Long.valueOf(id)); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.update(learnResouce); System.out.println("修改结果="+index); if(index&gt;0)&#123; result.put("message","教程信息修改成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息修改失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 删除教程 * @param request * @param response */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public void deleteUser(HttpServletRequest request ,HttpServletResponse response)&#123; String ids = request.getParameter("ids"); System.out.println("ids==="+ids); JSONObject result = new JSONObject(); //删除操作 int index = learnService.deleteByIds(ids.split(",")); if(index&gt;0)&#123; result.put("message","教程信息删除成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息删除失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125;&#125; Service:12345678package com.dudu.service;public interface LearnService &#123; int add(LearnResouce learnResouce); int update(LearnResouce learnResouce); int deleteByIds(String[] ids); LearnResouce queryLearnResouceById(Long learnResouce); List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params);&#125; 实现类：123456789101112131415161718192021222324252627282930313233343536 package com.dudu.service.impl;/** * Created by tengj on 2017/4/7. */ @Service public class LearnServiceImpl implements LearnService &#123; @Autowired LearnMapper learnMapper; @Override public int add(LearnResouce learnResouce) &#123; return this.learnMapper.add(learnResouce); &#125; @Override public int update(LearnResouce learnResouce) &#123; return this.learnMapper.update(learnResouce); &#125; @Override public int deleteByIds(String[] ids) &#123; return this.learnMapper.deleteByIds(ids); &#125; @Override public LearnResouce queryLearnResouceById(Long id) &#123; return this.learnMapper.queryLearnResouceById(id); &#125; @Override public List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; PageHelper.startPage(Integer.parseInt(params.get("page").toString()), Integer.parseInt(params.get("rows").toString())); return this.learnMapper.queryLearnResouceList(params); &#125; &#125; Mybatis集成方案一：注解方式Mybatis注解的方式简单，只要定义一个dao接口，然后sql语句通过注解写在接口方法上。最后给这个接口添加@Mapper注解或者在启动类上添加@MapperScan(“com.dudu.dao”)注解都行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.dudu.dao;import com.dudu.domain.LearnResouce;import com.dudu.tools.StringUtil;import org.apache.ibatis.annotations.*;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/22. * Component注解不添加也没事，只是不加service那边引入LearnMapper会有错误提示，但不影响 */@Component@Mapperpublic interface LearnMapper &#123; @Insert("insert into learn_resource(author, title,url) values(#&#123;author&#125;,#&#123;title&#125;,#&#123;url&#125;)") int add(LearnResouce learnResouce); @Update("update learn_resource set author=#&#123;author&#125;,title=#&#123;title&#125;,url=#&#123;url&#125; where id = #&#123;id&#125;") int update(LearnResouce learnResouce); @DeleteProvider(type = LearnSqlBuilder.class, method = "deleteByids") int deleteByIds(@Param("ids") String[] ids); @Select("select * from learn_resource where id = #&#123;id&#125;") @Results(id = "learnMap", value = &#123; @Result(column = "id", property = "id", javaType = Long.class), @Result(property = "author", column = "author", javaType = String.class), @Result(property = "title", column = "title", javaType = String.class) &#125;) LearnResouce queryLearnResouceById(@Param("id") Long id); @SelectProvider(type = LearnSqlBuilder.class, method = "queryLearnResouceByParams") List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params); class LearnSqlBuilder &#123; public String queryLearnResouceByParams(final Map&lt;String, Object&gt; params) &#123; StringBuffer sql =new StringBuffer(); sql.append("select * from learn_resource where 1=1"); if(!StringUtil.isNull((String)params.get("author")))&#123; sql.append(" and author like '%").append((String)params.get("author")).append("%'"); &#125; if(!StringUtil.isNull((String)params.get("title")))&#123; sql.append(" and title like '%").append((String)params.get("title")).append("%'"); &#125; System.out.println("查询sql=="+sql.toString()); return sql.toString(); &#125; //删除的方法 public String deleteByids(@Param("ids") final String[] ids)&#123; StringBuffer sql =new StringBuffer(); sql.append("DELETE FROM learn_resource WHERE id in("); for (int i=0;i&lt;ids.length;i++)&#123; if(i==ids.length-1)&#123; sql.append(ids[i]); &#125;else&#123; sql.append(ids[i]).append(","); &#125; &#125; sql.append(")"); return sql.toString(); &#125; &#125;&#125; 需要注意的是，简单的语句只需要使用@Insert、@Update、@Delete、@Select这4个注解即可，但是有些复杂点需要动态SQL语句，就比如上面方法中根据查询条件是否有值来动态添加sql的，就需要使用@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider等注解。 这些可选的 SQL 注解允许你指定一个类名和一个方法在执行时来返回运行 允许创建动态 的 SQL。 基于执行的映射语句, MyBatis 会实例化这个类,然后执行由 provider 指定的方法. 该方法可以有选择地接受参数对象.(In MyBatis 3.4 or later, it’s allow multiple parameters) 属性: type,method。type 属性是类。method 属性是方法名。 注意: 这节之后是对 类的 讨论,它可以帮助你以干净,容于阅读 的方式来构建动态 SQL。 方案二：XML配置方式xml配置方式保持映射文件的老传统，优化主要体现在不需要实现dao的是实现层，系统会自动根据方法名在映射文件中找对应的sql，具体操作如下： 编写Dao层的代码新建LearnMapper接口，无需具体实现类。123456789package com.dudu.dao;@Mapperpublic interface LearnMapper &#123; int add(LearnResouce learnResouce); int update(LearnResouce learnResouce); int deleteByIds(String[] ids); LearnResouce queryLearnResouceById(Long id); public List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String, Object&gt; params);&#125; 修改application.properties 配置文件：1234#指定bean所在包mybatis.type-aliases-package=com.dudu.domain#指定映射文件mybatis.mapperLocations=classpath:mapper/*.xml 添加LearnMapper的映射文件: 在src/main/resources目录下新建一个mapper目录，在mapper目录下新建LearnMapper.xml文件。 通过mapper标签中的namespace属性指定对应的dao映射，这里指向LearnMapper。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dudu.dao.LearnMapper"&gt; &lt;resultMap id="baseResultMap" type="com.dudu.domain.LearnResouce"&gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="author" property="author" jdbcType="VARCHAR"/&gt; &lt;result column="title" property="title" jdbcType="VARCHAR"/&gt; &lt;result column="url" property="url" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; &lt;sql id="baseColumnList" &gt; id, author, title,url &lt;/sql&gt; &lt;select id="queryLearnResouceList" resultMap="baseResultMap" parameterType="java.util.HashMap"&gt; select &lt;include refid="baseColumnList" /&gt; from learn_resource &lt;where&gt; 1 = 1 &lt;if test="author!= null and author !=''"&gt; AND author like CONCAT(CONCAT('%',#&#123;author,jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;if test="title != null and title !=''"&gt; AND title like CONCAT(CONCAT('%',#&#123;title,jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="queryLearnResouceById" resultMap="baseResultMap" parameterType="java.lang.Long"&gt; SELECT &lt;include refid="baseColumnList" /&gt; FROM learn_resource WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="add" parameterType="com.dudu.domain.LearnResouce" &gt; INSERT INTO learn_resource (author, title,url) VALUES (#&#123;author&#125;, #&#123;title&#125;, #&#123;url&#125;) &lt;/insert&gt; &lt;update id="update" parameterType="com.dudu.domain.LearnResouce" &gt; UPDATE learn_resource SET author = #&#123;author&#125;,title = #&#123;title&#125;,url = #&#123;url&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteByIds" parameterType="java.lang.String" &gt; DELETE FROM learn_resource WHERE id in &lt;foreach item="idItem" collection="array" open="(" separator="," close=")"&gt; #&#123;idItem&#125; &lt;/foreach&gt; &lt;/delete&gt;&lt;/mapper&gt; 分页插件上面我有使用到物理分页插件pagehelper，用法还算简单，pom.xml中添加依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 然后你只需在查询list之前使用PageHelper.startPage(int pageNum, int pageSize)方法即可。pageNum是第几页，pageSize是每页多少条：12345@Overridepublic List&lt;LearnResouce&gt; queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; PageHelper.startPage(Integer.parseInt(params.get(&quot;page&quot;).toString()), Integer.parseInt(params.get(&quot;rows&quot;).toString())); return this.learnMapper.queryLearnResouceList(params);&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：默认日志logback配置解析]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97logback%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.log.git Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。 默认日志LogbackSLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。 Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。 日志输出内容元素具体如下： 时间日期：精确到毫秒 日志级别：ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符：— 标识实际日志的开始 线程名：方括号括起来（可能会截断控制台输出） Logger名：通常使用源代码的类名 日志内容 添加日志依赖假如maven依赖中添加了spring-boot-starter-logging：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。 但是呢，实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。Thymeleaf依赖包含了spring-boot-starter，所以理论上，如果选择引入Thymeleaf，就不需要引入spring-boot-starter-logging：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 默认配置属性支持Spring Boot为我们提供了很多默认的日志配置，所以，只要将spring-boot-starter-logging作为依赖加入到当前应用的classpath，则“开箱即用”。下面介绍几种在application.properties就可以配置的日志相关属性。 控制台输出日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可： 在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug 在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。 文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log 注：二者不能同时使用，如若同时使用，则只有logging.file生效 默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO。 级别控制所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中）格式为：’logging.level.* = LEVEL’ logging.level：日志级别控制前缀，*为包名或Logger名 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF举例： logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出 logging.level.root=WARN：root日志以WARN级别输出 自定义日志配置由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。 根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载： Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml Log4j2：log4j2-spring.xml, log4j2.xml JDK (Java Util Logging)：logging.properties Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。 上面是默认的命名规则，并且放在src/main/resources下面即可。 如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：1logging.config=classpath:logging-config.xml 虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日志配置，这个功能会很有用。 下面是一个普通的logback-spring.xml例子： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="E:\\test\\logback.log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.dudu.controller"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.dudu.controller.LearnController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 参考：http://tengj.top/2017/04/05/springboot7/]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：静态资源和拦截器处理]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/jdbcTemplete.dudu.static.git 前面章节我们也有简单介绍过SpringBoot中对静态资源的默认支持，今天详细的来介绍下默认的支持，以及自定义扩展如何实现。 默认资源映射Spring Boot 默认为我们提供了静态资源处理，使用 WebMvcAutoConfiguration 中的配置各种属性。建议大家使用Spring Boot的默认配置方式，提供的静态资源映射如下: classpath:/META-INF/resources classpath:/resources classpath:/static classpath:/public 上面这几个都是静态资源的映射路径，优先级顺序为：META-INF/resources &gt; resources &gt; static &gt; public。 可以自己在上面4个路径下都放一张同名的图片，访问一下即可验证。还有，你可以随机在上面一个路径下面放上index.html，当我们访问应用根目录http://lcoalhost:8080 时，会直接映射到index.html页面。 对应的配置文件配置如下：1234# 默认值为 /**spring.mvc.static-path-pattern=# 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开 可以通过修改spring.mvc.static-path-pattern来修改默认的映射，例如我改成/dudu/**,那运行的时候访问http://lcoalhost:8080/dudu/index.html 才对应到index.html页面。 接管Spring Boot的Web配置如果Spring Boot提供的Sping MVC不符合要求，则可以通过一个配置类（注解有@Configuration的类）加上@EnableWebMvc注解来实现完全自己控制的MVC配置。 当然，通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter,无需使用@EnableWebMvc注解。 这里我们提到这个WebMvcConfigurerAdapter这个类，重写这个类中的方法可以让我们增加额外的配置，这里我们就介绍几个常用的。 自定义资源映射addResourceHandlers比如，我们想自定义静态资源映射目录的话，只需重写addResourceHandlers方法即可。123456789101112@Configurationpublic class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter &#123; /** * 配置静态访问资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/my/**").addResourceLocations("classpath:/my/"); super.addResourceHandlers(registry); &#125;&#125; 通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。我们访问自定义my文件夹中的elephant.jpg 图片的地址为：http://localhost:8080/my/elephant.jpg 如果你想指定外部的目录也很简单，直接addResourceLocations指定即可，代码如下：12345@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/my/**").addResourceLocations("file:E:/my/"); super.addResourceHandlers(registry);&#125; addResourceLocations指的是文件放置的目录，addResoureHandler指的是对外暴露的访问路径。 页面跳转addViewControllers以前写SpringMVC的时候，如果需要访问一个页面，必须要写Controller类，然后再写一个方法跳转到页面，感觉好麻烦，其实重写WebMvcConfigurerAdapter中的addViewControllers方法即可达到效果了：12345678910/** * 以前要访问一个页面需要先创建个Controller控制类，再写方法跳转到页面 * 在这里配置后就不需要那么麻烦了，直接访问http://localhost:8080/toLogin就跳转到login.htm页面了 * @param registry */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/toLogin").setViewName("login"); super.addViewControllers(registry); &#125; 值的指出的是，在这里重写addViewControllers方法，并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这也就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是我们推荐添加自己的MVC配置的方式。 拦截器addInterceptors拦截器在我们项目中经常使用的，这里就来介绍下最简单的判断是否登录的使用。要实现拦截器功能需要完成以下2个步骤： 创建我们自己的拦截器类并实现 HandlerInterceptor 接口 其实重写WebMvcConfigurerAdapter中的addInterceptors方法把自定义的拦截器类添加进来即可首先，自定义拦截器代码：1234567891011121314151617181920212223package com.dudu.interceptor;public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; boolean flag =true; User user=(User)request.getSession().getAttribute("user"); if(null==user)&#123; response.sendRedirect("toLogin"); flag = false; &#125;else&#123; flag = true; &#125; return flag; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 这里我们简单实现了根据session中是否有User对象来判断是否登录，为空就跳转到登录页，不为空就通过。 接着，重写WebMvcConfigurerAdapter中的addInterceptors方法如下：1234567891011/*** 拦截器* @param registry*/@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").excludePathPatterns("/toLogin","/login"); super.addInterceptors(registry);&#125; addPathPatterns(“/**”)对所有请求都拦截，但是排除了/toLogin和/login请求的拦截。 页面登录关键代码12345678910111213141516171819//简单登录操作$("#doLogin").click(function (e) &#123; $.ajax(&#123; type : "POST", url : "/login", data : &#123; "userName" : $("#userName").val(), "password" : $("#password").val() &#125;, dataType : "json", success : function(data) &#123; if (data.result == "1") &#123; window.location.href ="/learn"; &#125; else &#123; alert("账号密码不能为空！"); &#125; &#125; &#125;);&#125;); controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.dudu.controller;import com.dudu.domain.LearnResouce;import com.dudu.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.List;/** * Created by tengj on 2017/3/13. */@Controllerpublic class LearnController &#123; @RequestMapping(value = "/login",method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; login(HttpServletRequest request, HttpServletResponse response)&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); String userName=request.getParameter("userName"); String password=request.getParameter("password"); if(!userName.equals("") &amp;&amp; password!="")&#123; User user =new User(userName,password); request.getSession().setAttribute("user",user); map.put("result","1"); &#125;else&#123; map.put("result","0"); &#125; return map; &#125; @RequestMapping("/learn") public ModelAndView index()&#123; List&lt;LearnResouce&gt; learnList =new ArrayList&lt;LearnResouce&gt;(); LearnResouce bean =new LearnResouce("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResouce("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResouce("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResouce("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResouce("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResouce("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResouce("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResouce("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResouce("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResouce("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView("/template"); modelAndView.addObject("learnList", learnList); return modelAndView; &#125;&#125; 这样访问的时候，如果未登录就会跳转到login.html页面，而访问http://localhost:8080/toLogin 和http://localhost:8080/login 不会被拦截。 更多配置可以查看WebMvcConfigurerAdapter的类的API。因其是WebMvcConfigurer接口的实现，所以WebMvcConfigurer的API方法也可以用来配置MVC。 但是只是实现这个接口的话，要实现所有的方法，比较麻烦。 所以还是推荐使用继承WebMvcConfigurerAdapter类来处理。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：spring task定时任务]]></title>
    <url>%2F2018%2F11%2F30%2Fspringboot%EF%BC%9Aspring-task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.springtask.git 创建一个项目，在DemoApplication上加上注解@EnableScheduling：123456789101112131415161718package com.example.demo;import com.example.demo.task.Task;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class DemoApplication &#123; @Autowired private Task task; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 在demo包里创建Task.java：12345678910111213141516171819202122package com.example.demo.task;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class Task &#123; private int count=0; @Scheduled(cron="*/6 * * * * ?") private void process()&#123; System.out.println("[" + Thread.currentThread().getName() + "]" + "this is scheduler task runing "+(count++)); &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125;&#125; 使用@Scheduled注解，就会定时执行。 log日志：12345678910111213141516171819202122[scheduling-1]this is scheduler task runing 0[scheduling-1]this is scheduler task runing 1[scheduling-1]this is scheduler task runing 2[scheduling-1]this is scheduler task runing 3[scheduling-1]this is scheduler task runing 4[scheduling-1]this is scheduler task runing 5[scheduling-1]this is scheduler task runing 6[scheduling-1]this is scheduler task runing 7[scheduling-1]this is scheduler task runing 8[scheduling-1]this is scheduler task runing 9[scheduling-1]this is scheduler task runing 10[scheduling-1]this is scheduler task runing 11[scheduling-1]this is scheduler task runing 12[scheduling-1]this is scheduler task runing 13[scheduling-1]this is scheduler task runing 14[scheduling-1]this is scheduler task runing 15[scheduling-1]this is scheduler task runing 16[scheduling-1]this is scheduler task runing 17[scheduling-1]this is scheduler task runing 18[scheduling-1]this is scheduler task runing 19[scheduling-1]this is scheduler task runing 20[scheduling-1]this is scheduler task runing 21 不需要加入其它配置文件和注解。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring task定时任务（一）]]></title>
    <url>%2F2018%2F11%2F30%2Fspring-task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/spring.springtask.git SprngTask没有专门的包，其核心类位于spring-context包中。所以引入spring的核心包此功能即可使用。 在实际的项目中，我们经常将job作为action层，在job中注入service去操作底层的dao，或者定时的向其他系统拉取数据,再或者向其他系统推送数据。 xml配置文件applicationContext.xml： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd"&gt; &lt;context:component-scan base-package="org.task.app"/&gt; &lt;!-- 定时器开关--&gt; &lt;task:annotation-driven /&gt;&lt;/beans&gt; SpringTimer.java1234567891011121314151617package org.task.app;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;/** * @author 34924 */@Componentpublic class SpringTimer &#123; @Scheduled(cron="0/5 * * * * ? ") //每5秒执行一次 public void myTest()&#123; System.out.println("进入测试 " + new Date()); &#125;&#125; 测试类TaskTest.java：1234567891011121314151617181920212223242526package org.task.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.task.app.SpringTimer;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = "classpath:applicationContext.xml")public class TaskTest &#123; @Autowired SpringTimer springTimerTest; @Test public void springTask() &#123; try&#123; Thread.sleep(1000000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; log:123456进入测试 Fri Nov 30 21:39:20 CST 2018进入测试 Fri Nov 30 21:39:25 CST 2018进入测试 Fri Nov 30 21:39:30 CST 2018进入测试 Fri Nov 30 21:39:35 CST 2018进入测试 Fri Nov 30 21:39:40 CST 2018进入测试 Fri Nov 30 21:39:45 CST 2018]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium一些记录]]></title>
    <url>%2F2018%2F11%2F29%2Fselenium%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95-1%2F</url>
    <content type="text"><![CDATA[selenium中文文档：https://selenium-python-zh.readthedocs.io/en/latest/index.html 使用selenium，安装好对应版本的chromedriver和chrome，然后将driver放入项目，用 driver = webdriver.Chrome()启动。 selenium刷新：123driver.refresh()# 或调用jsdriver.execute_script("location.reload()") 请求头配置参考：https://blog.csdn.net/u013440574/article/details/81911954 仅添加普通请求头：123456opt = webdriver.ChromeOptions() opt.set_headless() opt.add_argument( 'user-agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400') driver = webdriver.Chrome(options=opt) 这里使用opt作为chromedriver的参数，添加user-agent信息，然后调用webdriver.Chrome，并传入opt。 注：这里使用的是无窗口界面的chrome selenium爬虫，所以可以设置，如果使用有界面的，则不必设置，因为带界面必定带请求头和各种信息。 Selenium不再推荐使用PhantomJS，会报如下警告 UserWarning: Selenium support for PhantomJS has been deprecated, please use headless versions of Chrome or Firefox instead warnings.warn(‘Selenium support for PhantomJS has been deprecated, please use headless ‘ 于是从PhantomJS转移到Chrome，使用headless versions of Chrome时，首先要安装Chrome，然后下载chromedriver，再把chromedriver的地址配置到系统环境变量path中，方便调用。如果不把chromedriver的地址配置到系统环境变量的话，也可以在使用时指定chromedriver的地址。 注意Chrome和chromedriver有版本对应的要求，系统中安装了某一版本的chrome要使用对应版本的chromedriver，其实下载最新版本的Chrome和chromedriver就行了，一般都是对应的。 Chrome下载地址：https://chrome.en.softonic.com/ chromedriver下载地址：http://npm.taobao.org/mirrors/chromedriver/ 报错：[0917/002914.533:ERROR:gpu_process_transport_factory.cc(1007)] Lost UI shared context. 原因是在windows系统中Chrome无头模式下，其中的SwiftShader软件会触发断言失败，但实际上不影响程序执行，可以忽略该错误。 可以设置chromedriver的日志级别，只有大于设置级别的日志还会输出，该配置参数为：log-level：123456opt.add_argument('log-level=3')# INFO = 0, # WARNING = 1, # LOG_ERROR = 2, # LOG_FATAL = 3# default is 0]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用JdbcTemplate（二）]]></title>
    <url>%2F2018%2F11%2F29%2Fspringboot%E4%BD%BF%E7%94%A8JdbcTemplate%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考博客 http://tengj.top/2017/04/13/springboot8/ 项目地址：https://github.com/snjl/springboot.jdbcTemplete.git 添加依赖123456789在pom.xml里添加spring-boot-starter-jdbc依赖跟mysql依赖：&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 数据源配置在src/main/resources/application.properties中配置数据源信息：1234spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = rootspring.datasource.driver-class-name = com.mysql.jdbc.Driver 自定义数据源添加mysql依赖（spring-boot-starter-jdbc 默认使用tomcat-jdbc数据源，如果要使用其他数据源，需要添加额外的依赖，这里使用了阿里巴巴的数据池管理）：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt;&lt;/dependency&gt; 修改Application.java：12345678910111213141516171819202122232425262728293031323334353637383940package com.dudu;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.core.env.Environment;import javax.sql.DataSource;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Autowired private Environment env; //destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty("spring.datasource.url")); dataSource.setUsername(env.getProperty("spring.datasource.username"));//用户名 dataSource.setPassword(env.getProperty("spring.datasource.password"));//密码 dataSource.setDriverClassName(env.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2);//初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 dataSource.setMaxActive(20);//最大连接池数量 dataSource.setMinIdle(0);//最小连接池数量 dataSource.setMaxWait(60000);//获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 dataSource.setValidationQuery("SELECT 1");//用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 dataSource.setTestOnBorrow(false);//申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 dataSource.setTestWhileIdle(true);//建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 dataSource.setPoolPreparedStatements(false);//是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 return dataSource; &#125;&#125; Spring Boot会智能地选择我们自己配置的这个DataSource实例。 脚本初始化12345678910111213141516171819202122232425CREATE DATABASE /*!32312 IF NOT EXISTS*/`spring` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `spring`;DROP TABLE IF EXISTS `learn_resource`;CREATE TABLE `learn_resource` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID', `author` varchar(20) DEFAULT NULL COMMENT '作者', `title` varchar(100) DEFAULT NULL COMMENT '描述', `url` varchar(100) DEFAULT NULL COMMENT '地址链接', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1029 DEFAULT CHARSET=utf8;insert into `learn_resource`(`id`,`author`,`title`,`url`) values (999,'官方SpriongBoot例子','官方SpriongBoot例子','https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1000,'龙果学院','Spring Boot 教程系列学习','http://www.roncoo.com/article/detail/124661');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1001,'嘟嘟MD独立博客','Spring Boot干货系列','http://tengj.top/');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1002,'后端编程嘟','Spring Boot视频教程','http://www.toutiao.com/m1559096720023553/');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1003,'程序猿DD','Spring Boot系列','http://www.roncoo.com/article/detail/125488');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1004,'纯洁的微笑','Sping Boot系列文章','http://www.ityouknow.com/spring-boot');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1005,'CSDN——小当博客专栏','Sping Boot学习','http://blog.csdn.net/column/details/spring-boot.html');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1006,'梁桂钊的博客','Spring Boot 揭秘与实战','http://blog.csdn.net/column/details/spring-boot.html');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1007,'林祥纤博客系列','从零开始学Spring Boot','http://412887952-qq-com.iteye.com/category/356333');insert into `learn_resource`(`id`,`author`,`title`,`url`) values (1028,'杜琪','关于Spring Boot的博客集合','http://www.jianshu.com/p/7e2e5e7b32ab'); 使用JdbcTemplateSpring的JdbcTemplate是自动配置的，可以直接使用@Autowired来注入到自己的bean中来使用。这里做了一套增伤改查。pojo类：1234567public class LearnResouce &#123; private Long id; private String author; private String title; private String url; // SET和GET方法&#125; dao层的接口实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.dudu.dao.impl;import com.dudu.dao.LearnDao;import com.dudu.domain.LearnResouce;import com.dudu.tools.Page;import com.dudu.tools.StringUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/8. */@Repositorypublic class LearnDaoImpl implements LearnDao&#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(LearnResouce learnResouce) &#123; return jdbcTemplate.update("insert into learn_resource(author, title,url) values(?, ?, ?)",learnResouce.getAuthor(),learnResouce.getTitle(),learnResouce.getUrl()); &#125; @Override public int update(LearnResouce learnResouce) &#123; return jdbcTemplate.update("update learn_resource set author=?,title=?,url=? where id = ?",new Object[]&#123;learnResouce.getAuthor(),learnResouce.getTitle(),learnResouce.getUrl(),learnResouce.getId()&#125;); &#125; @Override public int deleteByIds(String ids)&#123; return jdbcTemplate.update("delete from learn_resource where id in("+ids+")"); &#125; @Override public LearnResouce queryLearnResouceById(Long id) &#123; List&lt;LearnResouce&gt; list = jdbcTemplate.query("select * from learn_resource where id = ?", new Object[]&#123;id&#125;, new BeanPropertyRowMapper(LearnResouce.class)); if(null != list &amp;&amp; list.size()&gt;0)&#123; LearnResouce learnResouce = list.get(0); return learnResouce; &#125;else&#123; return null; &#125; &#125; @Override public Page queryLearnResouceList(Map&lt;String,Object&gt; params) &#123; StringBuffer sql =new StringBuffer(); sql.append("select * from learn_resource where 1=1"); if(!StringUtil.isNull((String)params.get("author")))&#123; sql.append(" and author like '%").append((String)params.get("author")).append("%'"); &#125; if(!StringUtil.isNull((String)params.get("title")))&#123; sql.append(" and title like '%").append((String)params.get("title")).append("%'"); &#125; Page page = new Page(sql.toString(), Integer.parseInt(params.get("page").toString()), Integer.parseInt(params.get("rows").toString()), jdbcTemplate); return page; &#125;&#125; 其中值得注意的几个点： jdbcTemplete直接使用@Autowired注解注入的； deleteByIds这个方法是传入的数据是形如”(1,2,3,5)”这样的数据，是在controller里或者前端组装好的； queryLearnResouceList这个方法返回的是一个Page对象,它需要的参数里有一个page，指的是当前页码，下面是Page.java的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.dudu.tools;import org.springframework.jdbc.core.JdbcTemplate;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/4/11. */public class Page &#123; //一页显示的记录数 private int numPerPage; //记录总数 private int totalRows; //总页数 private int totalPages; //当前页码 private int currentPage; //起始行数 private int startIndex; //结束行数 private int lastIndex; //结果集存放List private List&lt;Map&lt;String, Object&gt;&gt; resultList; /**分页构造函数 * @param sql 包含筛选条件的sql，但不包含分页相关约束，如mysql的limit * @param currentPage 当前页 * @param numPerPage 每页记录数 * @param jdbcTemplate jdbcTemplate实例 */ public Page(String sql,int currentPage,int numPerPage,JdbcTemplate jdbcTemplate)&#123; if(jdbcTemplate == null)&#123; throw new IllegalArgumentException("Page.jdbcTemplate is null"); &#125;else if(sql == null || sql.equals(""))&#123; throw new IllegalArgumentException("Page.sql is empty"); &#125; //设置每页显示记录数 setNumPerPage(numPerPage); //设置要显示的页数 setCurrentPage(currentPage); //计算总记录数 StringBuffer totalSQL = new StringBuffer(" SELECT count(*) FROM ( "); totalSQL.append(sql); totalSQL.append(" ) totalTable "); //总记录数 setTotalRows(jdbcTemplate.queryForObject(totalSQL.toString(),Integer.class)); //计算总页数 setTotalPages(); //计算起始行数 setStartIndex(); //计算结束行数 setLastIndex(); System.out.println("lastIndex="+lastIndex); //使用mysql时直接使用limits StringBuffer paginationSQL = new StringBuffer(); paginationSQL.append(sql); paginationSQL.append(" limit " + startIndex + "," + lastIndex); //装入结果集 setResultList(jdbcTemplate.queryForList(paginationSQL.toString())); &#125; //计算总页数 public void setTotalPages() &#123; if(totalRows % numPerPage == 0)&#123; this.totalPages = totalRows / numPerPage; &#125;else&#123; this.totalPages = (totalRows / numPerPage) + 1; &#125; &#125; //计算结束时候的索引 public void setLastIndex() &#123; System.out.println("totalRows="+totalRows);/////////// System.out.println("numPerPage="+numPerPage);/////////// if( totalRows &lt; numPerPage)&#123; this.lastIndex = totalRows; &#125;else if((totalRows % numPerPage == 0) || (totalRows % numPerPage != 0 &amp;&amp; currentPage &lt; totalPages))&#123; this.lastIndex = currentPage * numPerPage; &#125;else if(totalRows % numPerPage != 0 &amp;&amp; currentPage == totalPages)&#123;//最后一页 this.lastIndex = totalRows ; &#125; &#125; Page的构造函数，将sql和其他条件拼接起来，从而得到每一页的信息。最后返回一个List&lt;Map&lt;String, Object&gt;&gt;对象和一些例如页码数、总数据条数等数据，作为一个Page数据。 Service层没有特点。 Controller层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package com.dudu.controller;import com.alibaba.fastjson.JSONObject;import com.dudu.domain.LearnResouce;import com.dudu.service.LearnService;import com.dudu.tools.Page;import com.dudu.tools.ServletUtil;import com.dudu.tools.StringUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by tengj on 2017/3/13. */@Controller@RequestMapping("/learn")public class LearnController &#123; @Autowired private LearnService learnService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("") public String learn()&#123; return "learn-resource"; &#125; @RequestMapping(value = "/queryLeanList",method = RequestMethod.POST,produces="application/json;charset=UTF-8") @ResponseBody public void queryLearnList(HttpServletRequest request ,HttpServletResponse response)&#123; String page = request.getParameter("page"); // 取得当前页数,注意这是jqgrid自身的参数 String rows = request.getParameter("rows"); // 取得每页显示行数，,注意这是jqgrid自身的参数 String author = request.getParameter("author"); String title = request.getParameter("title"); Map&lt;String,Object&gt; params = new HashMap&lt;String,Object&gt;(); params.put("page", page); params.put("rows", rows); params.put("author", author); params.put("title", title); Page pageObj =learnService.queryLearnResouceList(params); List&lt;Map&lt;String, Object&gt;&gt; learnList=pageObj.getResultList(); JSONObject jo=new JSONObject(); jo.put("rows", learnList); jo.put("total", pageObj.getTotalPages()); jo.put("records", pageObj.getTotalRows()); ServletUtil.createSuccessResponse(200, jo, response); &#125; /** * 新添教程 * @param request * @param response */ @RequestMapping(value = "/add",method = RequestMethod.POST) public void addLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; LearnResouce learnResouce = new LearnResouce(); learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.add(learnResouce); System.out.println("结果="+index); if(index&gt;0)&#123; result.put("message","教程信息添加成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息添加失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 修改教程 * @param request * @param response */ @RequestMapping(value = "/update",method = RequestMethod.POST) public void updateLearn(HttpServletRequest request , HttpServletResponse response)&#123; JSONObject result=new JSONObject(); String id = request.getParameter("id"); LearnResouce learnResouce=learnService.queryLearnResouceById(Long.valueOf(id)); String author = request.getParameter("author"); String title = request.getParameter("title"); String url = request.getParameter("url"); if(StringUtil.isNull(author))&#123; result.put("message","作者不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(title))&#123; result.put("message","教程名称不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; if(StringUtil.isNull(url))&#123; result.put("message","地址不能为空!"); result.put("flag",false); ServletUtil.createSuccessResponse(200, result, response); return; &#125; learnResouce.setAuthor(author); learnResouce.setTitle(title); learnResouce.setUrl(url); int index=learnService.update(learnResouce); System.out.println("修改结果="+index); if(index&gt;0)&#123; result.put("message","教程信息修改成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息修改失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125; /** * 删除教程 * @param request * @param response */ @RequestMapping(value="/delete",method = RequestMethod.POST) @ResponseBody public void deleteUser(HttpServletRequest request ,HttpServletResponse response)&#123; String ids = request.getParameter("ids"); System.out.println("ids==="+ids); JSONObject result = new JSONObject(); //删除操作 int index = learnService.deleteByIds(ids); if(index&gt;0)&#123; result.put("message","教程信息删除成功!"); result.put("flag",true); &#125;else&#123; result.put("message","教程信息删除失败!"); result.put("flag",false); &#125; ServletUtil.createSuccessResponse(200, result, response); &#125;&#125; 这里使用了ServletUtil，在此仅举出一例：1234567891011121314151617181920212223242526 public static String createSuccessResponse(Integer httpCode, Object result, SerializerFeature serializerFeature, SerializeFilter filter, HttpServletResponse response)&#123; PrintWriter printWriter = null; String jsonString = ""; try &#123; response.setCharacterEncoding(RESPONSE_CHARACTERENCODING); response.setContentType(RESPONSE_CONTENTTYPE); response.setStatus(httpCode); printWriter = response.getWriter(); if(null != result)&#123; if(null!=filter)&#123; jsonString = JSONObject.toJSONString(result,filter,serializerFeature); &#125;else&#123;// jsonString = JSONObject.toJSONString(result, serializerFeature); jsonString = JSONObject.toJSONStringWithDateFormat(result,"yyyy-MM-dd HH:ss:mm",serializerFeature); &#125; printWriter.write(jsonString); &#125; printWriter.flush(); &#125; catch (Exception e) &#123; log.error("createResponse failed", e); &#125; finally &#123; if(null!=printWriter)printWriter.close(); &#125; return jsonString; &#125; 页面展示]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mysql</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用thymeleaf开发web应用]]></title>
    <url>%2F2018%2F11%2F29%2Fspringboot%E4%BD%BF%E7%94%A8thymeleaf%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.thymeleaf_demo.git Spring Web MVCSpring Web MVC框架（通常简称为”Spring MVC”）是一个富”模型，视图，控制器”的web框架。 Spring MVC允许你创建特定的@Controller或@RestController beans来处理传入的HTTP请求。 示例：12345678910111213141516@RestController@RequestMapping(value="/users")public class MyRestController &#123; @RequestMapping(value="/&#123;user&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long user) &#123; // ... &#125; @RequestMapping(value="/&#123;user&#125;/customers", method=RequestMethod.GET) List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) &#123; // ... &#125; @RequestMapping(value="/&#123;user&#125;", method=RequestMethod.DELETE) public User deleteUser(@PathVariable Long user) &#123; // ... &#125;&#125; Spring MVC自动配置Spring Boot为Spring MVC提供适用于多数应用的自动配置功能。在Spring默认基础上，自动配置添加了以下特性： 引入ContentNegotiatingViewResolver和BeanNameViewResolver beans。 对静态资源的支持，包括对WebJars的支持。 自动注册Converter，GenericConverter，Formatter beans。 对HttpMessageConverters的支持。 自动注册MessageCodeResolver。 对静态index.html的支持。 对自定义Favicon的支持。 如果想全面控制Spring MVC，你可以添加自己的@Configuration，并使用@EnableWebMvc对其注解。如果想保留Spring Boot MVC的特性，并只是添加其他的MVC配置(拦截器，formatters，视图控制器等)，你可以添加自己的WebMvcConfigurerAdapter类型的@Bean（不使用@EnableWebMvc注解）. 静态文件默认情况下，Spring Boot从classpath下一个叫/static（/public，/resources或/META-INF/resources）的文件夹或从ServletContext根目录提供静态内容。这使用了Spring MVC的ResourceHttpRequestHandler，所以你可以通过添加自己的WebMvcConfigurerAdapter并覆写addResourceHandlers方法来改变这个行为（加载静态文件）。 在一个单独的web应用中，容器默认的servlet是开启的，如果Spring决定不处理某些请求，默认的servlet作为一个回退（降级）将从ServletContext根目录加载内容。大多数时候，这不会发生（除非你修改默认的MVC配置），因为Spring总能够通过DispatcherServlet处理请求。 此外，上述标准的静态资源位置有个例外情况是Webjars内容。任何在/webjars/**路径下的资源都将从jar文件中提供，只要它们以Webjars的格式打包。 注：如果你的应用将被打包成jar，那就不要使用src/main/webapp文件夹。尽管该文件夹是一个共同的标准，但它仅在打包成war的情况下起作用，并且如果产生一个jar，多数构建工具都会静悄悄的忽略它。 模版引擎Spring Boot支持多种模版引擎包括： FreeMarker Groovy Thymeleaf(官方推荐) Mustache JSP技术Spring Boot官方是不推荐的，原因有三： tomcat只支持war的打包方式，不支持可执行的jar。 Jetty 嵌套的容器不支持jsp Undertow 创建自定义error.jsp页面不会覆盖错误处理的默认视图，而应该使用自定义错误页面 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 Thymeleaf模版引擎Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。它的功能特性如下： Spring MVC中@Controller中的方法可以直接返回模板名称，接下来Thymeleaf模板引擎会自动进行渲染 模板中的表达式支持Spring表达式语言（Spring EL) 表单支持，并兼容Spring MVC的数据绑定与验证机制 国际化支持 Spring官方也推荐使用Thymeleaf,所以本篇代码整合就使用Thymeleaf来整合。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; domain类1234567891011121314151617@Componentpublic class LearnResource &#123; private String author; private String title; private String url; public LearnResource() &#123; &#125; public LearnResource(String author, String title, String url) &#123; this.author = author; this.title = title; this.url = url; &#125; ...&#125; controller两种写法均可：123456789101112131415161718192021222324252627282930@Controller@RequestMapping("/learn")public class LearnResourceController &#123; @RequestMapping("/") public ModelAndView index()&#123; List&lt;LearnResource&gt; learnList =new ArrayList&lt;LearnResource&gt;(); LearnResource bean =new LearnResource("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResource("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResource("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResource("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResource("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResource("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView("/learning"); modelAndView.addObject("learnList", learnList); return modelAndView; &#125; 1234567891011121314151617181920212223242526@RequestMapping("/learning") public String index(ModelMap map)&#123; List&lt;LearnResource&gt; learnList =new ArrayList&lt;LearnResource&gt;(); LearnResource bean =new LearnResource("官方参考文档","Spring Boot Reference Guide","http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/#getting-started-first-application"); learnList.add(bean); bean =new LearnResource("官方SpriongBoot例子","官方SpriongBoot例子","https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples"); learnList.add(bean); bean =new LearnResource("龙国学院","Spring Boot 教程系列学习","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("嘟嘟MD独立博客","Spring Boot干货系列 ","http://tengj.top/"); learnList.add(bean); bean =new LearnResource("后端编程嘟","Spring Boot教程和视频 ","http://www.toutiao.com/m1559096720023553/"); learnList.add(bean); bean =new LearnResource("程序猿DD","Spring Boot系列","http://www.roncoo.com/article/detail/125488"); learnList.add(bean); bean =new LearnResource("纯洁的微笑","Sping Boot系列文章","http://www.ityouknow.com/spring-boot"); learnList.add(bean); bean =new LearnResource("CSDN——小当博客专栏","Sping Boot学习","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("梁桂钊的博客","Spring Boot 揭秘与实战","http://blog.csdn.net/column/details/spring-boot.html"); learnList.add(bean); bean =new LearnResource("林祥纤博客系列","从零开始学Spring Boot ","http://412887952-qq-com.iteye.com/category/356333"); learnList.add(bean); map.addAttribute("learnList", learnList); return "learning"; &#125; 一个访问链接是localhost:8080/learn/(带斜杆)，另一个是http://localhost:8080/learn/learning，但是对应的模版文件均是learning.html。 html编写引入依赖后就在默认的模板路径src/main/resources/templates下编写模板文件即可完成。这里我们新建一个index.html:1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;learn Resources&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center;margin:0 auto;width: 1000px; "&gt; &lt;h1&gt;springboot学习&lt;/h1&gt; &lt;table width="100%" border="1" cellspacing="1" cellpadding="0"&gt; &lt;tr&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;教程名称&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;!--/*@thymesVar id="learnList" type=""*/--&gt; &lt;tr th:each="learn : $&#123;learnList&#125;"&gt; &lt;td th:text="$&#123;learn.author&#125;"&gt;嘟嘟MD&lt;/td&gt; &lt;td th:text="$&#123;learn.title&#125;"&gt;SPringBoot干货系列&lt;/td&gt; &lt;td&gt;&lt;a th:href="$&#123;learn.url&#125;" target="_blank"&gt;点我&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：通过xmlns:th=”http://www.thymeleaf.org“ 命令空间，将静态页面转换为动态的视图，需要进行动态处理的元素将使用“th:”前缀。 直接打开learning.html和启动工程后访问http://localhost:8080/learn/ 看到的效果，Thymeleaf做到了不破坏HTML自身内容的数据逻辑分离。 Thymeleaf的默认参数配置在application.properties中可以配置thymeleaf模板解析器属性12345678910111213141516171819202122232425# THYMELEAF (ThymeleafAutoConfiguration)#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.servlet.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests包的异常处理]]></title>
    <url>%2F2018%2F11%2F26%2Frequests%E5%8C%85%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[可以使用raise_for_status()来获取所有错误，并且在except语句中使用 requests.RequestException来得到错误原因： def get_bs_obj(link): try: response = requests.get(link, headers=headers, timeout=10) response.raise_for_status() bs_obj = bs(response.text) return bs_obj except requests.RequestException as e: print(e) return None 例如会产生报错： HTTPConnectionPool(host=&apos;synthezise.christuniversity.in&apos;, port=80): Max retries exceeded with url: / (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x0000021B9CB8A0F0&gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed&apos;,)) HTTPConnectionPool(host=&apos;icu2018cls.umk.edu.my&apos;, port=80): Max retries exceeded with url: / (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x0000021B9CB8ACF8&gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed&apos;,)) HTTPSConnectionPool(host=&apos;icsah.eu&apos;, port=443): Max retries exceeded with url: /events (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(-1, &apos;Unexpected EOF&apos;)&quot;,),)) HTTPSConnectionPool(host=&apos;icsah.eu&apos;, port=443): Max retries exceeded with url: /events (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(-1, &apos;Unexpected EOF&apos;)&quot;,),))]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy常用函数]]></title>
    <url>%2F2018%2F11%2F26%2Fnumpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)12345678910111213141516171819202122start标量 序列的起始值。stop标量 除非`endpoint`设置为False，否则序列的结束值。 在这种情况下，序列由除``num + 1``的最后一个组成 均匀间隔的样本，以便排除`stop`。注意这一步 当`endpoint`为False时，大小会改变。num：int，可选 要生成的样本数。默认值为50.必须为非负数。endpoint：bool，可选 如果为True，则`stop`是最后一个样本。否则，它不包括在内。 默认为True。 retstep：bool，可选 如果为True，则返回（`samples`，`step`），其中`step`是间距 样本之间。 dtype：dtype，可选 输出数组的类型。如果没有给出`dtype`，推断数据 从其他输入参数中键入。 1234567891011121314x = np.linspace(-1, 1, 5)out:array([-1. , -0.5, 0. , 0.5, 1. ])x = np.linspace(-1, 1, 5,endpoint=False)out:array([-1. , -0.6, -0.2, 0.2, 0.6])x = np.linspace(-1,1,5,endpoint=False,retstep=True)out:(array([-1. , -0.6, -0.2, 0.2, 0.6]), 0.4) np.random.normal(loc=0.0, scale=1.0, size=None)1234567loc：float或array_like浮点数 分布的平均值（“中心”）。scale：float或array_like浮点数 分布的标准偏差（展宽或“宽度”）。size：int或int的元组，可选 输出形状。如果给定的形状是例如“（m，n，k）”，那么 绘制了`m * n * k`样本 输出一个均值为0，标准差为0.05的(4,3)矩阵12345678n = np.random.normal(0,0.05,[4,3])out:array([[ 0.00875909, 0.04187258, 0.03422398], [ 0.04415144, 0.00083901, 0.06574384], [ 0.13169391, 0.09001974, -0.0384982 ], [ 0.00414203, 0.03999768, -0.09010478]]) np.newaxis作用为增加维度。 1x_data=np.linspace(-1,1,300)[:,np.newaxis] 意思为，从-1到1均匀取出300个间隔数字（包括-1,1），得到shape为(300,)的array，增加一个维度，变为(300,1)。 实际上可以使用reshape做到。等价于1x_data=np.linspace(-1,1,300).reshape(300,-1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib画图]]></title>
    <url>%2F2018%2F11%2F26%2Fmatplotlib%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[123456789import matplotlib.pyplot as pltimport numpy as npdata = np.arange(100, 201)plt.plot(data)plt.show() 1.通过np.arange(100, 201)生成一个[100, 200]之间的整数数组，它的值是：[100, 101, 102, … , 200] 2.通过matplotlib.pyplot将其绘制出来。很显然，绘制出来的值对应了图中的纵坐标（y轴）。而matplotlib本身为我们设置了图形的横坐标（x轴）：[0, 100]，因为我们刚好有100个数值 3.通过plt.show()将这个图形显示出来 修改代码：123456789import matplotlib.pyplot as pltimport numpy as npdata = np.arange(1, 200, 20)plt.plot(data, &apos;ro&apos;)plt.show() 加入点也可以用1plt.plot([1,2],[3,4]) 加入的2个点为(1,3),(2,4)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：mysql报错记录]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9Amysql%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.Operand should contain 1 column字面意思是，需要有1个数据列。如下sql：1cursor.execute("INSERT INTO lunwen(url) VALUES (%s)", (url,)) 可能是因为url并不是一个字符串，而是一个tuple或者list。 2.latin-1’ codec can’t encode character u’\u201c’ in position 0pymysql 正常情况下会尝试将所有的内容转为latin1字符集处理，所以在连接数据库的时候应该加上utf8编码：1db = pymysql.connect("localhost","root","00000000","TESTDB" ,use_unicode=True, charset="utf8")]]></content>
      <categories>
        <category>python</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium一些记录]]></title>
    <url>%2F2018%2F11%2F26%2Fselenium%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[selenium中文文档：https://selenium-python-zh.readthedocs.io/en/latest/index.html 使用selenium，安装好对应版本的chromedriver和chrome，然后将driver放入项目，用 driver = webdriver.Chrome()启动。 selenium刷新：123driver.refresh()# 或调用jsdriver.execute_script("location.reload()") 请求头配置参考：https://blog.csdn.net/u013440574/article/details/81911954 仅添加普通请求头：123456opt = webdriver.ChromeOptions() opt.set_headless() opt.add_argument( 'user-agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400') driver = webdriver.Chrome(options=opt) 这里使用opt作为chromedriver的参数，添加user-agent信息，然后调用webdriver.Chrome，并传入opt。 注：这里使用的是无窗口界面的chrome selenium爬虫，所以可以设置，如果使用有界面的，则不必设置，因为带界面必定带请求头和各种信息。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：常用操作]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.生成随机数12import randomprint(3 * random.random()) 生成0-3的随机数。1print(random.randint(0,99)) 生成0-99的随机整数。 还有很多，用的不多，临时百度。 2.MD5加密123456789101112131415161718# 由于MD5模块在python3中被移除# 在python3中使用hashlib模块进行md5操作import hashlib# 待加密信息str = 'this is a md5 test.'# 创建md5对象hl = hashlib.md5()# Tips# 此处必须声明encode# 若写法为hl.update(str) 报错为： Unicode-objects must be encoded before hashinghl.update(str.encode(encoding='utf-8'))print('MD5加密前为 ：' + str)print('MD5加密后为 ：' + hl.hexdigest()) 可以将hl定义在类中，每次类调用该hl，可以不用每次都生成。 3.数据库timestamp时间插入123import timeprint(time.localtime()) 输出：1time.struct_time(tm_year=2018, tm_mon=11, tm_mday=26, tm_hour=16, tm_min=35, tm_sec=51, tm_wday=0, tm_yday=330, tm_isdst=0) 4.list元素拼接为字符串12345b = ['p', 'a', 'n', ';']k = ''.join(b)&gt;&gt;&gt; k = ''.join(b)&gt;&gt;&gt; k'pan;' 5.tuple注意点tuple是不可变的，提供了一种完整的约束性，但是它支持的操作比较少（如果元组中含有一个list或者dict，list和dict还是能改变的）。 6.文件二进制读写文件写入二进制，使用12data = open("a.txt",'rb')data.write(all) 7.单个表达式代替循环1234L = [x + 10 for x in L]# 效率高于 for i in L: res.append(i+10) 8.读取文件最好的方式是不要打开123for line in open('test.txt'): print(line, end='')# end=''是为了除去每一行的\n，可以不用replace 9.去除line里的换行符123f = open('test.text')lines = f.readlines()lines = [line.rstrip() for line in lines] 10.对文件进行简单操作的可行处理方法1lines = [line.upper() for lin in open('test.txt')] 11.对lines进行较为复杂的操作12lines = [line.rstrip() for line in open('test.txt') if line[0] == 'p']# 结果是只留下第一个字符是p的元素 12.两个list进行拼接123&gt;&gt;&gt; z = [x + y for x in 'abc' for y in 'lmn']&gt;&gt;&gt; z['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn'] 13.判断dict是否有该键12345value = d.get('x',0)# 表示如果字典d里有键为x的，返回x的值，如果没有，返回0；# 也可以写为：value = d['x'] if 'x' in d else 0# emmm其实我觉得这个也挺好理解的，但是有点长。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python：list差集]]></title>
    <url>%2F2018%2F11%2F26%2Fpython%EF%BC%9Alist%E5%B7%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[list并集：1print list(set(a).union(set(b))) 或者：12345678k = [x for x in s1 if x in s2]&gt;&gt;&gt; x1 = [1,2,3,4,5,6,7]&gt;&gt;&gt; s1 = x1&gt;&gt;&gt; s2 = (3,4,6,8)&gt;&gt;&gt; k = [x for x in s1 if x in s2]&gt;&gt;&gt; k[3, 4, 6] list差集：12print list(set(b).difference(set(a)))# b中有而a中没有的]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：页面中存在多个input设置value属性]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AAinput%E8%AE%BE%E7%BD%AEvalue%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[首先要为这些所有的input框绑定上onChange的方法，然后还需要在this.state中去设置不同的input对应不同的值，最后还需要在changeValue的方法中去一一监听input输入时去修改对应的input的值。 也可以写一个changeValue方法，但是input的属性的name要和state里的名字要一样，如下所示：12345678910constructor() &#123; super(); this.state = &#123; login:&#123; username:'', password:'' &#125;, user:&#123;&#125; &#125;&#125; 1234567用户名：&lt;input type=&#123;'text'&#125; name=&#123;'username'&#125; value=&#123;this.state.login.username&#125; className=&#123;'username'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt;&lt;br/&gt;密码：&lt;input type=&#123;'password'&#125; name=&#123;'password'&#125; value=&#123;this.state.login.password&#125; className=&#123;'password'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; 12345changeValue(event) &#123; let newLogin = this.state.login; newLogin[event.target.name] = event.target.value; this.setState(&#123;login: newLogin&#125;) &#125; 使用event.target.name获取input的name属性，使用evnet.target.value获取input的value，令newLogin为this.state.login，然后将newLogin中名为event.target.name的属性的值设为event.target.value，之后再setState，从而可以改变state.login的值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session-1%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery禁止回车提交]]></title>
    <url>%2F2018%2F11%2F25%2FjQuery%E7%A6%81%E6%AD%A2%E5%9B%9E%E8%BD%A6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[在有input框进行输入提交时，如果有input的type为submit，则默认按回车会提交，可以用jQuery的方法进行阻拦：1234567891011$(function()&#123; $("input").each( function()&#123; $(this).keypress( function(e) &#123; var key = window.event ? e.keyCode : e.which; if(key.toString() === "13")&#123; return false; &#125; &#125;); &#125;);&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：form表单提交]]></title>
    <url>%2F2018%2F11%2F25%2Freact%EF%BC%9Aform%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[由于React在浏览器显示的是虚拟的DOM，我们在表单输入值后直接提交，是无法获取到这个值的。对此，官方给出的解决办法是：先把输入的值存放在组件的状态（state）中，之后通过状态的改变更新页面内容，从而显示出正确的值，用户提交的也是从state里获取的表单的value。 1234567891011constructor() &#123; super(); this.state = &#123; item:&#123; name:'', organization:'', school:'', &#125;, &#125;&#125; 设置提交方法和改变state的状态的方法：1234567891011121314151617181920212223handleSubmit(event) &#123; //阻止表单默认提交 event.preventDefault(); let item = this.state.item; axios.post(host + 'xxx/insert', item).then( response =&gt; &#123; let message = response.data; if (message === 'success') &#123; alert("插入成功"); window.location.href = '/xxx/list'; &#125; else &#123; alert("插入失败，请重试"); &#125; &#125; ); this.setState(&#123;item:item&#125;)&#125;changeValue(event) &#123; let newItem = this.state.item; newItem[event.target.name] = event.target.value; this.setState(&#123;item: newItem&#125;)&#125; 123456789101112131415161718192021&lt;form method=&#123;'post'&#125; onSubmit=&#123;this.handleSubmit.bind(this)&#125;&gt; &lt;label&gt;申请数据集名称： &lt;input type="text" name=&#123;'name'&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学校： &lt;input type="text" name=&#123;'organization'&#125; value=&#123;this.state.item.organization&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;学院： &lt;input type="text" name=&#123;'school'&#125; value=&#123;this.state.item.school&#125; onChange=&#123;this.changeValue.bind(this)&#125;/&gt; &lt;/label&gt; &lt;br/&gt; &lt;input type=&#123;'submit'&#125; value=&#123;'提交'&#125;/&gt; &lt;input value=&#123;'重置'&#125; type=&#123;'reset'&#125;/&gt;&lt;/form&gt; 注：form中用onSubmit替代action，其中每个input的name需要对应定义state时的状态，在使用axios调接口传值时，如果是java的springmvc的后端，需要将传输的属性与对应的实体类对接好。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot报错记录]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured12345678910Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following: If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active). 原因：引入mybatis的jar包时：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; springboot会默认加载org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration这个类，而DataSourceAutoConfiguration类使用了@Configuration注解向spring注入了dataSource bean，又因为项目中并没有关于dataSource相关的配置信息，所以当spring创建dataSource bean时因缺少相关的信息就会报错。 解决办法： 在@SpringBootApplication注解上加上exclude，解除自动加载DataSourceAutoConfiguration。 1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 在parent项目的pom.xml文件中保存所有子模块的共有jar依赖，非共有的依赖则在各模块自身的pom.xml文件中进行申明。建议采用此方法，好处在于各模块的依赖不会相互产生干扰。 2.maven配置时，测试出现“’mvn’ 不是内部或外部命令,也不是可运行的程序”错误配置maven。 在环境变量的PATH中配置maven的bin目录。 使用mvn package打包成功后显示日志：1234567-----------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 46.791 s[INFO] Finished at: 2018-11-21T16:12:36+08:00[INFO] Final Memory: 35M/275M[INFO] ------------------------------------------------------------------------ 3.java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents……..具体错误：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Tue May 15 21:38:04 CST 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.java.sql.SQLException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71) at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76) at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862) at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:444) at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230) at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226) at java.sql.DriverManager.getConnection(Unknown Source) at java.sql.DriverManager.getConnection(Unknown Source) at zhu.jdbc.unit.UnitMysql.getConnection(UnitMysql.java:34) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:55) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1) at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87) at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source)Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) at java.lang.reflect.Constructor.newInstance(Unknown Source) at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:59) at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:83) at com.mysql.cj.util.TimeUtil.getCanonicalTimezone(TimeUtil.java:128) at com.mysql.cj.protocol.a.NativeProtocol.configureTimezone(NativeProtocol.java:2201) at com.mysql.cj.protocol.a.NativeProtocol.initServerSession(NativeProtocol.java:2225) at com.mysql.cj.jdbc.ConnectionImpl.initializePropsFromServer(ConnectionImpl.java:1391) at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:993) at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:852) ... 36 more五月 15, 2018 9:38:04 下午 org.apache.catalina.core.StandardWrapperValve invoke严重: Servlet.service() for servlet [Servlet_TbUser] in context with path [/myweb2] threw exceptionjava.lang.NullPointerException at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:59) at zhu.jdbc.dao.imp.ITb_UserImpI.insertData(ITb_UserImpI.java:1) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:35) at zhu.jdbc.service.imp.ITb_UserServiceImpI.insertData(ITb_UserServiceImpI.java:1) at zhu.jdbc.servlet.Servlet_TbUser.Insert(Servlet_TbUser.java:87) at zhu.jdbc.servlet.Servlet_TbUser.doPost(Servlet_TbUser.java:41) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) 出现这个的原因是因为 mysql返回的时间总是有问题，比实际时间要早8小时。 解决办法：在jdbc连接的url后面加上serverTimezone=GMT即可解决问题，如果需要使用gmt+8时区，需要写成GMT%2B8。 为了防止因为日期为null报错，可以直接加上： ?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 例如链接数据库，可以写为： jdbc.url=jdbc:mysql://xxx.xxx.xxx.xxx/xxxxx?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull 4.Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdbc.Driver. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.这个问题是 使用了新的mysql驱动包，但驱动声明不是最新的： DriverClassName 从 “com.mysql.jdbc.Driver” 换成 “com.mysql.cj.jdbc.Driver” 即可。 5.spring Failed to convert property value of type ‘java.lang.String’ to required type ‘int’ for property原错误是不能将long的null属性转化出来，但是没找到原来的错误。采取的方式是，把pojo类中的long全改为Integer。 如果是date出错，参考问题3，在数据库连接时加上zeroDateTimeBehavior=convertToNull。 6. This application has no explicit mapping for /…原因1:Application启动类的位置不对.要将Application类放在最外侧,即包含所有子包原因:spring-boot会自动加载启动类所在包下及其子包下的所有组件. 原因2:在springboot的配置文件:application.yml或application.properties中关于视图解析器的配置问题:当pom文件下的spring-boot-starter-paren版本高时使用:spring.mvc.view.prefix/spring.mvc.view.suffix当pom文件下的spring-boot-starter-paren版本低时使用:spring.view.prefix/spring.view.suffix 原因3:控制器的URL路径书写问题@RequestMapping(“xxxxxxxxxxxxxx”)实际访问的路径与”xxx”不符合. 原因4：**application.properties中设置thymeleaf的属性时，注释掉spring.thymeleaf.view-names=，这是可解析的视图名称列表，用逗号分隔，但是如果不写，就会报这个错误。 7.springboot中 server: context-path: /spring报错：Deprecated configuration property是版本问题，这个新版本不是这种写法：应该变化为：server.servlet.context-path: /spring]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用JdbcTemplate（一）]]></title>
    <url>%2F2018%2F11%2F24%2Fspringboot%E4%BD%BF%E7%94%A8JdbcTemplate%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.mysql.git 环境配置修改 POM 文件，添加spring-boot-starter-jdbc依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 添加mysql依赖（spring-boot-starter-jdbc 默认使用tomcat-jdbc数据源，如果要使用其他数据源，需要添加额外的依赖，这里使用了阿里巴巴的数据池管理）：12345678&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt; 数据源配置在src/main/resources/application.properties中配置数据源信息:1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/sss?serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=123456 在Application.java中配置：123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootApplicationpublic class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125; @Autowired private Environment environment; /** * destroy-method="close"的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. * @return */ @Bean(destroyMethod = "close") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(environment.getProperty("spring.datasource.url")); dataSource.setUsername(environment.getProperty("spring.datasource.username")); //用户名 dataSource.setPassword(environment.getProperty("spring.datasource.password")); //密码 dataSource.setDriverClassName(environment.getProperty("spring.datasource.driver-class-name")); dataSource.setInitialSize(2); //初始化时建立物理连接的个数 dataSource.setMaxActive(20); //最大连接池数量 dataSource.setMinIdle(0); //最小连接池数量 dataSource.setMaxWait(60000); //获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery("SELECT 1"); //用来检测连接是否有效的sql dataSource.setTestOnBorrow(false); //申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true); //建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false); //是否缓存preparedStatement，也就是PSCache return dataSource; &#125;&#125; 数据12345678910111213-- auto-generated definitionCREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id)) ENGINE = InnoDB; 代码实体类：1234567891011package com.example.myproject.domain;@Componentpublic class TbStudent &#123; private Integer id; private String name; private String sex; private Integer age; private Integer clazzId; //getter,setter 可以用idea自动生成，将long类型的全改为Integer，为了以后不报错。 DAO层123456789101112131415161718package com.example.myproject.dao;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentDao &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.myproject.dao.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class TbStudentDaoImpl implements TbStudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int insert(TbStudent tbStudent) &#123; return jdbcTemplate.update("insert into tb_student(NAME) VALUES (?)",tbStudent.getName()); &#125; @Override public int update(TbStudent tbStudent) &#123; return jdbcTemplate.update("update tb_student set NAME=? where id=?",tbStudent.getName(),tbStudent.getId()); &#125; @Override public int delete(long id) &#123; return jdbcTemplate.update("delete from tb_student where id=?", id); &#125; @Override public TbStudent findTbStudent(long id) &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student WHERE id=?", new Object[]&#123;id&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); if(list != null &amp;&amp; list.size() &gt; 0) &#123; TbStudent tbStudent = list.get(0); return tbStudent; &#125;else &#123; return null; &#125; &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; List&lt;TbStudent&gt; list = jdbcTemplate.query("SELECT * FROM tb_student", new Object[]&#123;&#125;, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)); return list; &#125;&#125; 注：使用jdbcTemplate.query时，需要注意这个写法：new Object[]{id}, new BeanPropertyRowMapper&lt;&gt;(TbStudent.class)。并且如果只需要一个，需要进行null和size判定，之后取出一个，不然会报错。 Service层1234567891011121314151617181920package com.example.myproject.service;import com.example.myproject.domain.TbStudent;import java.util.List;public interface TbStudentService &#123; int insert(TbStudent tbStudent); int update(TbStudent tbStudent); int delete(long id); TbStudent findTbStudent(long id); List&lt;TbStudent&gt; findAll();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.myproject.service.impl;import com.example.myproject.dao.TbStudentDao;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TbStudentServiceImpl implements TbStudentService&#123; @Resource(name = "tbStudentDaoImpl") private TbStudentDao tbStudentDao; @Override public int insert(TbStudent tbStudent) &#123; return tbStudentDao.insert(tbStudent); &#125; @Override public int update(TbStudent tbStudent) &#123; return tbStudentDao.update(tbStudent); &#125; @Override public int delete(long id) &#123; return tbStudentDao.delete(id); &#125; @Override public TbStudent findTbStudent(long id) &#123; return tbStudentDao.findTbStudent(id); &#125; @Override public List&lt;TbStudent&gt; findAll() &#123; return tbStudentDao.findAll(); &#125;&#125; Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.myproject.web;import com.example.myproject.domain.TbStudent;import com.example.myproject.service.TbStudentService;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author 34924 */@RestController@RequestMapping("/tbStudent")public class TbStudentController &#123; @Resource(name = "tbStudentServiceImpl") private TbStudentService tbStudentService; @RequestMapping("/findAll") public List&lt;TbStudent&gt; findAll() &#123; return tbStudentService.findAll(); &#125; @RequestMapping("/delete/&#123;id&#125;") public int delete(@PathVariable long id) &#123; return tbStudentService.delete(id); &#125; @RequestMapping(value = "/insert",method = RequestMethod.POST) public int insert(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.insert(tbStudent); &#125; @RequestMapping(value = "/update",method = RequestMethod.GET) public int update(@RequestParam Integer id,@RequestParam String name) &#123; TbStudent tbStudent = tbStudentService.findTbStudent(id); tbStudent.setName(name); return tbStudentService.update(tbStudent); &#125; @RequestMapping(value = "/findOne",method = RequestMethod.POST) public TbStudent findOne(@RequestBody TbStudent tbStudent) &#123; return tbStudentService.findTbStudent(tbStudent.getId()); &#125;&#125; 注：此处全写的是接口 findAll用的是普通的get请求; delete用的restful的形式； insert用的post请求； update用的get请求，使用@RequestParam，注意post请求使用@RequestBody，而get请求只能使用@RequestParam或者是使用@ModelAttribute（此处未使用）； findOne用的post请求。 如果将update改为使用@ModelAttribute，如下：1234@RequestMapping(value = "/update",method = RequestMethod.GET)public int update(@ModelAttribute TbStudent tbStudent) &#123; return tbStudentService.update(tbStudent);&#125; 使用JSONObject改insert为JSONObject接受参数：123456@RequestMapping(value = "/insert2",method = RequestMethod.POST)public int insert2(@RequestBody JSONObject tbStudent) &#123; TbStudent tbStudent1 = new TbStudent(); tbStudent1.setName((String)tbStudent.get("name")); return tbStudentService.insert(tbStudent1);&#125; 引入的包为：1import net.minidev.json.JSONObject; 在pom.xml中加入：12345&lt;dependency&gt; &lt;groupId&gt;net.minidev&lt;/groupId&gt; &lt;artifactId&gt;json-smart&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 测试效果findAll： delete： insert： update： 使用@ModelAttribute的注解： findOne： 使用thymeleaf添加文件：1234567891011121314151617181920212223242526272829package com.example.myproject.web;import com.example.myproject.service.TbStudentService;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * @author 34924 */@Controller@RequestMapping("/tbStudent/html")public class TbStudentControllerForHtml &#123; @Resource(name = "tbStudentServiceImpl") private TbStudentService tbStudentService; @RequestMapping("/findAll") public String findAll(ModelMap model) &#123; model.addAttribute("items", tbStudentService.findAll()); return "student"; &#125;&#125; student.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;student&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;student&lt;/h1&gt;this is student.&lt;br&gt;&lt;div th:each="item : $&#123;items&#125;"&gt; &lt;a th:text="$&#123;item.id&#125;"&gt;123&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:text="$&#123;item.name&#125;"&gt;name&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:text="$&#123;item.clazzId&#125;"&gt;name&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a th:if="$&#123;item.clazzId &#125;"&gt;123132&lt;/a&gt; &lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 即可显示。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mysql</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod命令]]></title>
    <url>%2F2018%2F11%2F24%2Fchmod%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/home/user/java/jdk1.7.0/bin/java:permission denied处理方法：提升java为执行权限1chmod +x /home/user/java/jdk1.7.0/bin/java 以及javac权限不够也是如此处理。 chmod命令详解使用格式和方法Linux/Ubuntu 系统中文件调用的权限分为三级:文件拥有者(u)、群组(g)、其他(o)。用chmod就可以更改文件的权限。chmod是一个相当灵活的命令，对同一个文件的权限的修改可以用多种风格的命令格式来实现。 方式一语法格式： chmod [-vR] mode 文件名 参数说明: mode 权限设置字串,格式为[ugoa] [+-=] [rwx] u 表示文件的拥有者 g 表示与此文件拥有者属于一个组群的人 o 表示其他人 a 表示包含以上三者即文件拥有者(u)、群组(g)、其他(o) +表示增加权限 -表示取消权限 =表示唯一设置权限 r 表示有读取的权限 w 表示有写入的权限 x 表示有执行的权限 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改例： 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取、写入、执行的权限。 在这里就需要结合sudo命令来使用123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 或者使用123ownlinux@server:/var/www$ sudo chmod ugo+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 命令不一样，但执行后的效果是一样的。 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod a+rwx -R ownlinux[sudo] password for ownlinux: （此时输入你的密码） 语法格式： chmod [-vR] [No] 文件名 参数说明:No 三位代表相应权限的数字 -v 显示权限改变的详细资料 -R 表示对当前目录下的所有文件和子目录进行相同的权限更改 可能这种方式对于初学者来说有一定的难度，但这种方法学会后在更改文件权限就变得非常的简单。 刚才已经说过了，[No]参数 是三位代表相应权限的数字。从左向右，第一位数学代表文件拥有者(u)的权限、群组(g)的权限、其他(o)的权限。每一个数字就对应该级用户拥有的权限即为rwx相应的数字之和。 类似于二进制，如果是所有用户拥有该文件的读取、写入、执行的权限就是拥有者(u)的权限(4+2+1=7)群组(g)的权限(4+2+1=7)其他(o)的权限(4+2+1=7即为777。注意：如果没有读取的权限则”r”相应的数字编号就为”0″,写入(w)、执行(x)同理。 我们要将当前目录下ownlinux这个文件的权限修为所有用户拥有该文件的读取(r)、写入(w)、执行(x)的权限。回顾一下方式一的命令格式。123ownlinux@server:/var/www$ sudo chmod a+rwx ownlinux[sudo] password for ownlinux: （此时输入你的密码） 可以改为：123ownlinux@server:/var/www$ sudo chmod 777 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 如果要让当前目录下ownlinux这个文件的权限修为该文件的拥有者(u)有该文件的读取(r)、写入(w)、执行(x)的权限,群组(g)和其他(o)的用户只有读取(r)和执行(x)的权限,运行以下命令：123ownlinux@server:/var/www$ sudo chmod 755 ownlinux[sudo] password for ownlinux: （此时输入你的密码） 要为此目录及子目录所有用户拥有该文件的读取、写入、执行的权限，此时需要加-R123ownlinux@server:/var/www$ sudo chmod 777 -R ownlinux[sudo] password for ownlinux: （此时输入你的密码）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放端口查看和打开关闭]]></title>
    <url>%2F2018%2F11%2F24%2F%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[查看打开端口1sudo iptables -L -n 打开80端口1sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react：存储session]]></title>
    <url>%2F2018%2F11%2F24%2Freact%EF%BC%9A%E5%AD%98%E5%82%A8session%2F</url>
    <content type="text"><![CDATA[react框架中使用session，如果是单个字符串：1sessionStorage.setItem("key",value); 取出时：1var result = sessionStorage.getItem("key") 如果是json，在存储时需要将json对象通过stringify()方法转为字符串，存入sessionStorage：1sessionStorage.setItem("jsonKey",JSON.stringify(jsonData)); 取出时需要再转回json：1var result = JSON.parse(sessionStorage.getItem("jsonKey")); 移除session：1sessionStorage.removeItem("data");]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot配置文件]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.config_test.git Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里:12com.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 在类中引入可以用@Value(“${….}”)的注解形式，也可以如下引用：12345678910111213package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "com.example.myproject.customer")public class Customer &#123; private String id; private String name; //getter,setter,toString&#125; 需要在springboot入口类上加上@EnableConfigurationProperties({Customer.class})注解，指明使用了配置文件的类。 12345678910111213141516package com.example.myproject;import com.example.myproject.domain.Customer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;@SpringBootApplication@EnableConfigurationProperties(&#123;Customer.class&#125;)public class MyprojectApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyprojectApplication.class, args); &#125;&#125; 参数间引用在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置：123com.example.myproject.customer.id = 001com.example.myproject.customer.name = jlcom.example.myproject.customer.title = 序号$&#123;com.example.myproject.customer.id&#125;,姓名$&#123;com.example.myproject.customer.name&#125; 运行测试，如果出现中文乱码，则进行以下步骤： java开发工具Idea下解决方案： File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 注意：做了上面操作后，一定要重新创建application.properties，才有效。 输出效果：1Customer&#123;id='001', name='jl', title='序号001,姓名jl'&#125; 使用自定义配置文件有时候我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里我明取名为test.properties,路径跟也放在src/main/resources下面。123com.example.myproject.customer2.id = 0011com.example.myproject.customer2.name = jlsdfcom.example.myproject.customer2.title = 序号$&#123;com.example.myproject.customer2.id&#125;,姓名$&#123;com.example.myproject.customer2.name&#125; 注意，这里的自定义配置名字不能与之前相同，不然会读取不到（踩坑贼开心）。 我们新建一个bean类,如下：12345678910111213141516package com.example.myproject.domain;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:test.properties")@ConfigurationProperties(prefix = "com.example.myproject.customer2")public class Customer2 &#123; private String id; private String name; private String title; //getter,setter,toString &#125; 其中使用@PropertySource(value = “classpath:test.properties”)指向了properties文件，使用@ConfigurationProperties(prefix = “com.example.myproject.customer2”)指向了前缀。 在CustomerService和CustomerController中增加函数与调用：1234567891011121314CustomerService.java public Customer2 getCustomer2()&#123; return customer2; &#125;CustomerController.java @RequestMapping("/customer") public String customer(ModelMap map) &#123;// Customer customer = customerService.getCustomer(); Customer2 customer = customerService.getCustomer2(); map.addAttribute("customer", customer); return "index"; &#125; 也可以在Test中进行输出测试。 注：出现错误Spring Boot Configuration Annotion Processor not found in classpath。在pom.xml中引入：12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; 重启idea，会出现Re-run Spring Boot Configuration Annotation Processor to update generated metadata，这个问题可以忽略，不影响代码执行。只是提醒用户，进行必要的重新编译。 随机值配置配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。 range.properties写入：123456range.secret=$&#123;random.value&#125;range.number=$&#123;random.int&#125;range.bignumber=$&#123;random.long&#125;range.uuid=$&#123;random.uuid&#125;range.number.less.than.ten=$&#123;random.int(10)&#125;range.number.in.range=$&#123;random.int[1024,65536]&#125; 使用java接收，Range.java1234567891011121314151617181920212223package com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = "classpath:range.properties")@ConfigurationProperties(prefix = "range")public class Range &#123; private String secret; private int number; private long bignumber; private String uuid; @Value("$&#123;range.number.less.than.ten&#125;") private int lessThanTen; @Value("$&#123;range.number.in.range&#125;") private int rangeNumber; //setter,getter,toString&#125; 配置相应的service和controller。显示效果如下： 注意，不重启springboot应用，这些值不会改变。 外部配置-命令行参数配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：1java -jar xx.jar 可以以下命令修改tomcat端口号：1java -jar xx.jar --server.port=9090 可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。 如果怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。 测试中的@TestPropertySource注解。 测试中的@SpringBootTest#properties注解特性。 命令行参数 SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。 ServletConfig初始化参数。 ServletContext初始化参数。 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}） 应用程序以外的application.properties或者appliaction.yml文件 打包在应用程序内的application.properties或者appliaction.yml文件 通过@PropertySource标注的属性源 默认属性(通过SpringApplication.setDefaultProperties指定). 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，列如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件的优先级application.properties和application.yml文件可以放在一下四个位置： 外置，在相对于应用程序运行目录的/congfig子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.yml里面的属性就会覆盖application.properties里的属性。 当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。 如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 当然你也可以用命令行启动的时候带上参数：1java -jar xxx.jar --spring.profiles.active=dev 给不同的环境添加不同的端口属性server.port，然后根据指定不同的spring.profiles.active来切换使用。 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口：1public interface DBConnector &#123; public void configure(); &#125; 定义2个类实现：1234567891011121314151617181920@Component@Profile("devDb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125;@Component@Profile("testDb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125; 在application.properties配置，激活其中一个类：1spring.profiles.active=testDb PS：这里一定要写对，如果写成testdb就会报错。 因为这里用的是thyemleaf模版，使用@RestController注解，应该是作为接口，所以可以用postman做测试，可以看到输出了testdb。 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile 12spring.profiles.active: testdb spring.profiles.include: proddb,prodmq]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot常用属性汇总]]></title>
    <url>%2F2018%2F11%2F21%2Fspringboot%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[可以在application.properties/application.yml文件中或作为命令行开关指定各种属性。本节提供了常用的Spring Boot属性列表，以及对使用它们的底层类的引用。 属性贡献可以来自您的类路径上的其他jar文件，因此您不应该考虑这是一个详尽的列表。定义您自己的属性也是完全合法的。此示例文件仅作为指南。不要将整个内容复制/粘贴到您的应用程序中;而只是选择你需要的属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184# ===================================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^# ===================================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)# LOGGINGlogging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logbacklogging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.logging.file= # Log file name. For instance `myapp.log`logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`logging.path= # Location of the log file. For instance `/var/log`logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.# AOPspring.aop.auto=true # Add @EnableAspectJAutoProxy.spring.aop.proxy-target-class=false # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false).# IDENTITY (ContextIdApplicationContextInitializer)spring.application.index= # Application index.spring.application.name= # Application name.# ADMIN (SpringApplicationAdminJmxAutoConfiguration)spring.application.admin.enabled=false # Enable admin features for the application.spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.# AUTO-CONFIGURATIONspring.autoconfigure.exclude= # Auto-configuration classes to exclude.# SPRING COREspring.beaninfo.ignore=true # Skip search of BeanInfo classes.# SPRING CACHE (CacheProperties)spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.spring.cache.caffeine.spec= # The spec to use to create caches. Check CaffeineSpec for more details on the spec format.spring.cache.couchbase.expiration=0 # Entry expiration in milliseconds. By default the entries never expire.spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.spring.cache.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.spring.cache.type= # Cache type, auto-detected according to the environment by default.# SPRING CONFIG - using environment property only (ConfigFileApplicationListener)spring.config.location= # Config file locations.spring.config.name=application # Config file name.# HAZELCAST (HazelcastProperties)spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.# PROJECT INFORMATION (ProjectInfoProperties)spring.info.build.location=classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.spring.info.git.location=classpath:git.properties # Location of the generated git.properties file.# JMXspring.jmx.default-domain= # JMX domain name.spring.jmx.enabled=true # Expose management beans to the JMX domain.spring.jmx.server=mbeanServer # MBeanServer bean name.# Email (MailProperties)spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.spring.mail.host= # SMTP server host. For instance `smtp.example.com`spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.spring.mail.password= # Login password of the SMTP server.spring.mail.port= # SMTP server port.spring.mail.properties.*= # Additional JavaMail session properties.spring.mail.protocol=smtp # Protocol used by the SMTP server.spring.mail.test-connection=false # Test that the mail server is available on startup.spring.mail.username= # Login user of the SMTP server.# APPLICATION SETTINGS (SpringApplication)spring.main.banner-mode=console # Mode used to display the banner when the application runs.spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.spring.main.web-environment= # Run the application in a web environment (auto-detected by default).# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding= # Expected character encoding the application must use.# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.always-use-message-format=false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.spring.messages.encoding=UTF-8 # Message bundles encoding.spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.# OUTPUTspring.output.ansi.enabled=detect # Configure the ANSI output.# PID FILE (ApplicationPidFileWriter)spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).# PROFILESspring.profiles.active= # Comma-separated list (or list if using YAML) of active profiles.spring.profiles.include= # Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).# SENDGRID (SendGridAutoConfiguration)spring.sendgrid.api-key= # SendGrid api key (alternative to username/password)spring.sendgrid.username= # SendGrid account usernamespring.sendgrid.password= # SendGrid account passwordspring.sendgrid.proxy.host= # SendGrid proxy hostspring.sendgrid.proxy.port= # SendGrid proxy port# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.address= # Network address to which the server should bind to.server.compression.enabled=false # If response compression is enabled.server.compression.excluded-user-agents= # List of user-agents to exclude from compression.server.compression.mime-types= # Comma-separated list of MIME types that should be compressed. For instance `text/html,text/css,application/json`server.compression.min-response-size= # Minimum response size that is required for compression to be performed. For instance 2048server.connection-timeout= # Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector's container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`server.context-path= # Context path of the application.server.display-name=application # Display name of the application.server.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.server.error.include-stacktrace=never # When to include a "stacktrace" attribute.server.error.path=/error # Path of the error controller.server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.server.jetty.acceptors= # Number of acceptor threads to use.server.jetty.max-http-post-size=0 # Maximum size in bytes of the HTTP post or put content.server.jetty.selectors= # Number of selector threads to use.server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servletserver.jsp-servlet.registered=true # Whether or not the JSP servlet is registeredserver.port=8080 # Server HTTP port.server.server-header= # Value to use for the Server response header (no header is sent if empty)server.servlet-path=/ # Path of the main dispatcher servlet.server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.server.session.cookie.comment= # Comment for the session cookie.server.session.cookie.domain= # Domain for the session cookie.server.session.cookie.http-only= # "HttpOnly" flag for the session cookie.server.session.cookie.max-age= # Maximum age of the session cookie in seconds.server.session.cookie.name= # Session cookie name.server.session.cookie.path= # Path of the session cookie.server.session.cookie.secure= # "Secure" flag for the session cookie.server.session.persistent=false # Persist session data between restarts.server.session.store-dir= # Directory used to store session data.server.session.timeout= # Session timeout in seconds.server.session.tracking-modes= # Session tracking modes (one or more of the following: "cookie", "url", "ssl").server.ssl.ciphers= # Supported SSL ciphers.server.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store.server.ssl.enabled= # Enable SSL support.server.ssl.enabled-protocols= # Enabled SSL protocols.server.ssl.key-alias= # Alias that identifies the key in the key store.server.ssl.key-password= # Password used to access the key in the key store.server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password= # Password used to access the key store.server.ssl.key-store-provider= # Provider for the key store.server.ssl.key-store-type= # Type of the key store.server.ssl.protocol=TLS # SSL protocol to use.server.ssl.trust-store= # Trust store that holds SSL certificates.server.ssl.trust-store-password= # Password used to access the trust store.server.ssl.trust-store-provider= # Provider for the trust store.server.ssl.trust-store-type= # Type of the trust store.server.tomcat.accept-count= # Maximum queue length for incoming connection requests when all possible request processing threads are in use.server.tomcat.accesslog.buffered=true # Buffer output such that it is only flushed periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address, Hostname, protocol and port used for the request.server.tomcat.accesslog.rotate=true # Enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-connections= # Maximum number of connections that the server will accept and process at any given time.server.tomcat.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.tomcat.max-threads=0 # Maximum amount of worker threads.server.tomcat.min-spare-threads=0 # Minimum amount of worker threads.server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named "X-Forwarded-Proto".server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected by appending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.server.undertow.accesslog.dir= # Undertow access log directory.server.undertow.accesslog.enabled=false # Enable access log.server.undertow.accesslog.pattern=common # Format pattern for access logs.server.undertow.accesslog.prefix=access_log. # Log file name prefix.server.undertow.accesslog.rotate=true # Enable access log rotation.server.undertow.accesslog.suffix=log # Log file name suffix.server.undertow.buffer-size= # Size of each buffer in bytes.server.undertow.buffers-per-region= # Number of buffer per region.server.undertow.direct-buffers= # Allocate buffers outside the Java heap.server.undertow.io-threads= # Number of I/O threads to create for the worker.server.undertow.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.undertow.worker-threads= # Number of worker threads.# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.cache=false # Enable template caching.spring.freemarker.charset=UTF-8 # Template encoding.spring.freemarker.check-template-location=true # Check that the templates location exists.spring.freemarker.content-type=text/html # Content-Type value.spring.freemarker.enabled=true # Enable MVC view resolution for this technology.spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker's Configuration.spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.spring.freemarker.view-names= # White list of view names that can be resolved.# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.cache= # Enable template caching.spring.groovy.template.charset=UTF-8 # Template encoding.spring.groovy.template.check-template-location=true # Check that the templates location exists.spring.groovy.template.configuration.*= # See GroovyMarkupConfigurerspring.groovy.template.content-type=test/html # Content-Type value.spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.spring.groovy.template.view-names= # White list of view names that can be resolved.# SPRING HATEOAS (HateoasProperties)spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.# HTTP message conversionspring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to "gson" to force the use of Gson when both it and Jackson are on the classpath.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.spring.http.encoding.enabled=true # Enable http encoding support.spring.http.encoding.force= # Force the encoding to the configured charset on HTTP requests and responses.spring.http.encoding.force-request= # Force the encoding to the configured charset on HTTP requests. Defaults to true when "force" has not been specified.spring.http.encoding.force-response= # Force the encoding to the configured charset on HTTP responses.spring.http.encoding.mapping= # Locale to Encoding mapping.# MULTIPART (MultipartProperties)spring.http.multipart.enabled=true # Enable support of multi-part uploads.spring.http.multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.location= # Intermediate location of uploaded files.spring.http.multipart.max-file-size=1MB # Max file size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.max-request-size=10MB # Max request size. Values can use the suffixed "MB" or "KB" to indicate a Megabyte or Kilobyte size.spring.http.multipart.resolve-lazily=false # Whether to resolve the multipart request lazily at the time of file or parameter access.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization.spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.spring.jackson.generator.*= # Jackson on/off features for generators.spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" will be used as a fallback if it is configured with a format string.spring.jackson.locale= # Locale used for formatting.spring.jackson.mapper.*= # Jackson general purpose on/off features.spring.jackson.parser.*= # Jackson on/off features for parsers.spring.jackson.property-naming-strategy= # One of the constants on Jackson's PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`# JERSEY (JerseyProperties)spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of "@ApplicationPath" if specified.spring.jersey.filter.order=0 # Jersey filter chain order.spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.spring.jersey.servlet.load-on-startup=-1 # Load on startup priority of the Jersey servlet.spring.jersey.type=servlet # Jersey integration type.# SPRING LDAP (LdapProperties)spring.ldap.urls= # LDAP URLs of the server.spring.ldap.base= # Base suffix from which all operations should originate.spring.ldap.username= # Login user of the server.spring.ldap.password= # Login password of the server.spring.ldap.base-environment.*= # LDAP specification settings.# EMBEDDED LDAP (EmbeddedLdapProperties)spring.ldap.embedded.port= # Embedded LDAP port.spring.ldap.embedded.credential.username= # Embedded LDAP username.spring.ldap.embedded.credential.password= # Embedded LDAP password.spring.ldap.embedded.base-dn= # The base DNspring.ldap.embedded.ldif=classpath:schema.ldif # Schema (LDIF) script resource reference.# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.# MUSTACHE TEMPLATES (MustacheAutoConfiguration)spring.mustache.allow-request-override= # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.allow-session-override= # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.cache= # Enable template caching.spring.mustache.charset= # Template encoding.spring.mustache.check-template-location= # Check that the templates location exists.spring.mustache.content-type= # Content-Type value.spring.mustache.enabled= # Enable MVC view resolution for this technology.spring.mustache.expose-request-attributes= # Set whether all request attributes should be added to the model prior to merging with the template.spring.mustache.expose-session-attributes= # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.mustache.expose-spring-macro-helpers= # Set whether to expose a RequestContext for use by Spring's macro library, under the name "springMacroRequestContext".spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.spring.mustache.request-context-attribute= # Name of the RequestContext attribute for all views.spring.mustache.suffix=.html # Suffix to apply to template names.spring.mustache.view-names= # White list of view names that can be resolved.# SPRING MVC (WebMvcProperties)spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.spring.mvc.dispatch-options-request=true # Dispatch OPTIONS requests to the FrameworkServlet doService method.spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.spring.mvc.formcontent.putfilter.enabled=true # Enable Spring's HttpPutFormContentFilter.spring.mvc.ignore-default-model-on-redirect=true # If the content of the "default" model should be ignored during redirect scenarios.spring.mvc.locale= # Locale to use. By default, this locale is overridden by the "Accept-Language" header.spring.mvc.locale-resolver=accept-header # Define how the locale should be resolved.spring.mvc.log-resolved-exception=false # Enable warn logging of exceptions resolved by a "HandlerExceptionResolver".spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.throw-exception-if-no-handler-found=false # If a "NoHandlerFoundException" should be thrown if no Handler was found to process a request.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# SPRING RESOURCES HANDLING (ResourceProperties)spring.resources.add-mappings=true # Enable default resource handling.spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.spring.resources.chain.cache=true # Enable caching in the Resource chain.spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.spring.resources.chain.gzipped=false # Enable resolution of already gzipped resources.spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.spring.resources.chain.strategy.fixed.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.# SPRING SESSION (SessionProperties)spring.session.hazelcast.flush-mode=on-save # Sessions flush mode.spring.session.hazelcast.map-name=spring:session:sessions # Name of the map used to store sessions.spring.session.jdbc.initializer.enabled= # Create the required session tables on startup if necessary. Enabled automatically if the default table name is set or a custom schema is configured.spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.session.jdbc.table-name=SPRING_SESSION # Name of database table used to store sessions.spring.session.mongo.collection-name=sessions # Collection name used to store sessions.spring.session.redis.flush-mode=on-save # Sessions flush mode.spring.session.redis.namespace= # Namespace for keys used to store sessions.spring.session.store-type= # Session store type.# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=false # Enable the connection status view for supported providers.# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application's Facebook App IDspring.social.facebook.app-secret= # your application's Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application's LinkedIn App IDspring.social.linkedin.app-secret= # your application's LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application's Twitter App IDspring.social.twitter.app-secret= # your application's Twitter App Secret# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.cache=true # Enable template caching.spring.thymeleaf.check-template=true # Check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Check that the templates location exists.spring.thymeleaf.content-type=text/html # Content-Type value.spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.spring.thymeleaf.encoding=UTF-8 # Template encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.# SPRING WEB SERVICES (WebServicesProperties)spring.webservices.path=/services # Path that serves as the base URI for the services.spring.webservices.servlet.init= # Servlet init parameters to pass to Spring Web Services.spring.webservices.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)security.basic.authorize-mode=role # Security authorize mode to apply.security.basic.enabled=true # Enable basic authentication.security.basic.path=/** # Comma-separated list of paths to secure.security.basic.realm=Spring # HTTP basic realm name.security.enable-csrf=false # Enable Cross Site Request Forgery support.security.filter-order=0 # Security filter chain order.security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.security.headers.cache=true # Enable cache control HTTP headers.security.headers.content-security-policy= # Value for content security policy header.security.headers.content-security-policy-mode=default # Content security policy mode.security.headers.content-type=true # Enable "X-Content-Type-Options" header.security.headers.frame=true # Enable "X-Frame-Options" header.security.headers.hsts=all # HTTP Strict Transport Security (HSTS) mode (none, domain, all).security.headers.xss=true # Enable cross site scripting (XSS) protection.security.ignored= # Comma-separated list of paths to exclude from the default secured paths.security.require-ssl=false # Enable secure channel for all requests.security.sessions=stateless # Session creation policy (always, never, if_required, stateless).security.user.name=user # Default user name.security.user.password= # Password for the default user name. A random password is logged on startup by default.security.user.role=USER # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)security.oauth2.client.client-id= # OAuth2 client id.security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default# SECURITY OAUTH2 RESOURCES (ResourceServerProperties)security.oauth2.resource.filter-order= # The order of the filter chain used to authenticate tokens.security.oauth2.resource.id= # Identifier of the resource.security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.security.oauth2.resource.service-id=resource #security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.security.oauth2.resource.user-info-uri= # URI of the user endpoint.# SECURITY OAUTH2 SSO (OAuth2SsoProperties)security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdaptersecurity.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server# ----------------------------------------# DATA PROPERTIES# ----------------------------------------# FLYWAY (FlywayProperties)flyway.baseline-description= #flyway.baseline-version=1 # version to start migrationflyway.baseline-on-migrate= #flyway.check-location=false # Check that migration scripts location exists.flyway.clean-on-validation-error= #flyway.enabled=true # Enable flyway.flyway.encoding= #flyway.ignore-failed-future-migration= #flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.flyway.locations=classpath:db/migration # locations of migrations scriptsflyway.out-of-order= #flyway.password= # JDBC password if you want Flyway to create its own DataSourceflyway.placeholder-prefix= #flyway.placeholder-replacement= #flyway.placeholder-suffix= #flyway.placeholders.*= #flyway.schemas= # schemas to updateflyway.sql-migration-prefix=V #flyway.sql-migration-separator= #flyway.sql-migration-suffix=.sql #flyway.table= #flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.flyway.user= # Login user of the database to migrate.flyway.validate-on-migrate= ## LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.liquibase.check-change-log-location=true # Check the change log location exists.liquibase.contexts= # Comma-separated list of runtime contexts to use.liquibase.default-schema= # Default database schema.liquibase.drop-first=false # Drop the database schema first.liquibase.enabled=true # Enable liquibase support.liquibase.labels= # Comma-separated list of runtime labels to use.liquibase.parameters.*= # Change log parameters.liquibase.password= # Login password of the database to migrate.liquibase.rollback-file= # File to which rollback SQL will be written when an update is performed.liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.liquibase.user= # Login user of the database to migrate.# COUCHBASE (CouchbaseProperties)spring.couchbase.bootstrap-hosts= # Couchbase nodes (host or IP address) to bootstrap from.spring.couchbase.bucket.name=default # Name of the bucket to connect to.spring.couchbase.bucket.password= # Password of the bucket.spring.couchbase.env.endpoints.key-value=1 # Number of sockets per node against the Key/value service.spring.couchbase.env.endpoints.query=1 # Number of sockets per node against the Query (N1QL) service.spring.couchbase.env.endpoints.view=1 # Number of sockets per node against the view service.spring.couchbase.env.ssl.enabled= # Enable SSL support. Enabled automatically if a "keyStore" is provided unless specified otherwise.spring.couchbase.env.ssl.key-store= # Path to the JVM key store that holds the certificates.spring.couchbase.env.ssl.key-store-password= # Password used to access the key store.spring.couchbase.env.timeouts.connect=5000 # Bucket connections timeout in milliseconds.spring.couchbase.env.timeouts.key-value=2500 # Blocking operations performed on a specific key timeout in milliseconds.spring.couchbase.env.timeouts.query=7500 # N1QL query operations timeout in milliseconds.spring.couchbase.env.timeouts.socket-connect=1000 # Socket connect connections timeout in milliseconds.spring.couchbase.env.timeouts.view=7500 # Regular and geospatial view operations timeout in milliseconds.# DAO (PersistenceExceptionTranslationAutoConfiguration)spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.# CASSANDRA (CassandraProperties)spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.spring.data.cassandra.compression=none # Compression supported by the Cassandra binary protocol.spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.spring.data.cassandra.consistency-level= # Queries consistency level.spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.spring.data.cassandra.fetch-size= # Queries default fetch size.spring.data.cassandra.keyspace-name= # Keyspace name to use.spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.spring.data.cassandra.port= # Port of the Cassandra server.spring.data.cassandra.password= # Login password of the server.spring.data.cassandra.read-timeout-millis= # Socket option: read time out.spring.data.cassandra.reconnection-policy= # Reconnection policy class.spring.data.cassandra.retry-policy= # Class name of the retry policy.spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.spring.data.cassandra.schema-action=none # Schema action to take at startup.spring.data.cassandra.ssl=false # Enable SSL support.spring.data.cassandra.username= # Login user of the server.# DATA COUCHBASE (CouchbaseDataProperties)spring.data.couchbase.auto-index=false # Automatically create views and indexes.spring.data.couchbase.consistency=read-your-own-writes # Consistency to apply by default on generated queries.spring.data.couchbase.repositories.enabled=true # Enable Couchbase repositories.# ELASTICSEARCH (ElasticsearchProperties)spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.# DATA LDAPspring.data.ldap.repositories.enabled=true # Enable LDAP repositories.# MONGODB (MongoProperties)spring.data.mongodb.authentication-database= # Authentication database name.spring.data.mongodb.database=test # Database name.spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database= # GridFS database name.spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.# DATA REDISspring.data.redis.repositories.enabled=true # Enable Redis repositories.# NEO4J (Neo4jProperties)spring.data.neo4j.compiler= # Compiler to use.spring.data.neo4j.embedded.enabled=true # Enable embedded mode if the embedded driver is available.spring.data.neo4j.open-in-view=false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.spring.data.neo4j.password= # Login password of the server.spring.data.neo4j.repositories.enabled=true # Enable Neo4j repositories.spring.data.neo4j.uri= # URI used by the driver. Auto-detected by default.spring.data.neo4j.username= # Login user of the server.# DATA REST (RepositoryRestProperties)spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.spring.data.rest.default-page-size= # Default size of pages.spring.data.rest.detection-strategy=default # Strategy to use to determine which repositories get exposed.spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.spring.data.rest.max-page-size= # Maximum size of pages.spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.spring.data.rest.return-body-on-create= # Return a response body after creating an entity.spring.data.rest.return-body-on-update= # Return a response body after updating an entity.spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.# SOLR (SolrProperties)spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if "zk-host" is set.spring.data.solr.repositories.enabled=true # Enable Solr repositories.spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.spring.datasource.data= # Data (DML) script resource references.spring.datasource.data-username= # User of the database to execute DML scripts (if different).spring.datasource.data-password= # Password of the database to execute DML scripts (if different).spring.datasource.dbcp2.*= # Commons DBCP2 specific settingsspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.generate-unique-name=false # Generate a random datasource name.spring.datasource.hikari.*= # Hikari specific settingsspring.datasource.initialize=true # Populate the database using 'data.sql'.spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.spring.datasource.name=testdb # Name of the datasource.spring.datasource.password= # Login password of the database.spring.datasource.platform=all # Platform to use in the schema resource (schema-$&#123;platform&#125;.sql).spring.datasource.schema= # Schema (DDL) script resource references.spring.datasource.schema-username= # User of the database to execute DDL scripts (if different).spring.datasource.schema-password= # Password of the database to execute DDL scripts (if different).spring.datasource.separator=; # Statement separator in SQL initialization scripts.spring.datasource.sql-script-encoding= # SQL scripts encoding.spring.datasource.tomcat.*= # Tomcat datasource specific settingsspring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.spring.datasource.url= # JDBC url of the database.spring.datasource.username=# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.connection-timeout=3000 # Connection timeout in milliseconds.spring.elasticsearch.jest.multi-threaded=true # Enable connection requests from multiple execution threads.spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3000 # Read timeout in milliseconds.spring.elasticsearch.jest.uris=http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.spring.elasticsearch.jest.username= # Login user.# H2 Web Console (H2ConsoleProperties)spring.h2.console.enabled=false # Enable the console.spring.h2.console.path=/h2-console # Path at which the console will be available.spring.h2.console.settings.trace=false # Enable trace output.spring.h2.console.settings.web-allow-others=false # Enable remote access.# JOOQ (JooqAutoConfiguration)spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.data.jpa.repositories.enabled=true # Enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the "databasePlatform" property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the "Database" enum.spring.jpa.generate-ddl=false # Initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto" property. Default to "create-drop" when using an embedded database, "none" otherwise.spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.naming.strategy= # Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate 5.spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Enable logging of SQL statements.# JTA (JtaAutoConfiguration)spring.jta.enabled=true # Enable JTA support.spring.jta.log-dir= # Transaction logs directory.spring.jta.transaction-manager-id= # Transaction manager unique identifier.# ATOMIKOS (AtomikosProperties)spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool's maintenance thread.spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.atomikos.properties.checkpoint-interval=500 # Interval between checkpoints.spring.jta.atomikos.properties.console-file-count=1 # Number of debug logs files that can be created.spring.jta.atomikos.properties.console-file-limit=-1 # How many bytes can be stored at most in debug logs files.spring.jta.atomikos.properties.console-file-name=tm.out # Debug logs file name.spring.jta.atomikos.properties.console-log-level=warn # Console log level.spring.jta.atomikos.properties.default-jta-timeout=10000 # Default timeout for JTA transactions.spring.jta.atomikos.properties.enable-logging=true # Enable disk logging.spring.jta.atomikos.properties.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.spring.jta.atomikos.properties.log-base-dir= # Directory in which the log files should be stored.spring.jta.atomikos.properties.log-base-name=tmlog # Transactions log file base name.spring.jta.atomikos.properties.max-actives=50 # Maximum number of active transactions.spring.jta.atomikos.properties.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.spring.jta.atomikos.properties.output-dir= # Directory in which to store the debug log files.spring.jta.atomikos.properties.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.spring.jta.atomikos.properties.service= # Transaction manager implementation that should be started.spring.jta.atomikos.properties.threaded-two-phase-commit=true # Use different (and concurrent) threads for two-phase commit on the participating resources.spring.jta.atomikos.properties.transaction-manager-unique-name= # Transaction manager's unique name.# BITRONIXspring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.spring.jta.bitronix.connectionfactory.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.spring.jta.bitronix.datasource.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.properties.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.spring.jta.bitronix.properties.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.spring.jta.bitronix.properties.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.spring.jta.bitronix.properties.current-node-only-recovery=true # Recover only the current node.spring.jta.bitronix.properties.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.spring.jta.bitronix.properties.default-transaction-timeout=60 # Default transaction timeout in seconds.spring.jta.bitronix.properties.disable-jmx=false # Enable JMX support.spring.jta.bitronix.properties.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.spring.jta.bitronix.properties.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.spring.jta.bitronix.properties.force-batching-enabled=true # Set if disk forces are batched.spring.jta.bitronix.properties.forced-write-enabled=true # Set if logs are forced to disk.spring.jta.bitronix.properties.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.spring.jta.bitronix.properties.jndi-user-transaction-name= # JNDI name of the UserTransaction.spring.jta.bitronix.properties.journal=disk # Name of the journal. Can be 'disk', 'null' or a class name.spring.jta.bitronix.properties.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.spring.jta.bitronix.properties.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.spring.jta.bitronix.properties.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.spring.jta.bitronix.properties.resource-configuration-filename= # ResourceLoader configuration file name.spring.jta.bitronix.properties.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine's IP address.spring.jta.bitronix.properties.skip-corrupted-logs=false # Skip corrupted transactions log entries.spring.jta.bitronix.properties.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.# NARAYANA (NarayanaProperties)spring.jta.narayana.default-timeout=60 # Transaction timeout in seconds.spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.spring.jta.narayana.log-dir= # Transaction object store directory.spring.jta.narayana.one-phase-commit=true # Enable one phase commit optimisation.spring.jta.narayana.periodic-recovery-period=120 # Interval in which periodic recovery scans are performed in seconds.spring.jta.narayana.recovery-backoff-period=10 # Back off period between first and second phases of the recovery scan in seconds.spring.jta.narayana.recovery-db-pass= # Database password to be used by recovery manager.spring.jta.narayana.recovery-db-user= # Database username to be used by recovery manager.spring.jta.narayana.recovery-jms-pass= # JMS password to be used by recovery manager.spring.jta.narayana.recovery-jms-user= # JMS username to be used by recovery manager.spring.jta.narayana.recovery-modules= # Comma-separated list of recovery modules.spring.jta.narayana.transaction-manager-id=1 # Unique transaction manager id.spring.jta.narayana.xa-resource-orphan-filters= # Comma-separated list of orphan filters.# EMBEDDED MONGODB (EmbeddedMongoProperties)spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.spring.mongodb.embedded.storage.database-dir= # Directory used for data storage.spring.mongodb.embedded.storage.oplog-size= # Maximum size of the oplog in megabytes.spring.mongodb.embedded.storage.repl-set-name= # Name of the replica set.spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.# REDIS (RedisProperties)spring.redis.cluster.max-redirects= # Maximum number of redirects to follow when executing commands across the cluster.spring.redis.cluster.nodes= # Comma-separated list of "host:port" pairs to bootstrap from.spring.redis.database=0 # Database index used by the connection factory.spring.redis.url= # Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.ssl=false # Enable SSL support.spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.spring.redis.pool.max-idle=8 # Max number of "idle" connections in the pool. Use a negative value to indicate an unlimited number of idle connections.spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.spring.redis.port=6379 # Redis server port.spring.redis.sentinel.master= # Name of Redis server.spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.spring.redis.timeout=0 # Connection timeout in milliseconds.# TRANSACTION (TransactionProperties)spring.transaction.default-timeout= # Default transaction timeout in seconds.spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.# ----------------------------------------# INTEGRATION PROPERTIES# ----------------------------------------# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default. For instance `tcp://localhost:61616`spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.spring.activemq.password= # Login password of the broker.spring.activemq.user= # Login user of the broker.spring.activemq.packages.trust-all=false # Trust all packages.spring.activemq.packages.trusted= # Comma-separated list of specific packages to trust (when not trusting all packages).spring.activemq.pool.configuration.*= # See PooledConnectionFactory.spring.activemq.pool.enabled=false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.spring.activemq.pool.expiry-timeout=0 # Connection expiration timeout in milliseconds.spring.activemq.pool.idle-timeout=30000 # Connection idle timeout in milliseconds.spring.activemq.pool.max-connections=1 # Maximum number of pooled connections.# ARTEMIS (ArtemisProperties)spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.spring.artemis.embedded.persistent=false # Enable persistent store.spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.spring.artemis.host=localhost # Artemis broker host.spring.artemis.mode= # Artemis deployment mode, auto-detected by default.spring.artemis.password= # Login password of the broker.spring.artemis.port=61616 # Artemis broker port.spring.artemis.user= # Login user of the broker.# SPRING BATCH (BatchProperties)spring.batch.initializer.enabled= # Create the required batch tables on startup if necessary. Enabled automatically if no custom table prefix is set or if a custom schema is configured.spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.# JMS (JmsProperties)spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.spring.jms.listener.auto-startup=true # Start the container automatically on startup.spring.jms.listener.concurrency= # Minimum number of concurrent consumers.spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.spring.jms.template.default-destination= # Default destination to use on send/receive operations that do not have a destination parameter.spring.jms.template.delivery-delay= # Delivery delay to use for send calls in milliseconds.spring.jms.template.delivery-mode= # Delivery mode. Enable QoS when set.spring.jms.template.priority= # Priority of a message when sending. Enable QoS when set.spring.jms.template.qos-enabled= # Enable explicit QoS when sending a message.spring.jms.template.receive-timeout= # Timeout to use for receive calls in milliseconds.spring.jms.template.time-to-live= # Time-to-live of a message when sending in milliseconds. Enable QoS when set.# APACHE KAFKA (KafkaProperties)spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.consumer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.enable-auto-commit= # If true the consumer's offset will be periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch.min.bytes".spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request in bytes.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group this consumer belongs to.spring.kafka.consumer.heartbeat-interval= # Expected time in milliseconds between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".spring.kafka.listener.ack-mode= # Listener AckMode; see the spring-kafka documentation.spring.kafka.listener.ack-time= # Time in milliseconds between offset commits when ackMode is "TIME" or "COUNT_TIME".spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.poll-timeout= # Timeout in milliseconds to use when polling the consumer.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Number of records to batch before sending.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.producer.buffer-memory= # Total bytes of memory the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.keystore-location= # Location of the key store file.spring.kafka.ssl.keystore-password= # Store password for the key store file.spring.kafka.ssl.truststore-location= # Location of the trust store file.spring.kafka.ssl.truststore-password= # Store password for the trust store file.spring.kafka.template.default-topic= # Default topic to which messages will be sent.# RABBIT (RabbitProperties)spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect.spring.rabbitmq.cache.channel.checkout-timeout= # Number of milliseconds to wait to obtain a channel if the cache size has been reached.spring.rabbitmq.cache.channel.size= # Number of channels to retain in the cache.spring.rabbitmq.cache.connection.mode=channel # Connection factory cache mode.spring.rabbitmq.cache.connection.size= # Number of connections to cache.spring.rabbitmq.connection-timeout= # Connection timeout, in milliseconds; zero for infinite.spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.spring.rabbitmq.host=localhost # RabbitMQ host.spring.rabbitmq.listener.acknowledge-mode= # Acknowledge mode of container.spring.rabbitmq.listener.auto-startup=true # Start the container automatically on startup.spring.rabbitmq.listener.concurrency= # Minimum number of consumers.spring.rabbitmq.listener.default-requeue-rejected= # Whether or not to requeue delivery failures; default `true`.spring.rabbitmq.listener.idle-event-interval= # How often idle container events should be published in milliseconds.spring.rabbitmq.listener.max-concurrency= # Maximum number of consumers.spring.rabbitmq.listener.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).spring.rabbitmq.listener.retry.enabled=false # Whether or not publishing retries are enabled.spring.rabbitmq.listener.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message.spring.rabbitmq.listener.retry.max-attempts=3 # Maximum number of attempts to deliver a message.spring.rabbitmq.listener.retry.max-interval=10000 # Maximum interval between attempts.spring.rabbitmq.listener.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval.spring.rabbitmq.listener.retry.stateless=true # Whether or not retry is stateless or stateful.spring.rabbitmq.listener.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.spring.rabbitmq.password= # Login to authenticate against the broker.spring.rabbitmq.port=5672 # RabbitMQ port.spring.rabbitmq.publisher-confirms=false # Enable publisher confirms.spring.rabbitmq.publisher-returns=false # Enable publisher returns.spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.spring.rabbitmq.ssl.enabled=false # Enable SSL support.spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.spring.rabbitmq.template.mandatory=false # Enable mandatory messages.spring.rabbitmq.template.receive-timeout=0 # Timeout for `receive()` methods.spring.rabbitmq.template.reply-timeout=5000 # Timeout for `sendAndReceive()` methods.spring.rabbitmq.template.retry.enabled=false # Set to true to enable retries in the `RabbitTemplate`.spring.rabbitmq.template.retry.initial-interval=1000 # Interval between the first and second attempt to publish a message.spring.rabbitmq.template.retry.max-attempts=3 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.max-interval=10000 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.multiplier=1.0 # A multiplier to apply to the previous publishing retry interval.spring.rabbitmq.username= # Login user to authenticate to the broker.spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# ENDPOINTS (AbstractEndpoint subclasses)endpoints.enabled=true # Enable endpoints.endpoints.sensitive= # Default endpoint sensitive setting.endpoints.actuator.enabled=true # Enable the endpoint.endpoints.actuator.path= # Endpoint URL path.endpoints.actuator.sensitive=false # Enable security on the endpoint.endpoints.auditevents.enabled= # Enable the endpoint.endpoints.auditevents.path= # Endpoint path.endpoints.auditevents.sensitive=false # Enable security on the endpoint.endpoints.autoconfig.enabled= # Enable the endpoint.endpoints.autoconfig.id= # Endpoint identifier.endpoints.autoconfig.path= # Endpoint path.endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.beans.enabled= # Enable the endpoint.endpoints.beans.id= # Endpoint identifier.endpoints.beans.path= # Endpoint path.endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.configprops.enabled= # Enable the endpoint.endpoints.configprops.id= # Endpoint identifier.endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.configprops.path= # Endpoint path.endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.docs.curies.enabled=false # Enable the curie generation.endpoints.docs.enabled=true # Enable actuator docs endpoint.endpoints.docs.path=/docs #endpoints.docs.sensitive=false #endpoints.dump.enabled= # Enable the endpoint.endpoints.dump.id= # Endpoint identifier.endpoints.dump.path= # Endpoint path.endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.env.enabled= # Enable the endpoint.endpoints.env.id= # Endpoint identifier.endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.env.path= # Endpoint path.endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.flyway.enabled= # Enable the endpoint.endpoints.flyway.id= # Endpoint identifier.endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.enabled= # Enable the endpoint.endpoints.health.id= # Endpoint identifier.endpoints.health.mapping.*= # Mapping of health statuses to HttpStatus codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).endpoints.health.path= # Endpoint path.endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.endpoints.heapdump.enabled= # Enable the endpoint.endpoints.heapdump.path= # Endpoint path.endpoints.heapdump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.hypermedia.enabled=false # Enable hypermedia support for endpoints.endpoints.info.enabled= # Enable the endpoint.endpoints.info.id= # Endpoint identifier.endpoints.info.path= # Endpoint path.endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.jolokia.enabled=true # Enable Jolokia endpoint.endpoints.jolokia.path=/jolokia # Endpoint URL path.endpoints.jolokia.sensitive=true # Enable security on the endpoint.endpoints.liquibase.enabled= # Enable the endpoint.endpoints.liquibase.id= # Endpoint identifier.endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.logfile.enabled=true # Enable the endpoint.endpoints.logfile.external-file= # External Logfile to be accessed.endpoints.logfile.path=/logfile # Endpoint URL path.endpoints.logfile.sensitive=true # Enable security on the endpoint.endpoints.loggers.enabled=true # Enable the endpoint.endpoints.loggers.id= # Endpoint identifier.endpoints.loggers.path=/logfile # Endpoint path.endpoints.loggers.sensitive=true # Mark if the endpoint exposes sensitive information.endpoints.mappings.enabled= # Enable the endpoint.endpoints.mappings.id= # Endpoint identifier.endpoints.mappings.path= # Endpoint path.endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.metrics.enabled= # Enable the endpoint.endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.endpoints.metrics.filter.gauge-submissions=merged # Http filter gauge submissions (merged, per-http-method)endpoints.metrics.filter.counter-submissions=merged # Http filter counter submissions (merged, per-http-method)endpoints.metrics.id= # Endpoint identifier.endpoints.metrics.path= # Endpoint path.endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.shutdown.enabled= # Enable the endpoint.endpoints.shutdown.id= # Endpoint identifier.endpoints.shutdown.path= # Endpoint path.endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.trace.enabled= # Enable the endpoint.endpoints.trace.id= # Endpoint identifier.endpoints.trace.path= # Endpoint path.endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.# ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. '*' allows all headers.endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. '*' allows all methods.endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. '*' allows all origins. When not set, CORS support is disabled.endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.domain= # JMX domain name. Initialized with the value of 'spring.jmx.default-domain' if set.endpoints.jmx.enabled=true # Enable JMX export of all endpoints.endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.add-application-context-header=true # Add the "X-Application-Context" HTTP header in each response.management.address= # Network address that the management endpoints should bind to.management.context-path= # Management endpoint context-path. For instance `/actuator`management.cloudfoundry.enabled= # Enable extended Cloud Foundry actuator endpointsmanagement.cloudfoundry.skip-ssl-validation= # Skip SSL verification for Cloud Foundry actuator endpoint security callsmanagement.port= # Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.management.security.enabled=true # Enable security.management.security.roles=ACTUATOR # Comma-separated list of roles that can access the management endpoint.management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).management.ssl.ciphers= # Supported SSL ciphers. Requires a custom management.port.management.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store. Requires a custom management.port.management.ssl.enabled= # Enable SSL support. Requires a custom management.port.management.ssl.enabled-protocols= # Enabled SSL protocols. Requires a custom management.port.management.ssl.key-alias= # Alias that identifies the key in the key store. Requires a custom management.port.management.ssl.key-password= # Password used to access the key in the key store. Requires a custom management.port.management.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.management.ssl.key-store-password= # Password used to access the key store. Requires a custom management.port.management.ssl.key-store-provider= # Provider for the key store. Requires a custom management.port.management.ssl.key-store-type= # Type of the key store. Requires a custom management.port.management.ssl.protocol=TLS # SSL protocol to use. Requires a custom management.port.management.ssl.trust-store= # Trust store that holds SSL certificates. Requires a custom management.port.management.ssl.trust-store-password= # Password used to access the trust store. Requires a custom management.port.management.ssl.trust-store-provider= # Provider for the trust store. Requires a custom management.port.management.ssl.trust-store-type= # Type of the trust store. Requires a custom management.port.# HEALTH INDICATORSmanagement.health.db.enabled=true # Enable database health check.management.health.cassandra.enabled=true # Enable cassandra health check.management.health.couchbase.enabled=true # Enable couchbase health check.management.health.defaults.enabled=true # Enable default health indicators.management.health.diskspace.enabled=true # Enable disk space health check.management.health.diskspace.path= # Path used to compute the available disk space.management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.management.health.elasticsearch.enabled=true # Enable elasticsearch health check.management.health.elasticsearch.indices= # Comma-separated index names.management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.management.health.jms.enabled=true # Enable JMS health check.management.health.ldap.enabled=true # Enable LDAP health check.management.health.mail.enabled=true # Enable Mail health check.management.health.mongo.enabled=true # Enable MongoDB health check.management.health.rabbit.enabled=true # Enable RabbitMQ health check.management.health.redis.enabled=true # Enable Redis health check.management.health.solr.enabled=true # Enable Solr health check.management.health.status.order=DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.# INFO CONTRIBUTORS (InfoContributorProperties)management.info.build.enabled=true # Enable build info.management.info.defaults.enabled=true # Enable default info contributors.management.info.env.enabled=true # Enable environment info.management.info.git.enabled=true # Enable git info.management.info.git.mode=simple # Mode to use to expose git information.# REMOTE SHELL (ShellProperties)management.shell.auth.type=simple # Authentication type. Auto-detected according to the environment.management.shell.auth.jaas.domain=my-domain # JAAS domain.management.shell.auth.key.path= # Path to the authentication key. This should point to a valid ".pem" file.management.shell.auth.simple.user.name=user # Login user.management.shell.auth.simple.user.password= # Login password.management.shell.auth.spring.roles=ACTUATOR # Comma-separated list of required roles to login to the CRaSH console.management.shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.management.shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).management.shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.management.shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.management.shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.management.shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.management.shell.ssh.enabled=true # Enable CRaSH SSH support.management.shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.management.shell.ssh.key-path= # Path to the SSH server key.management.shell.ssh.port=2000 # SSH port.management.shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is available.management.shell.telnet.port=5000 # Telnet port.# TRACING (TraceProperties)management.trace.include=request-headers,response-headers,cookies,errors # Items to be included in the trace.# METRICS EXPORT (MetricExportProperties)spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.spring.metrics.export.includes= # List of patterns for metric names to include.spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.# ----------------------------------------# DEVTOOLS PROPERTIES# ----------------------------------------# DEVTOOLS (DevToolsProperties)spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.spring.devtools.livereload.port=35729 # Server port.spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-paths= # Additional paths to watch for changes.spring.devtools.restart.enabled=true # Enable automatic restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.# REMOTE DEVTOOLS (RemoteDevToolsProperties)spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.spring.devtools.remote.debug.enabled=true # Enable remote debug support.spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.spring.devtools.remote.restart.enabled=true # Enable remote restart.spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.# ----------------------------------------# TESTING PROPERTIES# ----------------------------------------spring.test.database.replace=any # Type of existing DataSource to replace.spring.test.mockmvc.print=default # MVC Print option.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot工程结构推荐]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot.myproject.git Spring Boot框架本身并没有对工程结构有特别的要求，但是按照最佳实践的工程结构可以帮助我们减少可能会遇见的坑，尤其是Spring包扫描机制的存在，如果您使用最佳实践的工程结构，可以免去不少特殊的配置工作。 典型示例 root package结构：com.example.myproject 应用主类Application.java置于root package下，通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web | +- CustomerController.java | 创建： 项目结构： 工程构建在上述基础，构建项目：1234567891011121314151617181920212223242526272829Customer.javapackage com.example.myproject.domain;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Customer &#123; @Value("$&#123;com.example.myproject.customer.id&#125;") private String id; @Value("$&#123;com.example.myproject.customer.name&#125;") private String name; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920CustomerService.javapackage com.example.myproject.service;import com.example.myproject.domain.Customer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class CustomerService &#123; @Autowired private Customer customer; public void printCustomer() &#123; System.out.println(customer.getName()); &#125; public Customer getCustomer()&#123; return customer; &#125;&#125; 1234567891011121314151617181920212223242526CustomerController.javapackage com.example.myproject.web;import com.example.myproject.domain.Customer;import com.example.myproject.service.CustomerService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;/** * @author 34924 */@Controllerpublic class CustomerController &#123; @Autowired CustomerService customerService; @RequestMapping("/customer") public String customer(ModelMap map) &#123; Customer customer = customerService.getCustomer(); map.addAttribute("customer", customer); return "index"; &#125;&#125; 123456789101112index.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;customer.id&#125;"&gt;Hello World&lt;/h1&gt;&lt;h2 th:text="$&#123;customer.name&#125;"&gt;name&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234application.propertiescom.example.myproject.customer.id = 001com.example.myproject.customer.name = jl 运行项目，访问localhost:8080/customer 也可以test：1234567891011121314151617181920212223242526272829MyprojectApplicationTests.javapackage com.example.myproject;import com.example.myproject.service.CustomerService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class MyprojectApplicationTests &#123; @Autowired private CustomerService customerService; @Test public void contextLoads() &#123; &#125; @Test public void testCustomer() &#123; customerService.printCustomer(); System.out.println(customerService.getCustomer()); &#125;&#125; 输出：12jlCustomer&#123;id='001', name='jl'&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>工程</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot开发web应用]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_thymeleaf_demo 静态资源访问js,css,图片等文件，放在main/resources/static里。 页面放在main/resources/templates里。 配置文件内容可以添加在main/resources、application.properties里。 举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/D.jpg。如能显示图片，配置成功。 springboot提供默认配置的一些模版： Thymeleaf FreeMarker Velocity Groovy Mustache 使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。 Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。 示例：1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text="#&#123;msgs.headers.name&#125;"&gt;Name&lt;/td&gt; &lt;th th:text="#&#123;msgs.headers.price&#125;"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="prod : $&#123;allProducts&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Oranges&lt;/td&gt; &lt;td th:text="$&#123;#numbers.formatDecimal(prod.price,1,2)&#125;"&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。12345678910111213141516171819202122232425262728package com.example.demo.web;import com.example.demo.properties.BlobProperties;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;@Controllerpublic class HelloController &#123; @Resource(name = "blobProperties") private BlobProperties blobProperties; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125; @RequestMapping("/") public String index(ModelMap map) &#123; // 加入一个属性，用来在模板中读取 map.addAttribute("host", "http://www.baidu.com"); // return模板文件的名称，对应src/main/resources/templates/index.html return "index"; &#125;&#125; index.html页面：12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;host&#125;"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://blog.baidu.com，做到了不破坏HTML自身内容的数据逻辑分离。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 12345678910111213141516171819# Enable template caching.spring.thymeleaf.cache=true# Check that the templates location exists.spring.thymeleaf.check-template-location=true# Content-Type value.spring.thymeleaf.servlet.content-type=text/html# Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true# Template encoding.spring.thymeleaf.encoding=utf-8# Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names=# Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5# Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/# Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html#spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot热启动]]></title>
    <url>%2F2018%2F11%2F20%2Fspringboot%E7%83%AD%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在pom.xml中的dependencies中添加：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 改build： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 之后reimport，成功之后进行如下设置： 打开idea ，File-&gt;Settings-&gt; Build-Execution-Deployment -&gt; Compiler勾选 Build Project Automatically. 之后按 Shift+Ctrl+A 将看到弹窗 Enter Action or option name，输入”registry”，双击第一项”Registry…” ，会弹出另一个窗口，寻找compiler.automake.allow.when.app.running并且勾选： 之后重启项目，在修改resources文件和java文件时会自动加载或者重启。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot：hello world]]></title>
    <url>%2F2018%2F11%2F19%2Fspringboot%EF%BC%9Ahello-world%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/snjl/springboot_helloworld.git Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 快速入门主要目标是完成Spring Boot基础项目的构建，并且实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 使用Maven构建项目 通过SPRING INITIALIZR工具产生基础项目 访问：http://start.spring.io/ 选择构建工具Maven Project、Spring Boot版本1.3.2以及一些工程基本信息，可参考下图所示点击Generate Project下载项目压缩包 解压项目包，并用IDE以Maven项目导入 菜单中选择File–&gt;New–&gt;Project from Existing Sources 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 选择Java SDK的时候请选择Java 7以上的版本 项目结构 通过上面步骤完成了基础项目的创建，如上图所示，Spring Boot的基础结构共三个文件（具体路径根据用户生成项目时填写的Group所有差异）： src/main/java下的程序入口：Chapter1Application src/main/resources下的配置文件：application.properties src/test/下的测试入口：Chapter1ApplicationTests 生成的Chapter1Application和Chapter1ApplicationTests类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。 其中，@SpringBootApplication的这个注解是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 引入Web模块引入Web模块，需在pom.xml中添加spring-boot-starter-web模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写HelloWorld服务 创建package命名为com.example.demo.web（根据实际情况修改） 创建HelloController类，内容如下 123456789101112package com.exmaple.demo.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 启动主程序（可以在命令行中使用mvn spring-boot:run，或者通过idea启动），打开浏览器访问http://localhost:8080/hello，可以看到页面输出Hello World 编写单元测试用例打开的src/test/下的测试入口Chapter1ApplicationTests类。下面编写一个简单的单元测试来模拟http请求，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.exmaple.demo;import com.exmaple.demo.web.HelloController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.hamcrest.Matchers.equalTo;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)@WebAppConfigurationpublic class Chapter1ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 使用MockServletContext来构建一个空的WebApplicationContext，这样我们创建的HelloController就可以在@Before函数中创建并传递到MockMvcBuilders.standaloneSetup（）函数中。 其中的SpringBootTest注解，原来为SpringApplicationConfiguration，现在已弃用。如果在判断equalTo时判断不一致，会报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243java.lang.AssertionError: Response contentExpected: "Hello World1" but: was "Hello World"Expected :Hello World1Actual :Hello World &lt;Click to see difference&gt; at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) at org.springframework.test.web.servlet.result.ContentResultMatchers.lambda$string$3(ContentResultMatchers.java:130) at org.springframework.test.web.servlet.MockMvc$1.andExpect(MockMvc.java:195) at com.exmaple.demo.Chapter1ApplicationTests.getHello(Chapter1ApplicationTests.java:36) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 打包在 POM 文件添加插件： 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 当运行“mvn package”进行打包时，会打包成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行。 开箱即用模块Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。下面列举一些常用的模块。 spring-boot-starter-logging ：使用 Spring Boot 默认的日志框架 Logback。 spring-boot-starter-log4j ：添加 Log4j 的支持。 spring-boot-starter-web ：支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 spring-boot-starter-tomcat ：使用 Spring Boot 默认的 Tomcat 作为应用服务器。 spring-boot-starter-jetty ：使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-test ：包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-aop ：包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 spring-boot-starter-security ：包含 spring-security。 spring-boot-starter-jdbc ：支持使用 JDBC 访问数据库。 spring-boot-starter-redis ：支持使用 Redis。 spring-boot-starter-data-mongodb ：包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-jpa ：包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-amqp ：通过 spring-rabbit 支持 AMQP。 spring-boot-starter-actuator ： 添加适用于生产环境的功能，如性能指标和监测等功能。 Java Config 自动配置Spring Boot 推荐采用基于 Java Config 的配置方式，而不是传统的 XML。例如，@Configuration、@Bean、@EnableAutoConfiguration、@CompomentScan、@PropertySource、@Repository、@Service、@RestController等。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库处理tips]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86tips%2F</url>
    <content type="text"><![CDATA[1.mysql 开放，关闭 远程授权默认安装mysql是关闭远程连接的 这样也有助于系统的安全 但是有时候需要开启下远程连接方便操作 开启连接 mysql -uroot -p 进入mysql 输入密码1GRANT ALL PRIVILEGES ON * . * TO ‘root’@&apos;%’ IDENTIFIED BY ‘你的mysql密码’ 1WITH GRANT OPTION MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 1MAX_UPDATES_PER_HOUR 0 ; 1flush privileges; 输入这两个命令即可开启mysql远程连接 关闭授权1234REVOKE ALL PRIVILEGES ON *.* FROM root@”%”;USE mysql;DELETE FROM user WHERE User=”root” and Host=”%”;FLUSH PRIVILEGES; 1234567891011121314151617mysql&gt; DELETE FROM `user` WHERE Host='10.155.123.55' AND User='kaka';Query OK, 1 row affected (0.00 sec) mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT Host,User,Password FROM `user`;+----------------+------+-------------------------------------------+| Host | User | Password |+----------------+------+-------------------------------------------+| localhost | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || tony\_ts\_tian | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || 127.0.0.1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || ::1 | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 || % | root | *71ABCA8B06D46066CEF8062A75256E66243D0FC8 |+----------------+------+-------------------------------------------+5 rows in set (0.00 sec) 2.删除重复数据，只留下唯一不重复1.先多建立一列 temp，用来合并meetingId和speakerId,用“-”连接，之后就判断这一列是否相同。1234567891011121314151617ALTER TABLE cekasp_meeting_speaker ADD temp VARCHAR(20) NULL;update cekasp_meeting_speaker set temp = concat(meetingId, '-', speakerId);delete from cekasp_meeting_speaker where temp in (SELECT * from (SELECT b.temp from cekasp_meeting_speaker b GROUP BY b.temp HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg);ALTER TABLE cekasp_meeting_speaker DROP temp;``` 2.或者直接以meetingId和speakerId作为查询```sqldelete from cekasp_meeting_speaker where (meetingId,speakerId) in (SELECT * from (SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1)ggg)and id not in (select * from( (select min(c.id) from cekasp_meeting_speaker c GROUP BY c.meetingId,c.speakerId HAVING count(*) &gt; 1) ) ggggggg); 问题：delete/update里，有in的查询语句时，要使用临时表才能进行删除： 原本的1SELECT b.meetingId,b.speakerId from cekasp_meeting_speaker b GROUP BY b.meetingId,b.speakerId HAVING count(*) &gt; 1 应该要使用1select * from ... as NAME 包起来，作为一个临时表。 3.两张表表结构一样，将一张表中数据插入另一张表1insert into table1 (SELECT * from table2 WHERE id not in (SELECT id from table1)) 4.查询某张表的信息1select * from information_schema.COLUMNS where TABLE_SCHEMA = (select database()) and TABLE_NAME="paper";]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis简单测试]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[0.准备工具因为配置文件都是读取相同的，所以可以进行工厂类封装。 12345678910111213141516171819202122232425262728package org.fkit.factory;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;public class FKSqlSessionFactory &#123; private static SqlSessionFactory sqlSessionFactory = null; static &#123; try &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125; public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125;&#125; 1.简单的select，insert，update，delete测试在UserMapper.xml中配置：1234567891011121314&lt;insert id="saveUser" parameterType="user" useGeneratedKeys="true"&gt; INSERT INTO tb_user(name, sex, age) VALUES (#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;select id="selectUser" parameterType="int" resultType="user"&gt; SELECT * from tb_user where id = #&#123;id&#125;&lt;/select&gt;&lt;update id="modifyUser" parameterType="user" &gt; UPDATE tb_user set name = #&#123;name&#125;, sex = #&#123;sex&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;&lt;/update&gt;&lt;delete id="removeUser" parameterType="int"&gt; DELETE from tb_user where id=#&#123;id&#125;&lt;/delete&gt; 注：均包含在中。 可以看到，在saveUser和modifyUser中，都是传入的User对象，而在selectUser和removeUser传入的是int值，所以在测试时，需要进行对应。resultType是返回类型，返回User类型，需要使用User user = …获取到该对象，默认返回的是int类型（好像是。。忘记了）。 分别对其进行测试及结果：123456789101112131415//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("jack", "男", 22); sqlSession.insert("org.fkit.mapper.UserMapper.saveUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: INSERT INTO tb_user(name, sex, age) VALUES (?,?,?) DEBUG [main] - ==&gt; Parameters: jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213141516//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); System.out.println(user.getName()); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=1, name='hello?', sex='g', age=11&#125; 12345678910111213141516171819//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = sqlSession.selectOne("org.fkit.mapper.UserMapper.selectUser", 1); user.setName("hello?"); sqlSession.update("org.fkit.mapper.UserMapper.modifyUser", user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: UPDATE tb_user set name = ?, sex = ?, age = ? WHERE id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), g(String), 11(Integer), 1(Integer)DEBUG [main] - &lt;== Updates: 1 12345678910111213//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); sqlSession.selectOne("org.fkit.mapper.UserMapper.removeUser", 3); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: DELETE from tb_user where id=? DEBUG [main] - ==&gt; Parameters: 3(Integer) 2.测试ResultMapsresultMap是mybatis中最重要最强大的元素，它的作用是告诉mybatis将从结果集中取出的数据转化成开发者所需要的对象。123456&lt;select id="selectUsersToMap" resultType="map"&gt; SELECT * from tb_user&lt;/select&gt;&lt;select id="selectUsers" resultType="org.fkit.domain.User"&gt; SELECT * from tb_user&lt;/select&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//SelectMapTest.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.User;import org.fkit.factory.FKSqlSessionFactory;import java.util.List;import java.util.Map;public class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取map对象集，每个user映射为一个map List&lt;Map&lt;String, Object&gt;&gt; list = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsersToMap"); for (Map&lt;String, Object&gt; row : list) &#123; System.out.println(row); &#125;// 获取user对象集 List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers"); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12&#123;sex=g, name=hello?, id=1, age=11&#125;&#123;sex=男, name=gg, id=4, age=26&#125;&#123;sex=男, name=gg, id=5, age=26&#125;&#123;sex=男, name=gg, id=6, age=26&#125;&#123;sex=男, name=gg, id=7, age=26&#125;&#123;sex=男, name=gg, id=8, age=26&#125;&#123;sex=男, name=gg, id=9, age=26&#125;&#123;sex=男, name=gg, id=10, age=26&#125;&#123;sex=男, name=gg, id=11, age=26&#125;&#123;sex=男, name=gg, id=12, age=26&#125;&#123;sex=男, name=jack, id=13, age=22&#125;&#123;sex=男, name=jack, id=14, age=22&#125;DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 12User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='gg', sex='男', age=26&#125;User&#123;id=13, name='jack', sex='男', age=22&#125;User&#123;id=14, name='jack', sex='男', age=22&#125; 查询语句返回的每一条数据都被封装成了一个Map集合，列名作为Map集合的key，而列的值作为Map的value。 虽然数据被封装成Map集合返回，但是Map集合并不能很好描述一个领域的模型，如果像后一个测试一样，使用POJO类来作为领域模型描述数据，会更加准确。 比较特殊的情况：查询到的数据的列和需要返回的对象（User）的属性不一致，则mybatis不会自动赋值，可以使用resultMap进行处理。 在数据库中创建一个tb_user2表，并且插入一定数据：12345678CREATE TABLE tb_user2( user_id INT AUTO_INCREMENT PRIMARY KEY, user_name VARCHAR(18) NULL, user_sex CHAR(2) NULL, user_age INT NULL) User映射表使用原来的User.java。在UserMapper.xml中添加：12345678910&lt;resultMap id="userResultMap" type="org.fkit.domain.User"&gt; &lt;id property="id" column="user_id"/&gt; &lt;!--column对应数据库中的属性--&gt; &lt;result property="name" column="user_name"/&gt; &lt;result property="sex" column="user_sex"/&gt; &lt;result property="age" column="user_age"/&gt;&lt;/resultMap&gt;&lt;select id="selectUsers2" resultMap="userResultMap"&gt; SELECT * from tb_user2&lt;/select&gt; 测试：1234567891011121314151617//ResultMapTest.javapublic class ResultMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;User&gt; users = sqlSession.selectList("org.fkit.mapper.UserMapper.selectUsers2"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_user2 DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 2User&#123;id=1, name='qq1', sex='q', age=12&#125;User&#123;id=2, name='qq2', sex='b', age=13&#125; （待补充 3.多表查询两个表：123456789101112131415161718192021CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id)) 插入2个班级，4个学生，其中每2个学生对应一个班级。建立pojo类：1234567891011121314public class Clazz &#123; private Integer id; private String code; //setter,getter&#125;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz; //getter,setter UserMapper.xml映射：123456789101112&lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" column="clazz_id" javaType="org.fkit.domain.Clazz" select="selectClazzWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectClazzWithId" resultType="org.fkit.domain.Clazz"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125;&lt;/select&gt; 测试：123456789101112131415161718192021222324252627//SelectStudentTest.javapublic class SelectStudentTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Student&gt; students = sqlSession.selectList("org.fkit.mapper.UserMapper.selectStudent"); for (Student student : students) &#123; System.out.println(student); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_student DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 1DEBUG [main] - &lt;== Total: 4Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=1, code='j1601'&#125;&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=Clazz&#123;id=2, code='j1602'&#125;&#125; 查询每个班级的学生： 修改clazz.java1234567891011121314public class Clazz &#123; private Integer id; private String code; private List&lt;Student&gt; students; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125;...&#125; UserMapper.xml添加：12345678910111213&lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="selectStudentWithId"/&gt;&lt;/resultMap&gt;&lt;select id="selectStudentWithId" resultType="org.fkit.domain.Student"&gt; SELECT * FROM tb_student where clazz_id = #&#123;id&#125;&lt;/select&gt;&lt;select id="selectClazz" resultMap="clazzResultMap"&gt; SELECT * from tb_clazz&lt;/select&gt; 测试：123456789101112131415161718192021222324252627282930313233//SelectClazzTest.javapublic class SelectClazzTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); List&lt;Clazz&gt; clazzes = sqlSession.selectList("org.fkit.mapper.UserMapper.selectClazz"); for (Clazz clazz : clazzes) &#123; System.out.println(clazz); List&lt;Student&gt; students = clazz.getStudents(); for (Student student : students) &#123; System.out.println(student); &#125; &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_clazz DEBUG [main] - ==&gt; Parameters: DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - ====&gt; Preparing: SELECT * FROM tb_student where clazz_id = ? DEBUG [main] - ====&gt; Parameters: 2(Integer)DEBUG [main] - &lt;==== Total: 2DEBUG [main] - &lt;== Total: 2Clazz&#123;id=1, code='j1601'&#125;Student&#123;id=1, name='jack', sex='男', age=22, clazz=null&#125;Student&#123;id=2, name='rose', sex='女', age=18, clazz=null&#125;Clazz&#123;id=2, code='j1602'&#125;Student&#123;id=3, name='tom', sex='男', age=25, clazz=null&#125;Student&#123;id=4, name='mary', sex='女', age=20, clazz=null&#125; 看到student没有clazz属性，应该是不能递归查询。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748CREATE TABLE tb_article( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, price DOUBLE NULL, remark VARCHAR(18) NULL, CONSTRAINT tb_article_id_uindex UNIQUE (id))CREATE TABLE tb_consumer( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(18) NULL, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, phone VARCHAR(18) NULL, address VARCHAR(18) NULL, CONSTRAINT tb_consumer_id_uindex UNIQUE (id))CREATE TABLE tb_order( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(32) NULL, total DOUBLE NULL, user_id INT NULL, CONSTRAINT tb_order_id_uindex UNIQUE (id), CONSTRAINT tb_order_tb_consumer_id_fk FOREIGN KEY (user_id) REFERENCES tb_consumer (id)) ENGINE = InnoDB;CREATE INDEX tb_order_tb_consumer_id_fk ON tb_order (user_id);CREATE TABLE tb_item( order_id INT NOT NULL, amount INT NULL, code VARCHAR(18) NULL, article_id INT NOT NULL, PRIMARY KEY (order_id, article_id)) ENGINE = InnoDB; 其中，consumer和order是一对多关系，一个顾客有多个订单；order和article是多对多的关系，中间表是item，一个订单可以有多个商品，一个商品也可以在多个订单上，所以是多对多关系。POJO类：123456789101112131415161718192021222324252627282930313233//TbConsumer.javapublic class TbConsumer &#123; private long id; private String username; private String loginname; private String password; private String phone; private String address; private List&lt;TbOrder&gt; tbOrders;//setter,getter//TbOrder.javapublic class TbOrder &#123; private long id; private String code; private double total; private long userId; private TbConsumer tbConsumer; private List&lt;TbArticle&gt; articleList;//setter,getter//TbArticle.javapublic class TbArticle &#123; private long id; private String name; private double price; private String remark; private List&lt;TbOrder&gt; tbOrders;//getter,setter 1.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//ConsumerMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ConsumerMapper"&gt; &lt;resultMap id="consumerResultMap" type="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="loginname" column="loginname"/&gt; &lt;result property="password" column="password"/&gt; &lt;result property="phone" column="phone"/&gt; &lt;result property="address" column="address"/&gt; &lt;collection property="tbOrders" javaType="arrayList" column="id" ofType="org.fkit.domain.TbOrder" fetchType="lazy" select="org.fkit.mapper.OrderMapper.selectOrderByConsumerId"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="total" column="total"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectConsumerById" parameterType="int" resultMap="consumerResultMap"&gt; SELECT * from tb_consumer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;//OrderMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.OrderMapper"&gt; &lt;resultMap id="orderResultMap" type="org.fkit.domain.TbOrder"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="total" property="total"/&gt; &lt;result column="code" property="code"/&gt; &lt;association property="tbConsumer" javaType="org.fkit.domain.TbConsumer"&gt; &lt;id property="id" column="id"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="loginname" property="loginname"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;/association&gt; &lt;collection property="articleList" javaType="ArrayList" column="oid" ofType="org.fkit.domain.TbArticle" select="org.fkit.mapper.ArticleMapper.selectArticleByOrderId" fetchType="lazy"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="price" property="price"/&gt; &lt;result property="remark" column="remark"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectOrderById" resultMap="orderResultMap" parameterType="int"&gt; SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectOrderByConsumerId" parameterType="int" resultType="org.fkit.domain.TbOrder"&gt; select * from tb_order where user_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt;//ArticleMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ArticleMapper"&gt; &lt;select id="selectArticleByOrderId" parameterType="int" resultType="org.fkit.domain.TbArticle"&gt; SELECT * from tb_article where id in (select article_id from tb_item where order_id = #&#123;id&#125;) &lt;/select&gt;&lt;/mapper&gt; 因为多表查询返回结果中tb_consumer中有id列，tb_order中也有id列，所以需要区分，例如使o.id as oid，resultMap中的column=”oid”就是指tb_order表中的id值。 相应Java类：12345678910111213public interface ConsumerMapper &#123; TbConsumer selectConsumerById(Integer id);&#125;public interface OrderMapper &#123; TbOrder selectOrderById(Integer id); TbOrder selectOrderByUserId(Integer id);&#125;public interface ArticleMapper &#123; TbArticle selectArticleByOrderId(Integer id);&#125; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ManyToManyTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); ManyToManyTest manyToManyTest = new ManyToManyTest(); manyToManyTest.testSelectUserById(sqlSession); manyToManyTest.testSelectOrderById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectUserById(SqlSession sqlSession) &#123; ConsumerMapper consumerMapper = sqlSession.getMapper(ConsumerMapper.class); TbConsumer tbConsumer = consumerMapper.selectConsumerById(1); System.out.println(tbConsumer); List&lt;TbOrder&gt; tbOrders = tbConsumer.getTbOrders(); for (TbOrder tbOrder : tbOrders) &#123; System.out.println(tbOrder); &#125; &#125; public void testSelectOrderById(SqlSession sqlSession) &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); TbOrder tbOrder = orderMapper.selectOrderById(2); System.out.println(tbOrder); TbConsumer tbConsumer = tbOrder.getTbConsumer(); System.out.println(tbConsumer); List&lt;TbArticle&gt; tbArticles = tbOrder.getArticleList(); for (TbArticle tbArticle : tbArticles) &#123; System.out.println("tbArticle:"); System.out.println(tbArticle); &#125; &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * from tb_consumer where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select * from tb_order where user_id = ?; DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=[TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;, TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;]&#125;TbOrder&#123;id=2, code='23624', total=1.0, userId=1, tbConsumer=null&#125;TbOrder&#123;id=3, code='12351', total=2.0, userId=1, tbConsumer=null&#125;DEBUG [main] - ==&gt; Preparing: SELECT u.* ,o.id as oid,code,total,user_id FROM tb_consumer u, tb_order o WHERE u.id = o.user_id and o.id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: SELECT * from tb_article where id in (select article_id from tb_item where order_id = ?) DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 2TbOrder&#123;id=1, code='23624', total=1.0, userId=0, tbConsumer=TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;&#125;TbConsumer&#123;id=1, username='peter', loginname='blue man', password='123', phone='123456', address='外星球', tbOrders=null&#125;tbArticle:TbArticle&#123;id=1, name='洗发水', price=23.3, remark='bilibili', tbOrders=null&#125;tbArticle:TbArticle&#123;id=2, name='java书', price=111.0, remark='blingbling', tbOrders=null&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_clazz( id INT AUTO_INCREMENT PRIMARY KEY, CODE VARCHAR(18) NULL, name VARCHAR(18) NULL, CONSTRAINT TB_CLAZZ_id_uindex UNIQUE (id))CREATE TABLE tb_student( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(18) NULL, sex CHAR(3) NULL, age INT NULL, clazz_id INT NULL, CONSTRAINT TB_STUDENT_id_uindex UNIQUE (id), CONSTRAINT TB_STUDENT_tb_clazz_id_fk FOREIGN KEY (clazz_id) REFERENCES tb_clazz (id))CREATE INDEX TB_STUDENT_tb_clazz_id_fk ON tb_student (clazz_id); 一个clazz对应多个student。 log4j.properties需要进行配置：1234567log4j.rootLogger=ERROR, stdout#log4j.logger.org.fkit.mapper.UserMapper=DEBUGlog4j.logger.org.fkit.mapper=DEBUGlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 在mybatis-config.xml中配置一下mapper和懒加载：12&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt; 配置pojo类：12345678910111213141516171819202122//Student.javapackage org.fkit.domain;public class Student &#123; private Integer id; private String name; private String sex; private Integer age; private Clazz clazz;//getter,setter//Clazz.javapackage org.fkit.domain;import java.util.List;public class Clazz &#123; private Integer id; private String code; private String name; private List&lt;Student&gt; students;//getter,setter 1.配置StudentMapper和ClazzMapper1234567891011121314151617181920212223242526//StudentMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.StudentMapper"&gt; &lt;select id="selectStudentById" parameterType="int" resultMap="studentResultMap"&gt; SELECT * from tb_clazz c,tb_student s where c.id = s.clazz_id and s.id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectStudentByClazzId" parameterType="int" resultMap="studentResultMap"&gt; select * from tb_student where clazz_id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="studentResultMap" type="org.fkit.domain.Student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="clazz" javaType="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678910//StudentMapper.javapackage org.fkit.mapper;import org.fkit.domain.Student;public interface StudentMapper &#123; Student selectStudentById(Integer id); Student selectStudentByClazzId(Integer id);&#125; 1234567891011121314151617181920212223//ClazzMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.ClazzMapper"&gt; &lt;select id="selectClazzById" parameterType="int" resultMap="clazzResultMap"&gt; SELECT * FROM tb_clazz where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="clazzResultMap" type="org.fkit.domain.Clazz"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="code" column="code"/&gt; &lt;result property="name" column="name"/&gt; &lt;collection property="students" javaType="ArrayList" column="id" ofType="org.fkit.domain.Student" select="org.fkit.mapper.StudentMapper.selectStudentByClazzId" fetchType="lazy"&gt; &lt;id property="studentId" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678//ClazzMapper.javapackage org.fkit.mapper;import org.fkit.domain.Clazz;public interface ClazzMapper &#123; Clazz selectClazzById(Integer id);&#125; 测试代码：1234567891011121314151617181920212223242526272829303132333435363738//OneToMany.javapackage org.fkit.test;import org.apache.ibatis.session.SqlSession;import org.fkit.domain.Clazz;import org.fkit.factory.FKSqlSessionFactory;import org.fkit.mapper.ClazzMapper;public class OneToMany &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); OneToMany oneToMany = new OneToMany(); oneToMany.testSelectClazzById(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectClazzById(SqlSession sqlSession) &#123; ClazzMapper clazzMapper = sqlSession.getMapper(ClazzMapper.class); Clazz clazz = clazzMapper.selectClazzById(1); System.out.println(clazz.getId() + " " + clazz.getCode()); System.out.println(clazz.getStudents()); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_clazz where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 11 j1601DEBUG [main] - ==&gt; Preparing: select * from tb_student where clazz_id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 2[Student&#123;id=1, name='jack', sex='男', age=22, clazz=Clazz&#123;id=1, code='null', name='jack', students=null&#125;&#125;, Student&#123;id=2, name='rose', sex='女', age=18, clazz=Clazz&#123;id=2, code='null', name='rose', students=null&#125;&#125;] 可以看出，懒加载会只加载需要使用的(PS:如果做接口，json传数据，则冷加载相当于失效，但是可以在pojo类上加上@JsonIgnoreProperties(“fieldname”)）。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对一]]></title>
    <url>%2F2018%2F11%2F14%2FMybatis%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[0.前期准备数据库配置：12345678910111213141516171819202122232425CREATE TABLE tb_card( id INT AUTO_INCREMENT PRIMARY KEY, code VARCHAR(18) NULL, CONSTRAINT tb_card_id_uindex UNIQUE (id))CREATE TABLE tb_person( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(18) NULL, sex VARCHAR(18) NULL, age INT NULL, card_id INT NULL, CONSTRAINT tb_person_id_uindex UNIQUE (id), CONSTRAINT tb_person_card_id_uindex UNIQUE (card_id), CONSTRAINT tb_person_tb_card_id_fk FOREIGN KEY (card_id) REFERENCES tb_card (id)) ENGINE = Inno 身份证和人是一对一的关系，在tb_person表中，card_id为外键，对应tb_card主键，且card_id唯一，就满足了一对一的关系。 2.POJO类 两个pojo类： 12345public class Card implements Serializable&#123; private Integer id; private String code; //getter，setter 12345678public class Person implements Serializable&#123; private Integer id; private String name; private String sex; private Integer age; private Card card; //getter,setter 3.mapper和mybatis-config.xml配置mapper配置：12345678//CardMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.CardMapper"&gt; &lt;select id="selectCardById" parameterType="int" resultType="org.fkit.domain.Card"&gt; SELECT * FROM tb_card WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617//PersonMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.PersonMapper"&gt; &lt;select id="selectPersonById" parameterType="int" resultMap="personMapper"&gt; select * from tb_person where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id="personMapper" type="org.fkit.domain.Person"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="age" column="age"/&gt; &lt;association property="card" column="card_id" select="org.fkit.mapper.CardMapper.selectCardById" javaType="org.fkit.domain.Card"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在此可以给PersonMapper设置一个接口：123456789101112//PersonMapper.javapackage org.fkit.mapper;import org.fkit.domain.Person;public interface PersonMapper &#123; /** * @param id * @return Person */ Person selectPersonById(Integer id);&#125; 在mybatis-config.xml中配置这2个mapper：12&lt;mapper resource="org/fkit/mapper/PersonMapper.xml"/&gt;&lt;mapper resource="org/fkit/mapper/CardMapper.xml"/&gt; 4.测试测试代码：12345678910//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); Person person = sqlSession.selectOne("org.fkit.mapper.PersonMapper.selectPersonById", 1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125; 因为设置了接口，也可以如此测试：123456789101112131415//OneToOneTset.javapublic class OneToOneTest &#123; public static void main(String args[])throws Exception &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); PersonMapper personMapper = session.getMapper(PersonMapper.class); Person person = personMapper.selectPersonById(1); System.out.println(person); &#125;&#125;//output:Person&#123;id=1, name='jack', sex='男', age=23, card=Card&#123;id=1, code='432801198009191038'&#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册登录测试]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.domain2.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping("/user")public class UserController &#123; private static List&lt;User&gt; userList; public UserController() &#123; super(); userList = new ArrayList&lt;User&gt;(); &#125; private static Log logger = LogFactory.getLog(UserController.class); @RequestMapping(value = "/register", method = RequestMethod.GET) public String requireForm() &#123; logger.info("register GET被调用"); System.out.println("register GET被调用"); return "registerForm"; &#125; @RequestMapping(value = "/register", method = RequestMethod.POST) public String register( @RequestParam("loginname") String loginname, @RequestParam("password") String password, @RequestParam("username") String username) &#123; logger.info("register POST被调用"); System.out.println("register POST被调用"); User user = new User(); user.setLoginname(loginname); user.setUsername(username); user.setPassword(password); userList.add(user); System.out.println(userList); return "loginForm"; &#125; @RequestMapping("/login") public String login( @RequestParam("loginname") String loginname, @RequestParam("password") String password, Model model)&#123; logger.info("登录名" + loginname + " 密码" + password); for (User user : userList) &#123; if (user.getLoginname().equals(loginname) &amp;&amp; user.getPassword().equals(password)) &#123; model.addAttribute("user", user); return "welcome"; &#125; &#125; return "loginForm"; &#125;&#125; springmvc-config2.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean name="/hello" class="org.fkit.controller.HelloController"/&gt;--&gt; &lt;context:component-scan base-package="org.fkit.controller"/&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;value&gt;/WEB-INF/content/&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-config2.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathVariable，RequestHeader，CookieValue注解测试]]></title>
    <url>%2F2018%2F11%2F14%2FPathVariable%EF%BC%8CRequestHeader%EF%BC%8CCookieValue%E6%B3%A8%E8%A7%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041package org.fkit.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DataBindingController &#123; private static final Log logger = LogFactory.getLog(DataBindingController.class); @RequestMapping(value = "/pathVariableTest/&#123;userId&#125;") public void pathVariableTest(@PathVariable Integer userId) &#123; logger.info("通过@PathVariable获得的数据：" + userId); &#125; @RequestMapping(value = "/requestHeaderTest") public void requestHeaderTest( @RequestHeader("User-Agent") String userAgent, @RequestHeader(value = "Accept") String[] accepts) &#123; logger.info("通过@requestHeaderTest获得的数据:" + userAgent); for (String accept : accepts) &#123; logger.info(accept); &#125; &#125; @RequestMapping(value = "/cookieValueTest") public void cookieValueTest( @CookieValue(value = "JSESSIONID", defaultValue = "") String sessionId) &#123; logger.info("通过@CookieValue获得的数据：" + sessionId); &#125; @RequestMapping(value = "/testWebsite") public String testWebsite()&#123; return "index"; &#125;&#125; jsp:1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: 34924 Date: 2018/8/1 Time: 22:40 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/pathVariableTest/1"&gt;测试注解1&lt;/a&gt;&lt;br&gt;&lt;a href="/requestHeaderTest"&gt;注解2&lt;/a&gt;&lt;br&gt;&lt;a href="/cookieValueTest"&gt;注解3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4.properties配置]]></title>
    <url>%2F2018%2F11%2F14%2Flog4-properties%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[放在WEB-INF的目录下：123456789101112131415161718192021222324# Logging levelsolr.log=$&#123;solr.solr.home&#125;/../logslog4j.rootLogger=INFO, filelog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%-4r [%t] %-5p %c %x \u2013 %m%n#- size rotation with log cleanup.log4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.MaxFileSize=4MBlog4j.appender.file.MaxBackupIndex=9#- File to log to and log formatlog4j.appender.file.File=$&#123;solr.log&#125;/solr.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%-5p - %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;; %C; %m\nlog4j.logger.org.apache.zookeeper=WARNlog4j.logger.org.apache.hadoop=WARN# set to INFO to enable infostream log messageslog4j.logger.org.apache.solr.update.LoggingInfoStream=OFF 在web.xml中配置：12345678910&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <categories>
        <category>日志配置</category>
      </categories>
      <tags>
        <tag>日志配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的router路由跳转获取url参数方法]]></title>
    <url>%2F2018%2F11%2F14%2Freact%E7%9A%84route%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[例如一个页面分为三块，导航栏，左栏右栏，左栏为页面跳转，右栏为显示list页面或者detail页面，如下所示： 如果使用如下代码进行路由，url改变了，但是接收不到：12345678910&lt;div className='content-right'&gt; &lt;Layout.Content &gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path='/development/list' component=&#123;Com_dev_list&#125; /&gt; &lt;Route path="/development/list:type" component=&#123;Com_dev_list&#125; /&gt; &lt;Route path='/development/detail:id' component=&#123;Com_dev_detail&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Layout.Content&gt; 使用component接收：12345678910componentWillReceiveProps(nextProps)&#123; axios.get(host + 'development/list/' + nextProps.match.params.type.replace(":type=","") +'/' +1).then( response =&gt; &#123; let items = response.data; items = items.list; this.setState(&#123;list:items&#125;); window.scrollTo(0, 0) &#125; );&#125; 实际上nextProps.match.params.type.replace(“:type=”,””)并未接收到url每次的改变，需要使用window.location.href，这样每次都可以接收到。但是是否真的这么暴力美学，还需要进行之后的学习。]]></content>
      <categories>
        <category>react</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解写法]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E6%B3%A8%E8%A7%A3%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.普通增删改查使用表：User在mybatis-config.xml里配置1&lt;mapper class="org.fkit.mapper.UserMapper"/&gt; 注释掉原来的xml配置路径。注解java类：123456789101112131415161718192021222324252627282930313233//UserMapper.javapackage org.fkit.mapper;import org.apache.ibatis.annotations.*;import org.fkit.domain.Clazz;import org.fkit.domain.User;import java.util.List;public interface UserMapper &#123; @Insert("insert into tb_user(name,sex,age) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;)") @Options(useGeneratedKeys = true, keyProperty = "id") int saveUser(User user); @Delete("delete from tb_user where id = #&#123;id&#125; or name = #&#123;cctv&#125;") int removeUser(@Param("id") Integer id, @Param("cctv") String n); @Update("update tb_user set name = #&#123;name&#125;,sex = #&#123;sex&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;") void modifyUser(User user); @Select("select * from tb_user where id = #&#123;id&#125;") @Results(&#123; @Result(id = true, column = "id", property = "id"), @Result(column = "name", property = "name"), @Result(column = "sex", property = "sex"), @Result(column = "age", property = "age") &#125;) User selectUserById(Integer id); @Select("select * from tb_user") List&lt;User&gt; selectAllUser();&#125; 测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//InsertTest.javapublic class InsertTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); User user = new User("1111jack", "男", 22); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.saveUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: insert into tb_user(name,sex,age) values(?,?,?) DEBUG [main] - ==&gt; Parameters: 1111jack(String), 男(String), 22(Integer)DEBUG [main] - &lt;== Updates: 1//DeleteTest.javapublic class DeleteTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.removeUser(16,"jack"); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: delete from tb_user where id = ? or name = ? DEBUG [main] - ==&gt; Parameters: 16(Integer), jack(String)DEBUG [main] - &lt;== Updates: 1//UpdateTest.javapublic class UpdateTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); user.setName("hello?"); userMapper.modifyUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: update tb_user set name = ?,sex = ?, age = ? where id = ? DEBUG [main] - ==&gt; Parameters: hello?(String), 男(String), 26(Integer), 12(Integer)DEBUG [main] - &lt;== Updates: 1//SelectTest.javapublic class SelectTest &#123; public static void main(String args[])&#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUserById(12); System.out.println(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user where id = ? DEBUG [main] - ==&gt; Parameters: 12(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=12, name='hello?', sex='男', age=26&#125;//SelectMapTest.javapublic class SelectMapTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession();// 获取user对象集 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAllUser(); for (User user : users) &#123; System.out.println(user); &#125; sqlSession.commit(); sqlSession.close(); &#125;&#125;//output:DEBUG [main] - ==&gt; Preparing: select * from tb_user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 10User&#123;id=1, name='hello?', sex='g', age=11&#125;User&#123;id=4, name='gg', sex='男', age=26&#125;User&#123;id=5, name='gg', sex='男', age=26&#125;User&#123;id=6, name='gg', sex='男', age=26&#125;User&#123;id=7, name='gg', sex='男', age=26&#125;User&#123;id=8, name='gg', sex='男', age=26&#125;User&#123;id=9, name='gg', sex='男', age=26&#125;User&#123;id=10, name='gg', sex='男', age=26&#125;User&#123;id=11, name='gg', sex='男', age=26&#125;User&#123;id=12, name='hello?', sex='男', age=26&#125;]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mabatis逆向工程]]></title>
    <url>%2F2018%2F11%2F13%2Fmabatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文使用idea编译器，安装Mybatisplus插件后可以使用逆向工程。 配置：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" &gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="C:/Users/34924/Desktop/mysql-connector-java-5.1.46.jar"/&gt; &lt;context id="context" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;property name="suppressDate" value="false"/&gt; &lt;/commentGenerator&gt; &lt;!--&lt;jdbcConnection userId="root" password="123456" driverClass="com.mysql.jdbc.Driver"--&gt; &lt;!--connectionURL="jdbc:mysql://localhost:3306/sss"/&gt;--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="org.model" targetProject="."&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="org.mapper" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="org.mapper" type="MIXEDMAPPER" targetProject="."&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;table schema="sn349245467" tableName="polls_question" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;table schema="sn349245467" tableName="polls_choice" enableCountByExample="false" enableDeleteByExample="false" enableUpdateByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注意：jdbc版本最好用5.x左右的，targetRuntime使用Mybatis3，使用简略版的会少东西。javaClientGenerator的type选用MIXEDMAPPER。 使用了逆向工程后，在一对多等关系的时候，需要把默认的查找方式由select param1,param2,…改为select *，以及改resultMap的BaseResultMap。]]></content>
      <categories>
        <category>java</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>java</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea创建maven项目时显示“Loading archetype list ”]]></title>
    <url>%2F2018%2F11%2F13%2Fidea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%98%BE%E7%A4%BA%E2%80%9CLoading%20archetype%20list%20%E2%80%9D%2F</url>
    <content type="text"><![CDATA[本文参考https://blog.csdn.net/u011403655/article/details/46843331 1.idea创建maven项目时一直显示“Loading archetype list ”删除{User_Home}/.IntelliJIdea{Version}/system/Maven/Indices下面的文件，然后重启idea。 2.IntelliJ IDEA 创建maven-archetype-webapp超时问题 File -&gt; Other Settings -&gt; Default Settings… Build, Execution, Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner, 在VM Options中填写如下 -DarchetypeCatalog=internal Apply -&gt; OK即可 3.创建完项目后命令行卡在 [INFO] Generating project in Batch modeMaven命令执行到Generating Project in Batch mode 卡住，原因是网络带宽不足，需要下载一个约4.1M的archetype-catalog.xml文件。 在maven的五分钟入门里面，有这样一个命令： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false这句话的命令是创建一个默认的项目，但我在执行这个命令时，命令行会停在 [INFO] Generating project in Batch mode这句话会停很久。【当然，也有人的一下就过去。】 增加一个-X参数，可以查看详细信息1mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -X 可以看到，程序停在了下面这一行。1[DEBUG] Searching for remote catalog: http://repo1.maven.org/maven2/archetype-catalog.xml 去查询这个文件的时候网络比较差或者其他原因，导致挂在那里。 解决方法很简单。 把上述地址复制到浏览器中，下载这个文件到本地。 把文件archetype-catalog.xml复制到目录.m2\repository\org\apache\maven\archetype\archetype-catalog\2.2下面。 在上述命令后增加参数-DarchetypeCatalog=local，变成读取本地文件即可。4.庆祝一下123456789101112131415161718192021[INFO] ----------------------------------------------------------------------------[INFO] Using following parameters for creating project from Archetype: maven-archetype-webapp:RELEASE[INFO] ----------------------------------------------------------------------------[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: packageInPathFormat, Value: com/ssm/study[INFO] Parameter: package, Value: com.ssm.study[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] Parameter: groupId, Value: com.ssm.study[INFO] Parameter: artifactId, Value: ssmframe[INFO] Project created from Archetype in dir: C:\Users\34924\AppData\Local\Temp\archetypetmp\ssmframe[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 16:09 min[INFO] Finished at: 2018-07-20T21:16:52+08:00[INFO] Final Memory: 12M/87M[INFO] ------------------------------------------------------------------------[INFO] Maven execution finished]]></content>
      <categories>
        <category>Maven</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态sql]]></title>
    <url>%2F2018%2F11%2F13%2FMybatis%E7%9A%84%E5%8A%A8%E6%80%81sql%2F</url>
    <content type="text"><![CDATA[本文是关于mybatis的早期使用方法。 0.前期准备123456789101112131415CREATE TABLE tb_employee( id INT AUTO_INCREMENT PRIMARY KEY, loginname VARCHAR(18) NULL, password VARCHAR(18) NULL, name VARCHAR(18) NULL, sex CHAR(2) NULL, age INT NULL, phone VARCHAR(21) NULL, sal DOUBLE NULL, state VARCHAR(18) NULL, CONSTRAINT tb_employee_id_uindex UNIQUE (id)) POJO类：123456789101112public class TbEmployee &#123; private long id; private String loginname; private String password; private String name; private String sex; private long age; private String phone; private double sal; private String state;//getter,setter 1.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.fkit.mapper.EmployeeMapper"&gt; &lt;select id="selectEmployeeByIdLike" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee &lt;where&gt; &lt;if test="id != null"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeChoose" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee &lt;where&gt; &lt;choose&gt; &lt;when test="id != null"&gt; and id = #&#123;id&#125; &lt;/when&gt; &lt;when test="loginname != null and password != null"&gt; and loginname = #&#123;loginname&#125; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and sex = '1' &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectEmployeeWithId" parameterType="int" resultType="org.fkit.domain.TbEmployee"&gt; SELECT * FROM tb_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;update id="updateEmployeeIfNecessary" parameterType="org.fkit.domain.TbEmployee"&gt; UPDATE tb_employee &lt;set&gt; &lt;if test="loginname != null"&gt;loginname = #&#123;loginname&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="sex != null"&gt;sex = #&#123;sex&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;if test="phone != null"&gt;phone = #&#123;phone&#125;,&lt;/if&gt; &lt;if test="sal != null"&gt;sal = #&#123;sal&#125;,&lt;/if&gt; &lt;if test="state != null"&gt;state = #&#123;state&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id="selectEmployeeIn" resultType="org.fkit.domain.TbEmployee"&gt; select * from tb_employee where id in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;select id="selectEmployeeLikeName" resultType="org.fkit.domain.TbEmployee"&gt; &lt;bind name="pattern" value="'%' + _parameter.getName() + '%'"/&gt; &lt;bind name="pattern2" value="'%' + _parameter.getLoginname() +'%' "/&gt; SELECT * FROM tb_employee where name like #&#123;pattern&#125; and loginname like #&#123;pattern2&#125; &lt;/select&gt;&lt;/mapper&gt; 2.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class DynamicSQLTest &#123; public static void main(String args[]) &#123; SqlSession sqlSession = FKSqlSessionFactory.getSqlSession(); DynamicSQLTest dynamicSQLTest = new DynamicSQLTest(); dynamicSQLTest.testSelectEmployeeByIdLike(sqlSession); dynamicSQLTest.testSelectEmployeeChoose(sqlSession); dynamicSQLTest.testUpdateEmployeeIfNecessary(sqlSession); dynamicSQLTest.testSelectEmployeeIn(sqlSession); dynamicSQLTest.testSelectEmployeeLikeName(sqlSession); sqlSession.commit(); sqlSession.close(); &#125; public void testSelectEmployeeByIdLike(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("id", 1); params.put("sex", 1); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeByIdLike(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeChoose(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); HashMap&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginname", "jack"); params.put("password", "123"); params.put("id", 2); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeChoose(params); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testUpdateEmployeeIfNecessary(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = employeeMapper.selectEmployeeWithId(1); System.out.println(tbEmployee); tbEmployee.setLoginname("newJack"); employeeMapper.updateEmployeeIfNecessary(tbEmployee); &#125; public void testSelectEmployeeIn(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); integers.add(1); integers.add(3); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeIn(integers); tbEmployees.forEach(tbEmployee -&gt; System.out.println(tbEmployee)); &#125; public void testSelectEmployeeLikeName(SqlSession sqlSession) &#123; EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); TbEmployee tbEmployee = new TbEmployee(); tbEmployee.setName("a"); tbEmployee.setLoginname("J"); List&lt;TbEmployee&gt; tbEmployees = employeeMapper.selectEmployeeLikeName(tbEmployee); tbEmployees.forEach(tbEmployee1 -&gt; System.out.println(tbEmployee1)); &#125;&#125; 12345678910111213141516171819202122232425//output:DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee WHERE id = ? and sex = ? DEBUG [main] - ==&gt; Parameters: 1(Integer), 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: select * from tb_employee WHERE id = ? DEBUG [main] - ==&gt; Parameters: 2(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=2, loginname='rose', password='456', name='rooose', sex='2', age=21, phone='654321', sal=1121.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;DEBUG [main] - ==&gt; Preparing: UPDATE tb_employee SET loginname = ?, password = ?, name = ?, sex = ?, age = ?, phone = ?, sal = ?, state = ? where id = ? DEBUG [main] - ==&gt; Parameters: newJack(String), 123(String), jaccck(String), 1(String), 26(Long), 123456(String), 3211.0(Double), active(String), 1(Long)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - ==&gt; Preparing: select * from tb_employee where id in ( ? , ? ) DEBUG [main] - ==&gt; Parameters: 1(Integer), 3(Integer)DEBUG [main] - &lt;== Total: 2TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125;TbEmployee&#123;id=3, loginname='tom', password='tom', name='tooom', sex='1', age=12, phone='132', sal=32.2, state='active'&#125;DEBUG [main] - ==&gt; Preparing: SELECT * FROM tb_employee where name like ? and loginname like ? DEBUG [main] - ==&gt; Parameters: %a%(String), %J%(String)DEBUG [main] - &lt;== Total: 1TbEmployee&#123;id=1, loginname='newJack', password='123', name='jaccck', sex='1', age=26, phone='123456', sal=3211.0, state='active'&#125; 使用like的另一种写法：123456789101112&lt;select id="getUsersByConditionIf" resultType="com.model.User" parameterType="com.model.User"&gt; select * from user where &lt;if test="id!=null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username !=''"&gt; or username like "%"#&#123;username&#125;"%" &lt;/if&gt; &lt;if test="sex != null"&gt; and sex = #&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 使用”%”#{parameter}”%”，运行结果如下：1234567891011DEBUG [main] - ==&gt; Preparing: select id, username,birthday, sex, address,dept_id from user where id = ? DEBUG [main] - ==&gt; Parameters: 27(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: select id, name from department where id = ? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;DEBUG [main] - ==&gt; Preparing: select * from user where id = ? or username like "%"?"%" and sex = ? DEBUG [main] - ==&gt; Parameters: 27(Integer), 1(String), 1(String)DEBUG [main] - &lt;== Total: 2[User&#123;id=27, username='tes111t', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;, User&#123;id=32, username='11231', birthday=Thu Jul 12 08:00:00 CST 2018, sex='1', address='1'&#125;] 要使每个都写为and xxx= #{xx}的形式，而不是第一个需要去掉and，可以在sql前面的语句中写为1select * from xxx where 1=1 这样保证每个都可以写为and xxx = #{xx}的形式。 也可以使用where标签将所有拼接的动态条件放入。 但是where只能去掉第一个and。 一次更新多条数据：1void addUsers(@Param("userList") List&lt;User&gt; userList); 123456&lt;insert id="addUsers" &gt; insert into user(username,address) VALUES &lt;foreach collection="userList" item="user" separator=","&gt; (#&#123;user.username&#125;,#&#123;user.address&#125;) &lt;/foreach&gt;&lt;/insert&gt; 需要插入别的字段需要自己加入。]]></content>
      <categories>
        <category>Mybatis</category>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范数]]></title>
    <url>%2F2018%2F11%2F13%2F%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[p-范数: $||x||_p = (|x_1|^p + |x_2|^p + |x_3|^3 + … + |x_n|^p)^{1/p} =\sqrt[p]{ \sum_{i=1}^n|x_i|^p}$ 2-范数(欧式范数): $||x||_2 = (|x_1|^2 + |x_2|^2 + |x_3|^2 + … + |x_n|^2)^{1/2} = \sqrt{ \sum_{i=1}^n x_i^2}$ ∞-范数: $||x||_∞ = max(x_1,x_2,x_3,…,x_n) = max_i|x_i|$ 1-范数即向量元素绝对值之和； 2-范数为Euclid范数（欧几里得范数，常用计算向量长度），即向量元素绝对值的平方和再开方； ∞-范数即所有向量元素绝对值中的最大值； -∞-范数即所有向量元素绝对值中的最小值； p-范数即向量元素绝对值的p次方和的1/p次幂。 可以参考：https://blog.csdn.net/susanzhang1231/article/details/52127011 https://www.jianshu.com/p/bf860ad177dd https://blog.csdn.net/bitcarmanlee/article/details/51945271]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>范数</tag>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
</search>
